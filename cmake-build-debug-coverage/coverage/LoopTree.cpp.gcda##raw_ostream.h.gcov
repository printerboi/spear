        -:    0:Source:/usr/include/llvm/Support/raw_ostream.h
        -:    0:Graph:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/src/main/include/LoopTree/LoopTree.cpp.gcno
        -:    0:Data:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/src/main/include/LoopTree/LoopTree.cpp.gcda
        -:    0:Runs:1
        -:    1://===--- raw_ostream.h - Raw output stream ----------------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9://  This file defines the raw_ostream class.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef LLVM_SUPPORT_RAW_OSTREAM_H
        -:   14:#define LLVM_SUPPORT_RAW_OSTREAM_H
        -:   15:
        -:   16:#include "llvm/ADT/SmallVector.h"
        -:   17:#include "llvm/ADT/StringRef.h"
        -:   18:#include "llvm/ADT/Optional.h"
        -:   19:#include "llvm/Support/DataTypes.h"
        -:   20:#include <cassert>
        -:   21:#include <cstddef>
        -:   22:#include <cstdint>
        -:   23:#include <cstring>
        -:   24:#include <string>
        -:   25:#if __cplusplus > 201402L
        -:   26:#include <string_view>
        -:   27:#endif
        -:   28:#include <system_error>
        -:   29:#include <type_traits>
        -:   30:
        -:   31:namespace llvm {
        -:   32:
        -:   33:class Duration;
        -:   34:class formatv_object_base;
        -:   35:class format_object_base;
        -:   36:class FormattedString;
        -:   37:class FormattedNumber;
        -:   38:class FormattedBytes;
        -:   39:template <class T> class LLVM_NODISCARD Expected;
        -:   40:
        -:   41:namespace sys {
        -:   42:namespace fs {
        -:   43:enum FileAccess : unsigned;
        -:   44:enum OpenFlags : unsigned;
        -:   45:enum CreationDisposition : unsigned;
        -:   46:class FileLocker;
        -:   47:} // end namespace fs
        -:   48:} // end namespace sys
        -:   49:
        -:   50:/// This class implements an extremely fast bulk output stream that can *only*
        -:   51:/// output to a stream.  It does not support seeking, reopening, rewinding, line
        -:   52:/// buffered disciplines etc. It is a simple buffer that outputs
        -:   53:/// a chunk at a time.
        -:   54:class raw_ostream {
        -:   55:public:
        -:   56:  // Class kinds to support LLVM-style RTTI.
        -:   57:  enum class OStreamKind {
        -:   58:    OK_OStream,
        -:   59:    OK_FDStream,
        -:   60:  };
        -:   61:
        -:   62:private:
        -:   63:  OStreamKind Kind;
        -:   64:
        -:   65:  /// The buffer is handled in such a way that the buffer is
        -:   66:  /// uninitialized, unbuffered, or out of space when OutBufCur >=
        -:   67:  /// OutBufEnd. Thus a single comparison suffices to determine if we
        -:   68:  /// need to take the slow path to write a single character.
        -:   69:  ///
        -:   70:  /// The buffer is in one of three states:
        -:   71:  ///  1. Unbuffered (BufferMode == Unbuffered)
        -:   72:  ///  1. Uninitialized (BufferMode != Unbuffered && OutBufStart == 0).
        -:   73:  ///  2. Buffered (BufferMode != Unbuffered && OutBufStart != 0 &&
        -:   74:  ///               OutBufEnd - OutBufStart >= 1).
        -:   75:  ///
        -:   76:  /// If buffered, then the raw_ostream owns the buffer if (BufferMode ==
        -:   77:  /// InternalBuffer); otherwise the buffer has been set via SetBuffer and is
        -:   78:  /// managed by the subclass.
        -:   79:  ///
        -:   80:  /// If a subclass installs an external buffer using SetBuffer then it can wait
        -:   81:  /// for a \see write_impl() call to handle the data which has been put into
        -:   82:  /// this buffer.
        -:   83:  char *OutBufStart, *OutBufEnd, *OutBufCur;
        -:   84:  bool ColorEnabled = false;
        -:   85:
        -:   86:  /// Optional stream this stream is tied to. If this stream is written to, the
        -:   87:  /// tied-to stream will be flushed first.
        -:   88:  raw_ostream *TiedStream = nullptr;
        -:   89:
        -:   90:  enum class BufferKind {
        -:   91:    Unbuffered = 0,
        -:   92:    InternalBuffer,
        -:   93:    ExternalBuffer
        -:   94:  } BufferMode;
        -:   95:
        -:   96:public:
        -:   97:  // color order matches ANSI escape sequence, don't change
        -:   98:  enum class Colors {
        -:   99:    BLACK = 0,
        -:  100:    RED,
        -:  101:    GREEN,
        -:  102:    YELLOW,
        -:  103:    BLUE,
        -:  104:    MAGENTA,
        -:  105:    CYAN,
        -:  106:    WHITE,
        -:  107:    SAVEDCOLOR,
        -:  108:    RESET,
        -:  109:  };
        -:  110:
        -:  111:  static constexpr Colors BLACK = Colors::BLACK;
        -:  112:  static constexpr Colors RED = Colors::RED;
        -:  113:  static constexpr Colors GREEN = Colors::GREEN;
        -:  114:  static constexpr Colors YELLOW = Colors::YELLOW;
        -:  115:  static constexpr Colors BLUE = Colors::BLUE;
        -:  116:  static constexpr Colors MAGENTA = Colors::MAGENTA;
        -:  117:  static constexpr Colors CYAN = Colors::CYAN;
        -:  118:  static constexpr Colors WHITE = Colors::WHITE;
        -:  119:  static constexpr Colors SAVEDCOLOR = Colors::SAVEDCOLOR;
        -:  120:  static constexpr Colors RESET = Colors::RESET;
        -:  121:
        -:  122:  explicit raw_ostream(bool unbuffered = false,
        -:  123:                       OStreamKind K = OStreamKind::OK_OStream)
        -:  124:      : Kind(K), BufferMode(unbuffered ? BufferKind::Unbuffered
        -:  125:                                       : BufferKind::InternalBuffer) {
        -:  126:    // Start out ready to flush.
        -:  127:    OutBufStart = OutBufEnd = OutBufCur = nullptr;
        -:  128:  }
        -:  129:
        -:  130:  raw_ostream(const raw_ostream &) = delete;
        -:  131:  void operator=(const raw_ostream &) = delete;
        -:  132:
        -:  133:  virtual ~raw_ostream();
        -:  134:
        -:  135:  /// tell - Return the current offset with the file.
        -:  136:  uint64_t tell() const { return current_pos() + GetNumBytesInBuffer(); }
        -:  137:
        -:  138:  OStreamKind get_kind() const { return Kind; }
        -:  139:
        -:  140:  //===--------------------------------------------------------------------===//
        -:  141:  // Configuration Interface
        -:  142:  //===--------------------------------------------------------------------===//
        -:  143:
        -:  144:  /// If possible, pre-allocate \p ExtraSize bytes for stream data.
        -:  145:  /// i.e. it extends internal buffers to keep additional ExtraSize bytes.
        -:  146:  /// So that the stream could keep at least tell() + ExtraSize bytes
        -:  147:  /// without re-allocations. reserveExtraSpace() does not change
        -:  148:  /// the size/data of the stream.
        -:  149:  virtual void reserveExtraSpace(uint64_t ExtraSize) {}
        -:  150:
        -:  151:  /// Set the stream to be buffered, with an automatically determined buffer
        -:  152:  /// size.
        -:  153:  void SetBuffered();
        -:  154:
        -:  155:  /// Set the stream to be buffered, using the specified buffer size.
        -:  156:  void SetBufferSize(size_t Size) {
        -:  157:    flush();
        -:  158:    SetBufferAndMode(new char[Size], Size, BufferKind::InternalBuffer);
        -:  159:  }
        -:  160:
        -:  161:  size_t GetBufferSize() const {
        -:  162:    // If we're supposed to be buffered but haven't actually gotten around
        -:  163:    // to allocating the buffer yet, return the value that would be used.
        -:  164:    if (BufferMode != BufferKind::Unbuffered && OutBufStart == nullptr)
        -:  165:      return preferred_buffer_size();
        -:  166:
        -:  167:    // Otherwise just return the size of the allocated buffer.
        -:  168:    return OutBufEnd - OutBufStart;
        -:  169:  }
        -:  170:
        -:  171:  /// Set the stream to be unbuffered. When unbuffered, the stream will flush
        -:  172:  /// after every write. This routine will also flush the buffer immediately
        -:  173:  /// when the stream is being set to unbuffered.
        -:  174:  void SetUnbuffered() {
        -:  175:    flush();
        -:  176:    SetBufferAndMode(nullptr, 0, BufferKind::Unbuffered);
        -:  177:  }
        -:  178:
        -:  179:  size_t GetNumBytesInBuffer() const {
        -:  180:    return OutBufCur - OutBufStart;
        -:  181:  }
        -:  182:
        -:  183:  //===--------------------------------------------------------------------===//
        -:  184:  // Data Output Interface
        -:  185:  //===--------------------------------------------------------------------===//
        -:  186:
        -:  187:  void flush() {
        -:  188:    if (OutBufCur != OutBufStart)
        -:  189:      flush_nonempty();
        -:  190:  }
        -:  191:
        -:  192:  raw_ostream &operator<<(char C) {
        -:  193:    if (OutBufCur >= OutBufEnd)
        -:  194:      return write(C);
        -:  195:    *OutBufCur++ = C;
        -:  196:    return *this;
        -:  197:  }
        -:  198:
        -:  199:  raw_ostream &operator<<(unsigned char C) {
        -:  200:    if (OutBufCur >= OutBufEnd)
        -:  201:      return write(C);
        -:  202:    *OutBufCur++ = C;
        -:  203:    return *this;
        -:  204:  }
        -:  205:
        -:  206:  raw_ostream &operator<<(signed char C) {
        -:  207:    if (OutBufCur >= OutBufEnd)
        -:  208:      return write(C);
        -:  209:    *OutBufCur++ = C;
        -:  210:    return *this;
        -:  211:  }
        -:  212:
function _ZN4llvm11raw_ostreamlsENS_9StringRefE called 0 returned 0% blocks executed 0%
    #####:  213:  raw_ostream &operator<<(StringRef Str) {
        -:  214:    // Inline fast path, particularly for strings with a known length.
    #####:  215:    size_t Size = Str.size();
    %%%%%:  215-block  0
Aufruf  0 niemals ausgeführt
        -:  216:
        -:  217:    // Make sure we can use the fast path.
    #####:  218:    if (Size > (size_t)(OutBufEnd - OutBufCur))
Zweig  0 niemals ausgeführt
Zweig  1 niemals ausgeführt
    #####:  219:      return write(Str.data(), Size);
    %%%%%:  219-block  0
Aufruf  0 niemals ausgeführt
Aufruf  1 niemals ausgeführt
        -:  220:
    #####:  221:    if (Size) {
    %%%%%:  221-block  0
Zweig  0 niemals ausgeführt
Zweig  1 niemals ausgeführt
    #####:  222:      memcpy(OutBufCur, Str.data(), Size);
    %%%%%:  222-block  0
Aufruf  0 niemals ausgeführt
    #####:  223:      OutBufCur += Size;
        -:  224:    }
    #####:  225:    return *this;
    %%%%%:  225-block  0
        -:  226:  }
        -:  227:
function _ZN4llvm11raw_ostreamlsEPKc called 0 returned 0% blocks executed 0%
    #####:  228:  raw_ostream &operator<<(const char *Str) {
        -:  229:    // Inline fast path, particularly for constant strings where a sufficiently
        -:  230:    // smart compiler will simplify strlen.
        -:  231:
    #####:  232:    return this->operator<<(StringRef(Str));
    %%%%%:  232-block  0
Aufruf  0 niemals ausgeführt
Zweig  1 niemals ausgeführt
Zweig  2 niemals ausgeführt
    %%%%%:  232-block  1
Aufruf  3 niemals ausgeführt
Zweig  4 niemals ausgeführt
Zweig  5 niemals ausgeführt
    %%%%%:  232-block  2
    %%%%%:  232-block  3
    %%%%%:  232-block  4
        -:  233:  }
        -:  234:
        -:  235:  raw_ostream &operator<<(const std::string &Str) {
        -:  236:    // Avoid the fast path, it would only increase code size for a marginal win.
        -:  237:    return write(Str.data(), Str.length());
        -:  238:  }
        -:  239:
        -:  240:#if __cplusplus > 201402L
        -:  241:  raw_ostream &operator<<(const std::string_view &Str) {
        -:  242:    return write(Str.data(), Str.length());
        -:  243:  }
        -:  244:#endif
        -:  245:
        -:  246:  raw_ostream &operator<<(const SmallVectorImpl<char> &Str) {
        -:  247:    return write(Str.data(), Str.size());
        -:  248:  }
        -:  249:
        -:  250:  raw_ostream &operator<<(unsigned long N);
        -:  251:  raw_ostream &operator<<(long N);
        -:  252:  raw_ostream &operator<<(unsigned long long N);
        -:  253:  raw_ostream &operator<<(long long N);
        -:  254:  raw_ostream &operator<<(const void *P);
        -:  255:
        -:  256:  raw_ostream &operator<<(unsigned int N) {
        -:  257:    return this->operator<<(static_cast<unsigned long>(N));
        -:  258:  }
        -:  259:
        -:  260:  raw_ostream &operator<<(int N) {
        -:  261:    return this->operator<<(static_cast<long>(N));
        -:  262:  }
        -:  263:
        -:  264:  raw_ostream &operator<<(double N);
        -:  265:
        -:  266:  /// Output \p N in hexadecimal, without any prefix or padding.
        -:  267:  raw_ostream &write_hex(unsigned long long N);
        -:  268:
        -:  269:  // Change the foreground color of text.
        -:  270:  raw_ostream &operator<<(Colors C);
        -:  271:
        -:  272:  /// Output a formatted UUID with dash separators.
        -:  273:  using uuid_t = uint8_t[16];
        -:  274:  raw_ostream &write_uuid(const uuid_t UUID);
        -:  275:
        -:  276:  /// Output \p Str, turning '\\', '\t', '\n', '"', and anything that doesn't
        -:  277:  /// satisfy llvm::isPrint into an escape sequence.
        -:  278:  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);
        -:  279:
        -:  280:  raw_ostream &write(unsigned char C);
        -:  281:  raw_ostream &write(const char *Ptr, size_t Size);
        -:  282:
        -:  283:  // Formatted output, see the format() function in Support/Format.h.
        -:  284:  raw_ostream &operator<<(const format_object_base &Fmt);
        -:  285:
        -:  286:  // Formatted output, see the leftJustify() function in Support/Format.h.
        -:  287:  raw_ostream &operator<<(const FormattedString &);
        -:  288:
        -:  289:  // Formatted output, see the formatHex() function in Support/Format.h.
        -:  290:  raw_ostream &operator<<(const FormattedNumber &);
        -:  291:
        -:  292:  // Formatted output, see the formatv() function in Support/FormatVariadic.h.
        -:  293:  raw_ostream &operator<<(const formatv_object_base &);
        -:  294:
        -:  295:  // Formatted output, see the format_bytes() function in Support/Format.h.
        -:  296:  raw_ostream &operator<<(const FormattedBytes &);
        -:  297:
        -:  298:  /// indent - Insert 'NumSpaces' spaces.
        -:  299:  raw_ostream &indent(unsigned NumSpaces);
        -:  300:
        -:  301:  /// write_zeros - Insert 'NumZeros' nulls.
        -:  302:  raw_ostream &write_zeros(unsigned NumZeros);
        -:  303:
        -:  304:  /// Changes the foreground color of text that will be output from this point
        -:  305:  /// forward.
        -:  306:  /// @param Color ANSI color to use, the special SAVEDCOLOR can be used to
        -:  307:  /// change only the bold attribute, and keep colors untouched
        -:  308:  /// @param Bold bold/brighter text, default false
        -:  309:  /// @param BG if true change the background, default: change foreground
        -:  310:  /// @returns itself so it can be used within << invocations
        -:  311:  virtual raw_ostream &changeColor(enum Colors Color, bool Bold = false,
        -:  312:                                   bool BG = false);
        -:  313:
        -:  314:  /// Resets the colors to terminal defaults. Call this when you are done
        -:  315:  /// outputting colored text, or before program exit.
        -:  316:  virtual raw_ostream &resetColor();
        -:  317:
        -:  318:  /// Reverses the foreground and background colors.
        -:  319:  virtual raw_ostream &reverseColor();
        -:  320:
        -:  321:  /// This function determines if this stream is connected to a "tty" or
        -:  322:  /// "console" window. That is, the output would be displayed to the user
        -:  323:  /// rather than being put on a pipe or stored in a file.
        -:  324:  virtual bool is_displayed() const { return false; }
        -:  325:
        -:  326:  /// This function determines if this stream is displayed and supports colors.
        -:  327:  /// The result is unaffected by calls to enable_color().
        -:  328:  virtual bool has_colors() const { return is_displayed(); }
        -:  329:
        -:  330:  // Enable or disable colors. Once enable_colors(false) is called,
        -:  331:  // changeColor() has no effect until enable_colors(true) is called.
        -:  332:  virtual void enable_colors(bool enable) { ColorEnabled = enable; }
        -:  333:
        -:  334:  bool colors_enabled() const { return ColorEnabled; }
        -:  335:
        -:  336:  /// Tie this stream to the specified stream. Replaces any existing tied-to
        -:  337:  /// stream. Specifying a nullptr unties the stream.
        -:  338:  void tie(raw_ostream *TieTo) { TiedStream = TieTo; }
        -:  339:
        -:  340:  //===--------------------------------------------------------------------===//
        -:  341:  // Subclass Interface
        -:  342:  //===--------------------------------------------------------------------===//
        -:  343:
        -:  344:private:
        -:  345:  /// The is the piece of the class that is implemented by subclasses.  This
        -:  346:  /// writes the \p Size bytes starting at
        -:  347:  /// \p Ptr to the underlying stream.
        -:  348:  ///
        -:  349:  /// This function is guaranteed to only be called at a point at which it is
        -:  350:  /// safe for the subclass to install a new buffer via SetBuffer.
        -:  351:  ///
        -:  352:  /// \param Ptr The start of the data to be written. For buffered streams this
        -:  353:  /// is guaranteed to be the start of the buffer.
        -:  354:  ///
        -:  355:  /// \param Size The number of bytes to be written.
        -:  356:  ///
        -:  357:  /// \invariant { Size > 0 }
        -:  358:  virtual void write_impl(const char *Ptr, size_t Size) = 0;
        -:  359:
        -:  360:  /// Return the current position within the stream, not counting the bytes
        -:  361:  /// currently in the buffer.
        -:  362:  virtual uint64_t current_pos() const = 0;
        -:  363:
        -:  364:protected:
        -:  365:  /// Use the provided buffer as the raw_ostream buffer. This is intended for
        -:  366:  /// use only by subclasses which can arrange for the output to go directly
        -:  367:  /// into the desired output buffer, instead of being copied on each flush.
        -:  368:  void SetBuffer(char *BufferStart, size_t Size) {
        -:  369:    SetBufferAndMode(BufferStart, Size, BufferKind::ExternalBuffer);
        -:  370:  }
        -:  371:
        -:  372:  /// Return an efficient buffer size for the underlying output mechanism.
        -:  373:  virtual size_t preferred_buffer_size() const;
        -:  374:
        -:  375:  /// Return the beginning of the current stream buffer, or 0 if the stream is
        -:  376:  /// unbuffered.
        -:  377:  const char *getBufferStart() const { return OutBufStart; }
        -:  378:
        -:  379:  //===--------------------------------------------------------------------===//
        -:  380:  // Private Interface
        -:  381:  //===--------------------------------------------------------------------===//
        -:  382:private:
        -:  383:  /// Install the given buffer and mode.
        -:  384:  void SetBufferAndMode(char *BufferStart, size_t Size, BufferKind Mode);
        -:  385:
        -:  386:  /// Flush the current buffer, which is known to be non-empty. This outputs the
        -:  387:  /// currently buffered data and resets the buffer to empty.
        -:  388:  void flush_nonempty();
        -:  389:
        -:  390:  /// Copy data into the buffer. Size must not be greater than the number of
        -:  391:  /// unused bytes in the buffer.
        -:  392:  void copy_to_buffer(const char *Ptr, size_t Size);
        -:  393:
        -:  394:  /// Compute whether colors should be used and do the necessary work such as
        -:  395:  /// flushing. The result is affected by calls to enable_color().
        -:  396:  bool prepare_colors();
        -:  397:
        -:  398:  /// Flush the tied-to stream (if present) and then write the required data.
        -:  399:  void flush_tied_then_write(const char *Ptr, size_t Size);
        -:  400:
        -:  401:  virtual void anchor();
        -:  402:};
        -:  403:
        -:  404:/// Call the appropriate insertion operator, given an rvalue reference to a
        -:  405:/// raw_ostream object and return a stream of the same type as the argument.
        -:  406:template <typename OStream, typename T>
        -:  407:std::enable_if_t<!std::is_reference<OStream>::value &&
        -:  408:                     std::is_base_of<raw_ostream, OStream>::value,
        -:  409:                 OStream &&>
        -:  410:operator<<(OStream &&OS, const T &Value) {
        -:  411:  OS << Value;
        -:  412:  return std::move(OS);
        -:  413:}
        -:  414:
        -:  415:/// An abstract base class for streams implementations that also support a
        -:  416:/// pwrite operation. This is useful for code that can mostly stream out data,
        -:  417:/// but needs to patch in a header that needs to know the output size.
        -:  418:class raw_pwrite_stream : public raw_ostream {
        -:  419:  virtual void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) = 0;
        -:  420:  void anchor() override;
        -:  421:
        -:  422:public:
        -:  423:  explicit raw_pwrite_stream(bool Unbuffered = false,
        -:  424:                             OStreamKind K = OStreamKind::OK_OStream)
        -:  425:      : raw_ostream(Unbuffered, K) {}
        -:  426:  void pwrite(const char *Ptr, size_t Size, uint64_t Offset) {
        -:  427:#ifndef NDEBUG
        -:  428:    uint64_t Pos = tell();
        -:  429:    // /dev/null always reports a pos of 0, so we cannot perform this check
        -:  430:    // in that case.
        -:  431:    if (Pos)
        -:  432:      assert(Size + Offset <= Pos && "We don't support extending the stream");
        -:  433:#endif
        -:  434:    pwrite_impl(Ptr, Size, Offset);
        -:  435:  }
        -:  436:};
        -:  437:
        -:  438://===----------------------------------------------------------------------===//
        -:  439:// File Output Streams
        -:  440://===----------------------------------------------------------------------===//
        -:  441:
        -:  442:/// A raw_ostream that writes to a file descriptor.
        -:  443:///
        -:  444:class raw_fd_ostream : public raw_pwrite_stream {
        -:  445:  int FD;
        -:  446:  bool ShouldClose;
        -:  447:  bool SupportsSeeking = false;
        -:  448:  bool IsRegularFile = false;
        -:  449:  mutable Optional<bool> HasColors;
        -:  450:
        -:  451:#ifdef _WIN32
        -:  452:  /// True if this fd refers to a Windows console device. Mintty and other
        -:  453:  /// terminal emulators are TTYs, but they are not consoles.
        -:  454:  bool IsWindowsConsole = false;
        -:  455:#endif
        -:  456:
        -:  457:  std::error_code EC;
        -:  458:
        -:  459:  uint64_t pos = 0;
        -:  460:
        -:  461:  /// See raw_ostream::write_impl.
        -:  462:  void write_impl(const char *Ptr, size_t Size) override;
        -:  463:
        -:  464:  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;
        -:  465:
        -:  466:  /// Return the current position within the stream, not counting the bytes
        -:  467:  /// currently in the buffer.
        -:  468:  uint64_t current_pos() const override { return pos; }
        -:  469:
        -:  470:  /// Determine an efficient buffer size.
        -:  471:  size_t preferred_buffer_size() const override;
        -:  472:
        -:  473:  void anchor() override;
        -:  474:
        -:  475:protected:
        -:  476:  /// Set the flag indicating that an output error has been encountered.
        -:  477:  void error_detected(std::error_code EC) { this->EC = EC; }
        -:  478:
        -:  479:  /// Return the file descriptor.
        -:  480:  int get_fd() const { return FD; }
        -:  481:
        -:  482:  // Update the file position by increasing \p Delta.
        -:  483:  void inc_pos(uint64_t Delta) { pos += Delta; }
        -:  484:
        -:  485:public:
        -:  486:  /// Open the specified file for writing. If an error occurs, information
        -:  487:  /// about the error is put into EC, and the stream should be immediately
        -:  488:  /// destroyed;
        -:  489:  /// \p Flags allows optional flags to control how the file will be opened.
        -:  490:  ///
        -:  491:  /// As a special case, if Filename is "-", then the stream will use
        -:  492:  /// STDOUT_FILENO instead of opening a file. This will not close the stdout
        -:  493:  /// descriptor.
        -:  494:  raw_fd_ostream(StringRef Filename, std::error_code &EC);
        -:  495:  raw_fd_ostream(StringRef Filename, std::error_code &EC,
        -:  496:                 sys::fs::CreationDisposition Disp);
        -:  497:  raw_fd_ostream(StringRef Filename, std::error_code &EC,
        -:  498:                 sys::fs::FileAccess Access);
        -:  499:  raw_fd_ostream(StringRef Filename, std::error_code &EC,
        -:  500:                 sys::fs::OpenFlags Flags);
        -:  501:  raw_fd_ostream(StringRef Filename, std::error_code &EC,
        -:  502:                 sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
        -:  503:                 sys::fs::OpenFlags Flags);
        -:  504:
        -:  505:  /// FD is the file descriptor that this writes to.  If ShouldClose is true,
        -:  506:  /// this closes the file when the stream is destroyed. If FD is for stdout or
        -:  507:  /// stderr, it will not be closed.
        -:  508:  raw_fd_ostream(int fd, bool shouldClose, bool unbuffered = false,
        -:  509:                 OStreamKind K = OStreamKind::OK_OStream);
        -:  510:
        -:  511:  ~raw_fd_ostream() override;
        -:  512:
        -:  513:  /// Manually flush the stream and close the file. Note that this does not call
        -:  514:  /// fsync.
        -:  515:  void close();
        -:  516:
        -:  517:  bool supportsSeeking() const { return SupportsSeeking; }
        -:  518:
        -:  519:  bool isRegularFile() const { return IsRegularFile; }
        -:  520:
        -:  521:  /// Flushes the stream and repositions the underlying file descriptor position
        -:  522:  /// to the offset specified from the beginning of the file.
        -:  523:  uint64_t seek(uint64_t off);
        -:  524:
        -:  525:  bool is_displayed() const override;
        -:  526:
        -:  527:  bool has_colors() const override;
        -:  528:
        -:  529:  std::error_code error() const { return EC; }
        -:  530:
        -:  531:  /// Return the value of the flag in this raw_fd_ostream indicating whether an
        -:  532:  /// output error has been encountered.
        -:  533:  /// This doesn't implicitly flush any pending output.  Also, it doesn't
        -:  534:  /// guarantee to detect all errors unless the stream has been closed.
        -:  535:  bool has_error() const { return bool(EC); }
        -:  536:
        -:  537:  /// Set the flag read by has_error() to false. If the error flag is set at the
        -:  538:  /// time when this raw_ostream's destructor is called, report_fatal_error is
        -:  539:  /// called to report the error. Use clear_error() after handling the error to
        -:  540:  /// avoid this behavior.
        -:  541:  ///
        -:  542:  ///   "Errors should never pass silently.
        -:  543:  ///    Unless explicitly silenced."
        -:  544:  ///      - from The Zen of Python, by Tim Peters
        -:  545:  ///
        -:  546:  void clear_error() { EC = std::error_code(); }
        -:  547:
        -:  548:  /// Locks the underlying file.
        -:  549:  ///
        -:  550:  /// @returns RAII object that releases the lock upon leaving the scope, if the
        -:  551:  ///          locking was successful. Otherwise returns corresponding
        -:  552:  ///          error code.
        -:  553:  ///
        -:  554:  /// The function blocks the current thread until the lock become available or
        -:  555:  /// error occurs.
        -:  556:  ///
        -:  557:  /// Possible use of this function may be as follows:
        -:  558:  ///
        -:  559:  ///   @code{.cpp}
        -:  560:  ///   if (auto L = stream.lock()) {
        -:  561:  ///     // ... do action that require file to be locked.
        -:  562:  ///   } else {
        -:  563:  ///     handleAllErrors(std::move(L.takeError()), [&](ErrorInfoBase &EIB) {
        -:  564:  ///       // ... handle lock error.
        -:  565:  ///     });
        -:  566:  ///   }
        -:  567:  ///   @endcode
        -:  568:  LLVM_NODISCARD Expected<sys::fs::FileLocker> lock();
        -:  569:
        -:  570:  /// Tries to lock the underlying file within the specified period.
        -:  571:  ///
        -:  572:  /// @returns RAII object that releases the lock upon leaving the scope, if the
        -:  573:  ///          locking was successful. Otherwise returns corresponding
        -:  574:  ///          error code.
        -:  575:  ///
        -:  576:  /// It is used as @ref lock.
        -:  577:  LLVM_NODISCARD
        -:  578:  Expected<sys::fs::FileLocker> tryLockFor(Duration const& Timeout);
        -:  579:};
        -:  580:
        -:  581:/// This returns a reference to a raw_fd_ostream for standard output. Use it
        -:  582:/// like: outs() << "foo" << "bar";
        -:  583:raw_fd_ostream &outs();
        -:  584:
        -:  585:/// This returns a reference to a raw_ostream for standard error.
        -:  586:/// Use it like: errs() << "foo" << "bar";
        -:  587:/// By default, the stream is tied to stdout to ensure stdout is flushed before
        -:  588:/// stderr is written, to ensure the error messages are written in their
        -:  589:/// expected place.
        -:  590:raw_fd_ostream &errs();
        -:  591:
        -:  592:/// This returns a reference to a raw_ostream which simply discards output.
        -:  593:raw_ostream &nulls();
        -:  594:
        -:  595://===----------------------------------------------------------------------===//
        -:  596:// File Streams
        -:  597://===----------------------------------------------------------------------===//
        -:  598:
        -:  599:/// A raw_ostream of a file for reading/writing/seeking.
        -:  600:///
        -:  601:class raw_fd_stream : public raw_fd_ostream {
        -:  602:public:
        -:  603:  /// Open the specified file for reading/writing/seeking. If an error occurs,
        -:  604:  /// information about the error is put into EC, and the stream should be
        -:  605:  /// immediately destroyed.
        -:  606:  raw_fd_stream(StringRef Filename, std::error_code &EC);
        -:  607:
        -:  608:  /// This reads the \p Size bytes into a buffer pointed by \p Ptr.
        -:  609:  ///
        -:  610:  /// \param Ptr The start of the buffer to hold data to be read.
        -:  611:  ///
        -:  612:  /// \param Size The number of bytes to be read.
        -:  613:  ///
        -:  614:  /// On success, the number of bytes read is returned, and the file position is
        -:  615:  /// advanced by this number. On error, -1 is returned, use error() to get the
        -:  616:  /// error code.
        -:  617:  ssize_t read(char *Ptr, size_t Size);
        -:  618:
        -:  619:  /// Check if \p OS is a pointer of type raw_fd_stream*.
        -:  620:  static bool classof(const raw_ostream *OS);
        -:  621:};
        -:  622:
        -:  623://===----------------------------------------------------------------------===//
        -:  624:// Output Stream Adaptors
        -:  625://===----------------------------------------------------------------------===//
        -:  626:
        -:  627:/// A raw_ostream that writes to an std::string.  This is a simple adaptor
        -:  628:/// class. This class does not encounter output errors.
        -:  629:/// raw_string_ostream operates without a buffer, delegating all memory
        -:  630:/// management to the std::string. Thus the std::string is always up-to-date,
        -:  631:/// may be used directly and there is no need to call flush().
        -:  632:class raw_string_ostream : public raw_ostream {
        -:  633:  std::string &OS;
        -:  634:
        -:  635:  /// See raw_ostream::write_impl.
        -:  636:  void write_impl(const char *Ptr, size_t Size) override;
        -:  637:
        -:  638:  /// Return the current position within the stream, not counting the bytes
        -:  639:  /// currently in the buffer.
        -:  640:  uint64_t current_pos() const override { return OS.size(); }
        -:  641:
        -:  642:public:
        -:  643:  explicit raw_string_ostream(std::string &O) : OS(O) {
        -:  644:    SetUnbuffered();
        -:  645:  }
        -:  646:
        -:  647:  /// Returns the string's reference. In most cases it is better to simply use
        -:  648:  /// the underlying std::string directly.
        -:  649:  /// TODO: Consider removing this API.
        -:  650:  std::string &str() { return OS; }
        -:  651:
        -:  652:  void reserveExtraSpace(uint64_t ExtraSize) override {
        -:  653:    OS.reserve(tell() + ExtraSize);
        -:  654:  }
        -:  655:};
        -:  656:
        -:  657:/// A raw_ostream that writes to an SmallVector or SmallString.  This is a
        -:  658:/// simple adaptor class. This class does not encounter output errors.
        -:  659:/// raw_svector_ostream operates without a buffer, delegating all memory
        -:  660:/// management to the SmallString. Thus the SmallString is always up-to-date,
        -:  661:/// may be used directly and there is no need to call flush().
        -:  662:class raw_svector_ostream : public raw_pwrite_stream {
        -:  663:  SmallVectorImpl<char> &OS;
        -:  664:
        -:  665:  /// See raw_ostream::write_impl.
        -:  666:  void write_impl(const char *Ptr, size_t Size) override;
        -:  667:
        -:  668:  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;
        -:  669:
        -:  670:  /// Return the current position within the stream.
        -:  671:  uint64_t current_pos() const override;
        -:  672:
        -:  673:public:
        -:  674:  /// Construct a new raw_svector_ostream.
        -:  675:  ///
        -:  676:  /// \param O The vector to write to; this should generally have at least 128
        -:  677:  /// bytes free to avoid any extraneous memory overhead.
        -:  678:  explicit raw_svector_ostream(SmallVectorImpl<char> &O) : OS(O) {
        -:  679:    SetUnbuffered();
        -:  680:  }
        -:  681:
        -:  682:  ~raw_svector_ostream() override = default;
        -:  683:
        -:  684:  void flush() = delete;
        -:  685:
        -:  686:  /// Return a StringRef for the vector contents.
        -:  687:  StringRef str() const { return StringRef(OS.data(), OS.size()); }
        -:  688:
        -:  689:  void reserveExtraSpace(uint64_t ExtraSize) override {
        -:  690:    OS.reserve(tell() + ExtraSize);
        -:  691:  }
        -:  692:};
        -:  693:
        -:  694:/// A raw_ostream that discards all output.
        -:  695:class raw_null_ostream : public raw_pwrite_stream {
        -:  696:  /// See raw_ostream::write_impl.
        -:  697:  void write_impl(const char *Ptr, size_t size) override;
        -:  698:  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;
        -:  699:
        -:  700:  /// Return the current position within the stream, not counting the bytes
        -:  701:  /// currently in the buffer.
        -:  702:  uint64_t current_pos() const override;
        -:  703:
        -:  704:public:
        -:  705:  explicit raw_null_ostream() = default;
        -:  706:  ~raw_null_ostream() override;
        -:  707:};
        -:  708:
        -:  709:class buffer_ostream : public raw_svector_ostream {
        -:  710:  raw_ostream &OS;
        -:  711:  SmallVector<char, 0> Buffer;
        -:  712:
        -:  713:  void anchor() override;
        -:  714:
        -:  715:public:
        -:  716:  buffer_ostream(raw_ostream &OS) : raw_svector_ostream(Buffer), OS(OS) {}
        -:  717:  ~buffer_ostream() override { OS << str(); }
        -:  718:};
        -:  719:
        -:  720:class buffer_unique_ostream : public raw_svector_ostream {
        -:  721:  std::unique_ptr<raw_ostream> OS;
        -:  722:  SmallVector<char, 0> Buffer;
        -:  723:
        -:  724:  void anchor() override;
        -:  725:
        -:  726:public:
        -:  727:  buffer_unique_ostream(std::unique_ptr<raw_ostream> OS)
        -:  728:      : raw_svector_ostream(Buffer), OS(std::move(OS)) {
        -:  729:    // Turn off buffering on OS, which we now own, to avoid allocating a buffer
        -:  730:    // when the destructor writes only to be immediately flushed again.
        -:  731:    this->OS->SetUnbuffered();
        -:  732:  }
        -:  733:  ~buffer_unique_ostream() override { *OS << str(); }
        -:  734:};
        -:  735:
        -:  736:class Error;
        -:  737:
        -:  738:/// This helper creates an output stream and then passes it to \p Write.
        -:  739:/// The stream created is based on the specified \p OutputFileName:
        -:  740:/// llvm::outs for "-", raw_null_ostream for "/dev/null", and raw_fd_ostream
        -:  741:/// for other names. For raw_fd_ostream instances, the stream writes to
        -:  742:/// a temporary file. The final output file is atomically replaced with the
        -:  743:/// temporary file after the \p Write function is finished.
        -:  744:Error writeToOutput(StringRef OutputFileName,
        -:  745:                    std::function<Error(raw_ostream &)> Write);
        -:  746:
        -:  747:} // end namespace llvm
        -:  748:
        -:  749:#endif // LLVM_SUPPORT_RAW_OSTREAM_H
