        -:    0:Source:/usr/include/llvm/IR/Function.h
        -:    0:Graph:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/main.cpp.gcno
        -:    0:Data:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    1://===- llvm/Function.h - Class to represent a single function ---*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains the declaration of the Function class, which represents a
        -:   10:// single function/procedure in LLVM.
        -:   11://
        -:   12:// A function basically consists of a list of basic blocks, a list of arguments,
        -:   13:// and a symbol table.
        -:   14://
        -:   15://===----------------------------------------------------------------------===//
        -:   16:
        -:   17:#ifndef LLVM_IR_FUNCTION_H
        -:   18:#define LLVM_IR_FUNCTION_H
        -:   19:
        -:   20:#include "llvm/ADT/DenseSet.h"
        -:   21:#include "llvm/ADT/StringRef.h"
        -:   22:#include "llvm/ADT/Twine.h"
        -:   23:#include "llvm/ADT/ilist_node.h"
        -:   24:#include "llvm/ADT/iterator_range.h"
        -:   25:#include "llvm/IR/Argument.h"
        -:   26:#include "llvm/IR/Attributes.h"
        -:   27:#include "llvm/IR/BasicBlock.h"
        -:   28:#include "llvm/IR/CallingConv.h"
        -:   29:#include "llvm/IR/DerivedTypes.h"
        -:   30:#include "llvm/IR/GlobalObject.h"
        -:   31:#include "llvm/IR/GlobalValue.h"
        -:   32:#include "llvm/IR/OperandTraits.h"
        -:   33:#include "llvm/IR/SymbolTableListTraits.h"
        -:   34:#include "llvm/IR/Value.h"
        -:   35:#include <cassert>
        -:   36:#include <cstddef>
        -:   37:#include <cstdint>
        -:   38:#include <memory>
        -:   39:#include <string>
        -:   40:
        -:   41:namespace llvm {
        -:   42:
        -:   43:namespace Intrinsic {
        -:   44:typedef unsigned ID;
        -:   45:}
        -:   46:
        -:   47:class AssemblyAnnotationWriter;
        -:   48:class Constant;
        -:   49:struct DenormalMode;
        -:   50:class DISubprogram;
        -:   51:class LLVMContext;
        -:   52:class Module;
        -:   53:template <typename T> class Optional;
        -:   54:class raw_ostream;
        -:   55:class Type;
        -:   56:class User;
        -:   57:class BranchProbabilityInfo;
        -:   58:class BlockFrequencyInfo;
        -:   59:
        -:   60:class LLVM_EXTERNAL_VISIBILITY Function : public GlobalObject,
        -:   61:                                          public ilist_node<Function> {
        -:   62:public:
        -:   63:  using BasicBlockListType = SymbolTableList<BasicBlock>;
        -:   64:
        -:   65:  // BasicBlock iterators...
        -:   66:  using iterator = BasicBlockListType::iterator;
        -:   67:  using const_iterator = BasicBlockListType::const_iterator;
        -:   68:
        -:   69:  using arg_iterator = Argument *;
        -:   70:  using const_arg_iterator = const Argument *;
        -:   71:
        -:   72:private:
        -:   73:  // Important things that make up a function!
        -:   74:  BasicBlockListType BasicBlocks;         ///< The basic blocks
        -:   75:  mutable Argument *Arguments = nullptr;  ///< The formal arguments
        -:   76:  size_t NumArgs;
        -:   77:  std::unique_ptr<ValueSymbolTable>
        -:   78:      SymTab;                             ///< Symbol table of args/instructions
        -:   79:  AttributeList AttributeSets;            ///< Parameter attributes
        -:   80:
        -:   81:  /*
        -:   82:   * Value::SubclassData
        -:   83:   *
        -:   84:   * bit 0      : HasLazyArguments
        -:   85:   * bit 1      : HasPrefixData
        -:   86:   * bit 2      : HasPrologueData
        -:   87:   * bit 3      : HasPersonalityFn
        -:   88:   * bits 4-13  : CallingConvention
        -:   89:   * bits 14    : HasGC
        -:   90:   * bits 15 : [reserved]
        -:   91:   */
        -:   92:
        -:   93:  /// Bits from GlobalObject::GlobalObjectSubclassData.
        -:   94:  enum {
        -:   95:    /// Whether this function is materializable.
        -:   96:    IsMaterializableBit = 0,
        -:   97:  };
        -:   98:
        -:   99:  friend class SymbolTableListTraits<Function>;
        -:  100:
        -:  101:  /// hasLazyArguments/CheckLazyArguments - The argument list of a function is
        -:  102:  /// built on demand, so that the list isn't allocated until the first client
        -:  103:  /// needs it.  The hasLazyArguments predicate returns true if the arg list
        -:  104:  /// hasn't been set up yet.
        -:  105:public:
        -:  106:  bool hasLazyArguments() const {
        -:  107:    return getSubclassDataFromValue() & (1<<0);
        -:  108:  }
        -:  109:
        -:  110:private:
        -:  111:  void CheckLazyArguments() const {
        -:  112:    if (hasLazyArguments())
        -:  113:      BuildLazyArguments();
        -:  114:  }
        -:  115:
        -:  116:  void BuildLazyArguments() const;
        -:  117:
        -:  118:  void clearArguments();
        -:  119:
        -:  120:  /// Function ctor - If the (optional) Module argument is specified, the
        -:  121:  /// function is automatically inserted into the end of the function list for
        -:  122:  /// the module.
        -:  123:  ///
        -:  124:  Function(FunctionType *Ty, LinkageTypes Linkage, unsigned AddrSpace,
        -:  125:           const Twine &N = "", Module *M = nullptr);
        -:  126:
        -:  127:public:
        -:  128:  Function(const Function&) = delete;
        -:  129:  void operator=(const Function&) = delete;
        -:  130:  ~Function();
        -:  131:
        -:  132:  // This is here to help easily convert from FunctionT * (Function * or
        -:  133:  // MachineFunction *) in BlockFrequencyInfoImpl to Function * by calling
        -:  134:  // FunctionT->getFunction().
        -:  135:  const Function &getFunction() const { return *this; }
        -:  136:
        -:  137:  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
        -:  138:                          unsigned AddrSpace, const Twine &N = "",
        -:  139:                          Module *M = nullptr) {
        -:  140:    return new Function(Ty, Linkage, AddrSpace, N, M);
        -:  141:  }
        -:  142:
        -:  143:  // TODO: remove this once all users have been updated to pass an AddrSpace
        -:  144:  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
        -:  145:                          const Twine &N = "", Module *M = nullptr) {
        -:  146:    return new Function(Ty, Linkage, static_cast<unsigned>(-1), N, M);
        -:  147:  }
        -:  148:
        -:  149:  /// Creates a new function and attaches it to a module.
        -:  150:  ///
        -:  151:  /// Places the function in the program address space as specified
        -:  152:  /// by the module's data layout.
        -:  153:  static Function *Create(FunctionType *Ty, LinkageTypes Linkage,
        -:  154:                          const Twine &N, Module &M);
        -:  155:
        -:  156:  /// Creates a function with some attributes recorded in llvm.module.flags
        -:  157:  /// applied.
        -:  158:  ///
        -:  159:  /// Use this when synthesizing new functions that need attributes that would
        -:  160:  /// have been set by command line options.
        -:  161:  static Function *createWithDefaultAttr(FunctionType *Ty, LinkageTypes Linkage,
        -:  162:                                         unsigned AddrSpace,
        -:  163:                                         const Twine &N = "",
        -:  164:                                         Module *M = nullptr);
        -:  165:
        -:  166:  // Provide fast operand accessors.
        -:  167:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -:  168:
        -:  169:  /// Returns the number of non-debug IR instructions in this function.
        -:  170:  /// This is equivalent to the sum of the sizes of each basic block contained
        -:  171:  /// within this function.
        -:  172:  unsigned getInstructionCount() const;
        -:  173:
        -:  174:  /// Returns the FunctionType for me.
        -:  175:  FunctionType *getFunctionType() const {
        -:  176:    return cast<FunctionType>(getValueType());
        -:  177:  }
        -:  178:
        -:  179:  /// Returns the type of the ret val.
        -:  180:  Type *getReturnType() const { return getFunctionType()->getReturnType(); }
        -:  181:
        -:  182:  /// getContext - Return a reference to the LLVMContext associated with this
        -:  183:  /// function.
        -:  184:  LLVMContext &getContext() const;
        -:  185:
        -:  186:  /// isVarArg - Return true if this function takes a variable number of
        -:  187:  /// arguments.
        -:  188:  bool isVarArg() const { return getFunctionType()->isVarArg(); }
        -:  189:
        -:  190:  bool isMaterializable() const {
        -:  191:    return getGlobalObjectSubClassData() & (1 << IsMaterializableBit);
        -:  192:  }
        -:  193:  void setIsMaterializable(bool V) {
        -:  194:    unsigned Mask = 1 << IsMaterializableBit;
        -:  195:    setGlobalObjectSubClassData((~Mask & getGlobalObjectSubClassData()) |
        -:  196:                                (V ? Mask : 0u));
        -:  197:  }
        -:  198:
        -:  199:  /// getIntrinsicID - This method returns the ID number of the specified
        -:  200:  /// function, or Intrinsic::not_intrinsic if the function is not an
        -:  201:  /// intrinsic, or if the pointer is null.  This value is always defined to be
        -:  202:  /// zero to allow easy checking for whether a function is intrinsic or not.
        -:  203:  /// The particular intrinsic functions which correspond to this value are
        -:  204:  /// defined in llvm/Intrinsics.h.
        -:  205:  Intrinsic::ID getIntrinsicID() const LLVM_READONLY { return IntID; }
        -:  206:
        -:  207:  /// isIntrinsic - Returns true if the function's name starts with "llvm.".
        -:  208:  /// It's possible for this function to return true while getIntrinsicID()
        -:  209:  /// returns Intrinsic::not_intrinsic!
        -:  210:  bool isIntrinsic() const { return HasLLVMReservedName; }
        -:  211:
        -:  212:  /// isTargetIntrinsic - Returns true if IID is an intrinsic specific to a
        -:  213:  /// certain target. If it is a generic intrinsic false is returned.
        -:  214:  static bool isTargetIntrinsic(Intrinsic::ID IID);
        -:  215:
        -:  216:  /// isTargetIntrinsic - Returns true if this function is an intrinsic and the
        -:  217:  /// intrinsic is specific to a certain target. If this is not an intrinsic
        -:  218:  /// or a generic intrinsic, false is returned.
        -:  219:  bool isTargetIntrinsic() const;
        -:  220:
        -:  221:  /// Returns true if the function is one of the "Constrained Floating-Point
        -:  222:  /// Intrinsics". Returns false if not, and returns false when
        -:  223:  /// getIntrinsicID() returns Intrinsic::not_intrinsic.
        -:  224:  bool isConstrainedFPIntrinsic() const;
        -:  225:
        -:  226:  static Intrinsic::ID lookupIntrinsicID(StringRef Name);
        -:  227:
        -:  228:  /// Recalculate the ID for this function if it is an Intrinsic defined
        -:  229:  /// in llvm/Intrinsics.h.  Sets the intrinsic ID to Intrinsic::not_intrinsic
        -:  230:  /// if the name of this function does not match an intrinsic in that header.
        -:  231:  /// Note, this method does not need to be called directly, as it is called
        -:  232:  /// from Value::setName() whenever the name of this function changes.
        -:  233:  void recalculateIntrinsicID();
        -:  234:
        -:  235:  /// getCallingConv()/setCallingConv(CC) - These method get and set the
        -:  236:  /// calling convention of this function.  The enum values for the known
        -:  237:  /// calling conventions are defined in CallingConv.h.
        -:  238:  CallingConv::ID getCallingConv() const {
        -:  239:    return static_cast<CallingConv::ID>((getSubclassDataFromValue() >> 4) &
        -:  240:                                        CallingConv::MaxID);
        -:  241:  }
        -:  242:  void setCallingConv(CallingConv::ID CC) {
        -:  243:    auto ID = static_cast<unsigned>(CC);
        -:  244:    assert(!(ID & ~CallingConv::MaxID) && "Unsupported calling convention");
        -:  245:    setValueSubclassData((getSubclassDataFromValue() & 0xc00f) | (ID << 4));
        -:  246:  }
        -:  247:
        -:  248:  enum ProfileCountType { PCT_Real, PCT_Synthetic };
        -:  249:
        -:  250:  /// Class to represent profile counts.
        -:  251:  ///
        -:  252:  /// This class represents both real and synthetic profile counts.
        -:  253:  class ProfileCount {
        -:  254:  private:
        -:  255:    uint64_t Count = 0;
        -:  256:    ProfileCountType PCT = PCT_Real;
        -:  257:
        -:  258:  public:
        -:  259:    ProfileCount(uint64_t Count, ProfileCountType PCT)
        -:  260:        : Count(Count), PCT(PCT) {}
        -:  261:    uint64_t getCount() const { return Count; }
        -:  262:    ProfileCountType getType() const { return PCT; }
        -:  263:    bool isSynthetic() const { return PCT == PCT_Synthetic; }
        -:  264:  };
        -:  265:
        -:  266:  /// Set the entry count for this function.
        -:  267:  ///
        -:  268:  /// Entry count is the number of times this function was executed based on
        -:  269:  /// pgo data. \p Imports points to a set of GUIDs that needs to
        -:  270:  /// be imported by the function for sample PGO, to enable the same inlines as
        -:  271:  /// the profiled optimized binary.
        -:  272:  void setEntryCount(ProfileCount Count,
        -:  273:                     const DenseSet<GlobalValue::GUID> *Imports = nullptr);
        -:  274:
        -:  275:  /// A convenience wrapper for setting entry count
        -:  276:  void setEntryCount(uint64_t Count, ProfileCountType Type = PCT_Real,
        -:  277:                     const DenseSet<GlobalValue::GUID> *Imports = nullptr);
        -:  278:
        -:  279:  /// Get the entry count for this function.
        -:  280:  ///
        -:  281:  /// Entry count is the number of times the function was executed.
        -:  282:  /// When AllowSynthetic is false, only pgo_data will be returned.
        -:  283:  Optional<ProfileCount> getEntryCount(bool AllowSynthetic = false) const;
        -:  284:
        -:  285:  /// Return true if the function is annotated with profile data.
        -:  286:  ///
        -:  287:  /// Presence of entry counts from a profile run implies the function has
        -:  288:  /// profile annotations. If IncludeSynthetic is false, only return true
        -:  289:  /// when the profile data is real.
        -:  290:  bool hasProfileData(bool IncludeSynthetic = false) const {
        -:  291:    return getEntryCount(IncludeSynthetic).has_value();
        -:  292:  }
        -:  293:
        -:  294:  /// Returns the set of GUIDs that needs to be imported to the function for
        -:  295:  /// sample PGO, to enable the same inlines as the profiled optimized binary.
        -:  296:  DenseSet<GlobalValue::GUID> getImportGUIDs() const;
        -:  297:
        -:  298:  /// Set the section prefix for this function.
        -:  299:  void setSectionPrefix(StringRef Prefix);
        -:  300:
        -:  301:  /// Get the section prefix for this function.
        -:  302:  Optional<StringRef> getSectionPrefix() const;
        -:  303:
        -:  304:  /// hasGC/getGC/setGC/clearGC - The name of the garbage collection algorithm
        -:  305:  ///                             to use during code generation.
        -:  306:  bool hasGC() const {
        -:  307:    return getSubclassDataFromValue() & (1<<14);
        -:  308:  }
        -:  309:  const std::string &getGC() const;
        -:  310:  void setGC(std::string Str);
        -:  311:  void clearGC();
        -:  312:
        -:  313:  /// Return the attribute list for this Function.
        -:  314:  AttributeList getAttributes() const { return AttributeSets; }
        -:  315:
        -:  316:  /// Set the attribute list for this Function.
        -:  317:  void setAttributes(AttributeList Attrs) { AttributeSets = Attrs; }
        -:  318:
        -:  319:  // TODO: remove non-AtIndex versions of these methods.
        -:  320:  /// adds the attribute to the list of attributes.
        -:  321:  void addAttributeAtIndex(unsigned i, Attribute Attr);
        -:  322:
        -:  323:  /// Add function attributes to this function.
        -:  324:  void addFnAttr(Attribute::AttrKind Kind);
        -:  325:
        -:  326:  /// Add function attributes to this function.
        -:  327:  void addFnAttr(StringRef Kind, StringRef Val = StringRef());
        -:  328:
        -:  329:  /// Add function attributes to this function.
        -:  330:  void addFnAttr(Attribute Attr);
        -:  331:
        -:  332:  /// Add function attributes to this function.
        -:  333:  void addFnAttrs(const AttrBuilder &Attrs);
        -:  334:
        -:  335:  /// Add return value attributes to this function.
        -:  336:  void addRetAttr(Attribute::AttrKind Kind);
        -:  337:
        -:  338:  /// Add return value attributes to this function.
        -:  339:  void addRetAttr(Attribute Attr);
        -:  340:
        -:  341:  /// Add return value attributes to this function.
        -:  342:  void addRetAttrs(const AttrBuilder &Attrs);
        -:  343:
        -:  344:  /// adds the attribute to the list of attributes for the given arg.
        -:  345:  void addParamAttr(unsigned ArgNo, Attribute::AttrKind Kind);
        -:  346:
        -:  347:  /// adds the attribute to the list of attributes for the given arg.
        -:  348:  void addParamAttr(unsigned ArgNo, Attribute Attr);
        -:  349:
        -:  350:  /// adds the attributes to the list of attributes for the given arg.
        -:  351:  void addParamAttrs(unsigned ArgNo, const AttrBuilder &Attrs);
        -:  352:
        -:  353:  /// removes the attribute from the list of attributes.
        -:  354:  void removeAttributeAtIndex(unsigned i, Attribute::AttrKind Kind);
        -:  355:
        -:  356:  /// removes the attribute from the list of attributes.
        -:  357:  void removeAttributeAtIndex(unsigned i, StringRef Kind);
        -:  358:
        -:  359:  /// Remove function attributes from this function.
        -:  360:  void removeFnAttr(Attribute::AttrKind Kind);
        -:  361:
        -:  362:  /// Remove function attribute from this function.
        -:  363:  void removeFnAttr(StringRef Kind);
        -:  364:
        -:  365:  void removeFnAttrs(const AttributeMask &Attrs);
        -:  366:
        -:  367:  /// removes the attribute from the return value list of attributes.
        -:  368:  void removeRetAttr(Attribute::AttrKind Kind);
        -:  369:
        -:  370:  /// removes the attribute from the return value list of attributes.
        -:  371:  void removeRetAttr(StringRef Kind);
        -:  372:
        -:  373:  /// removes the attributes from the return value list of attributes.
        -:  374:  void removeRetAttrs(const AttributeMask &Attrs);
        -:  375:
        -:  376:  /// removes the attribute from the list of attributes.
        -:  377:  void removeParamAttr(unsigned ArgNo, Attribute::AttrKind Kind);
        -:  378:
        -:  379:  /// removes the attribute from the list of attributes.
        -:  380:  void removeParamAttr(unsigned ArgNo, StringRef Kind);
        -:  381:
        -:  382:  /// removes the attribute from the list of attributes.
        -:  383:  void removeParamAttrs(unsigned ArgNo, const AttributeMask &Attrs);
        -:  384:
        -:  385:  /// Return true if the function has the attribute.
        -:  386:  bool hasFnAttribute(Attribute::AttrKind Kind) const;
        -:  387:
        -:  388:  /// Return true if the function has the attribute.
        -:  389:  bool hasFnAttribute(StringRef Kind) const;
        -:  390:
        -:  391:  /// check if an attribute is in the list of attributes for the return value.
        -:  392:  bool hasRetAttribute(Attribute::AttrKind Kind) const;
        -:  393:
        -:  394:  /// check if an attributes is in the list of attributes.
        -:  395:  bool hasParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;
        -:  396:
        -:  397:  /// gets the attribute from the list of attributes.
        -:  398:  Attribute getAttributeAtIndex(unsigned i, Attribute::AttrKind Kind) const;
        -:  399:
        -:  400:  /// gets the attribute from the list of attributes.
        -:  401:  Attribute getAttributeAtIndex(unsigned i, StringRef Kind) const;
        -:  402:
        -:  403:  /// Return the attribute for the given attribute kind.
        -:  404:  Attribute getFnAttribute(Attribute::AttrKind Kind) const;
        -:  405:
        -:  406:  /// Return the attribute for the given attribute kind.
        -:  407:  Attribute getFnAttribute(StringRef Kind) const;
        -:  408:
        -:  409:  /// gets the specified attribute from the list of attributes.
        -:  410:  Attribute getParamAttribute(unsigned ArgNo, Attribute::AttrKind Kind) const;
        -:  411:
        -:  412:  /// removes noundef and other attributes that imply undefined behavior if a
        -:  413:  /// `undef` or `poison` value is passed from the list of attributes.
        -:  414:  void removeParamUndefImplyingAttrs(unsigned ArgNo);
        -:  415:
        -:  416:  /// Return the stack alignment for the function.
        -:  417:  MaybeAlign getFnStackAlign() const {
        -:  418:    return AttributeSets.getFnStackAlignment();
        -:  419:  }
        -:  420:
        -:  421:  /// Returns true if the function has ssp, sspstrong, or sspreq fn attrs.
        -:  422:  bool hasStackProtectorFnAttr() const;
        -:  423:
        -:  424:  /// adds the dereferenceable attribute to the list of attributes for
        -:  425:  /// the given arg.
        -:  426:  void addDereferenceableParamAttr(unsigned ArgNo, uint64_t Bytes);
        -:  427:
        -:  428:  /// adds the dereferenceable_or_null attribute to the list of
        -:  429:  /// attributes for the given arg.
        -:  430:  void addDereferenceableOrNullParamAttr(unsigned ArgNo, uint64_t Bytes);
        -:  431:
        -:  432:  /// Extract the alignment for a call or parameter (0=unknown).
        -:  433:  /// FIXME: Remove this function once transition to Align is over.
        -:  434:  /// Use getParamAlign() instead.
        -:  435:  uint64_t getParamAlignment(unsigned ArgNo) const {
        -:  436:    if (const auto MA = getParamAlign(ArgNo))
        -:  437:      return MA->value();
        -:  438:    return 0;
        -:  439:  }
        -:  440:
        -:  441:  MaybeAlign getParamAlign(unsigned ArgNo) const {
        -:  442:    return AttributeSets.getParamAlignment(ArgNo);
        -:  443:  }
        -:  444:
        -:  445:  MaybeAlign getParamStackAlign(unsigned ArgNo) const {
        -:  446:    return AttributeSets.getParamStackAlignment(ArgNo);
        -:  447:  }
        -:  448:
        -:  449:  /// Extract the byval type for a parameter.
        -:  450:  Type *getParamByValType(unsigned ArgNo) const {
        -:  451:    return AttributeSets.getParamByValType(ArgNo);
        -:  452:  }
        -:  453:
        -:  454:  /// Extract the sret type for a parameter.
        -:  455:  Type *getParamStructRetType(unsigned ArgNo) const {
        -:  456:    return AttributeSets.getParamStructRetType(ArgNo);
        -:  457:  }
        -:  458:
        -:  459:  /// Extract the inalloca type for a parameter.
        -:  460:  Type *getParamInAllocaType(unsigned ArgNo) const {
        -:  461:    return AttributeSets.getParamInAllocaType(ArgNo);
        -:  462:  }
        -:  463:
        -:  464:  /// Extract the byref type for a parameter.
        -:  465:  Type *getParamByRefType(unsigned ArgNo) const {
        -:  466:    return AttributeSets.getParamByRefType(ArgNo);
        -:  467:  }
        -:  468:
        -:  469:  /// Extract the preallocated type for a parameter.
        -:  470:  Type *getParamPreallocatedType(unsigned ArgNo) const {
        -:  471:    return AttributeSets.getParamPreallocatedType(ArgNo);
        -:  472:  }
        -:  473:
        -:  474:  /// Extract the number of dereferenceable bytes for a parameter.
        -:  475:  /// @param ArgNo Index of an argument, with 0 being the first function arg.
        -:  476:  uint64_t getParamDereferenceableBytes(unsigned ArgNo) const {
        -:  477:    return AttributeSets.getParamDereferenceableBytes(ArgNo);
        -:  478:  }
        -:  479:
        -:  480:  /// Extract the number of dereferenceable_or_null bytes for a
        -:  481:  /// parameter.
        -:  482:  /// @param ArgNo AttributeList ArgNo, referring to an argument.
        -:  483:  uint64_t getParamDereferenceableOrNullBytes(unsigned ArgNo) const {
        -:  484:    return AttributeSets.getParamDereferenceableOrNullBytes(ArgNo);
        -:  485:  }
        -:  486:
        -:  487:  /// Determine if the function is presplit coroutine.
        -:  488:  bool isPresplitCoroutine() const {
        -:  489:    return hasFnAttribute(Attribute::PresplitCoroutine);
        -:  490:  }
        -:  491:  void setPresplitCoroutine() { addFnAttr(Attribute::PresplitCoroutine); }
        -:  492:  void setSplittedCoroutine() { removeFnAttr(Attribute::PresplitCoroutine); }
        -:  493:
        -:  494:  /// Determine if the function does not access memory.
        -:  495:  bool doesNotAccessMemory() const {
        -:  496:    return hasFnAttribute(Attribute::ReadNone);
        -:  497:  }
        -:  498:  void setDoesNotAccessMemory() {
        -:  499:    addFnAttr(Attribute::ReadNone);
        -:  500:  }
        -:  501:
        -:  502:  /// Determine if the function does not access or only reads memory.
        -:  503:  bool onlyReadsMemory() const {
        -:  504:    return doesNotAccessMemory() || hasFnAttribute(Attribute::ReadOnly);
        -:  505:  }
        -:  506:  void setOnlyReadsMemory() {
        -:  507:    addFnAttr(Attribute::ReadOnly);
        -:  508:  }
        -:  509:
        -:  510:  /// Determine if the function does not access or only writes memory.
        -:  511:  bool onlyWritesMemory() const {
        -:  512:    return doesNotAccessMemory() || hasFnAttribute(Attribute::WriteOnly);
        -:  513:  }
        -:  514:  void setOnlyWritesMemory() {
        -:  515:    addFnAttr(Attribute::WriteOnly);
        -:  516:  }
        -:  517:
        -:  518:  /// Determine if the call can access memmory only using pointers based
        -:  519:  /// on its arguments.
        -:  520:  bool onlyAccessesArgMemory() const {
        -:  521:    return hasFnAttribute(Attribute::ArgMemOnly);
        -:  522:  }
        -:  523:  void setOnlyAccessesArgMemory() { addFnAttr(Attribute::ArgMemOnly); }
        -:  524:
        -:  525:  /// Determine if the function may only access memory that is
        -:  526:  ///  inaccessible from the IR.
        -:  527:  bool onlyAccessesInaccessibleMemory() const {
        -:  528:    return hasFnAttribute(Attribute::InaccessibleMemOnly);
        -:  529:  }
        -:  530:  void setOnlyAccessesInaccessibleMemory() {
        -:  531:    addFnAttr(Attribute::InaccessibleMemOnly);
        -:  532:  }
        -:  533:
        -:  534:  /// Determine if the function may only access memory that is
        -:  535:  ///  either inaccessible from the IR or pointed to by its arguments.
        -:  536:  bool onlyAccessesInaccessibleMemOrArgMem() const {
        -:  537:    return hasFnAttribute(Attribute::InaccessibleMemOrArgMemOnly);
        -:  538:  }
        -:  539:  void setOnlyAccessesInaccessibleMemOrArgMem() {
        -:  540:    addFnAttr(Attribute::InaccessibleMemOrArgMemOnly);
        -:  541:  }
        -:  542:
        -:  543:  /// Determine if the function cannot return.
        -:  544:  bool doesNotReturn() const {
        -:  545:    return hasFnAttribute(Attribute::NoReturn);
        -:  546:  }
        -:  547:  void setDoesNotReturn() {
        -:  548:    addFnAttr(Attribute::NoReturn);
        -:  549:  }
        -:  550:
        -:  551:  /// Determine if the function should not perform indirect branch tracking.
        -:  552:  bool doesNoCfCheck() const { return hasFnAttribute(Attribute::NoCfCheck); }
        -:  553:
        -:  554:  /// Determine if the function cannot unwind.
        -:  555:  bool doesNotThrow() const {
        -:  556:    return hasFnAttribute(Attribute::NoUnwind);
        -:  557:  }
        -:  558:  void setDoesNotThrow() {
        -:  559:    addFnAttr(Attribute::NoUnwind);
        -:  560:  }
        -:  561:
        -:  562:  /// Determine if the call cannot be duplicated.
        -:  563:  bool cannotDuplicate() const {
        -:  564:    return hasFnAttribute(Attribute::NoDuplicate);
        -:  565:  }
        -:  566:  void setCannotDuplicate() {
        -:  567:    addFnAttr(Attribute::NoDuplicate);
        -:  568:  }
        -:  569:
        -:  570:  /// Determine if the call is convergent.
        -:  571:  bool isConvergent() const {
        -:  572:    return hasFnAttribute(Attribute::Convergent);
        -:  573:  }
        -:  574:  void setConvergent() {
        -:  575:    addFnAttr(Attribute::Convergent);
        -:  576:  }
        -:  577:  void setNotConvergent() {
        -:  578:    removeFnAttr(Attribute::Convergent);
        -:  579:  }
        -:  580:
        -:  581:  /// Determine if the call has sideeffects.
        -:  582:  bool isSpeculatable() const {
        -:  583:    return hasFnAttribute(Attribute::Speculatable);
        -:  584:  }
        -:  585:  void setSpeculatable() {
        -:  586:    addFnAttr(Attribute::Speculatable);
        -:  587:  }
        -:  588:
        -:  589:  /// Determine if the call might deallocate memory.
        -:  590:  bool doesNotFreeMemory() const {
        -:  591:    return onlyReadsMemory() || hasFnAttribute(Attribute::NoFree);
        -:  592:  }
        -:  593:  void setDoesNotFreeMemory() {
        -:  594:    addFnAttr(Attribute::NoFree);
        -:  595:  }
        -:  596:
        -:  597:  /// Determine if the call can synchroize with other threads
        -:  598:  bool hasNoSync() const {
        -:  599:    return hasFnAttribute(Attribute::NoSync);
        -:  600:  }
        -:  601:  void setNoSync() {
        -:  602:    addFnAttr(Attribute::NoSync);
        -:  603:  }
        -:  604:
        -:  605:  /// Determine if the function is known not to recurse, directly or
        -:  606:  /// indirectly.
        -:  607:  bool doesNotRecurse() const {
        -:  608:    return hasFnAttribute(Attribute::NoRecurse);
        -:  609:  }
        -:  610:  void setDoesNotRecurse() {
        -:  611:    addFnAttr(Attribute::NoRecurse);
        -:  612:  }
        -:  613:
        -:  614:  /// Determine if the function is required to make forward progress.
        -:  615:  bool mustProgress() const {
        -:  616:    return hasFnAttribute(Attribute::MustProgress) ||
        -:  617:           hasFnAttribute(Attribute::WillReturn);
        -:  618:  }
        -:  619:  void setMustProgress() { addFnAttr(Attribute::MustProgress); }
        -:  620:
        -:  621:  /// Determine if the function will return.
        -:  622:  bool willReturn() const { return hasFnAttribute(Attribute::WillReturn); }
        -:  623:  void setWillReturn() { addFnAttr(Attribute::WillReturn); }
        -:  624:
        -:  625:  /// Get what kind of unwind table entry to generate for this function.
        -:  626:  UWTableKind getUWTableKind() const {
        -:  627:    return AttributeSets.getUWTableKind();
        -:  628:  }
        -:  629:
        -:  630:  /// True if the ABI mandates (or the user requested) that this
        -:  631:  /// function be in a unwind table.
        -:  632:  bool hasUWTable() const {
        -:  633:    return getUWTableKind() != UWTableKind::None;
        -:  634:  }
        -:  635:  void setUWTableKind(UWTableKind K) {
        -:  636:    addFnAttr(Attribute::getWithUWTableKind(getContext(), K));
        -:  637:  }
        -:  638:  /// True if this function needs an unwind table.
        -:  639:  bool needsUnwindTableEntry() const {
        -:  640:    return hasUWTable() || !doesNotThrow() || hasPersonalityFn();
        -:  641:  }
        -:  642:
        -:  643:  /// Determine if the function returns a structure through first
        -:  644:  /// or second pointer argument.
        -:  645:  bool hasStructRetAttr() const {
        -:  646:    return AttributeSets.hasParamAttr(0, Attribute::StructRet) ||
        -:  647:           AttributeSets.hasParamAttr(1, Attribute::StructRet);
        -:  648:  }
        -:  649:
        -:  650:  /// Determine if the parameter or return value is marked with NoAlias
        -:  651:  /// attribute.
        -:  652:  bool returnDoesNotAlias() const {
        -:  653:    return AttributeSets.hasRetAttr(Attribute::NoAlias);
        -:  654:  }
        -:  655:  void setReturnDoesNotAlias() { addRetAttr(Attribute::NoAlias); }
        -:  656:
        -:  657:  /// Do not optimize this function (-O0).
        -:  658:  bool hasOptNone() const { return hasFnAttribute(Attribute::OptimizeNone); }
        -:  659:
        -:  660:  /// Optimize this function for minimum size (-Oz).
        -:  661:  bool hasMinSize() const { return hasFnAttribute(Attribute::MinSize); }
        -:  662:
        -:  663:  /// Optimize this function for size (-Os) or minimum size (-Oz).
        -:  664:  bool hasOptSize() const {
        -:  665:    return hasFnAttribute(Attribute::OptimizeForSize) || hasMinSize();
        -:  666:  }
        -:  667:
        -:  668:  /// Returns the denormal handling type for the default rounding mode of the
        -:  669:  /// function.
        -:  670:  DenormalMode getDenormalMode(const fltSemantics &FPType) const;
        -:  671:
        -:  672:  /// copyAttributesFrom - copy all additional attributes (those not needed to
        -:  673:  /// create a Function) from the Function Src to this one.
        -:  674:  void copyAttributesFrom(const Function *Src);
        -:  675:
        -:  676:  /// deleteBody - This method deletes the body of the function, and converts
        -:  677:  /// the linkage to external.
        -:  678:  ///
        -:  679:  void deleteBody() {
        -:  680:    dropAllReferences();
        -:  681:    setLinkage(ExternalLinkage);
        -:  682:  }
        -:  683:
        -:  684:  /// removeFromParent - This method unlinks 'this' from the containing module,
        -:  685:  /// but does not delete it.
        -:  686:  ///
        -:  687:  void removeFromParent();
        -:  688:
        -:  689:  /// eraseFromParent - This method unlinks 'this' from the containing module
        -:  690:  /// and deletes it.
        -:  691:  ///
        -:  692:  void eraseFromParent();
        -:  693:
        -:  694:  /// Steal arguments from another function.
        -:  695:  ///
        -:  696:  /// Drop this function's arguments and splice in the ones from \c Src.
        -:  697:  /// Requires that this has no function body.
        -:  698:  void stealArgumentListFrom(Function &Src);
        -:  699:
        -:  700:  /// Get the underlying elements of the Function... the basic block list is
        -:  701:  /// empty for external functions.
        -:  702:  ///
        -:  703:  const BasicBlockListType &getBasicBlockList() const { return BasicBlocks; }
        -:  704:        BasicBlockListType &getBasicBlockList()       { return BasicBlocks; }
        -:  705:
        -:  706:  static BasicBlockListType Function::*getSublistAccess(BasicBlock*) {
        -:  707:    return &Function::BasicBlocks;
        -:  708:  }
        -:  709:
        -:  710:  const BasicBlock       &getEntryBlock() const   { return front(); }
        -:  711:        BasicBlock       &getEntryBlock()         { return front(); }
        -:  712:
        -:  713:  //===--------------------------------------------------------------------===//
        -:  714:  // Symbol Table Accessing functions...
        -:  715:
        -:  716:  /// getSymbolTable() - Return the symbol table if any, otherwise nullptr.
        -:  717:  ///
        -:  718:  inline ValueSymbolTable *getValueSymbolTable() { return SymTab.get(); }
        -:  719:  inline const ValueSymbolTable *getValueSymbolTable() const {
        -:  720:    return SymTab.get();
        -:  721:  }
        -:  722:
        -:  723:  //===--------------------------------------------------------------------===//
        -:  724:  // BasicBlock iterator forwarding functions
        -:  725:  //
function _ZN4llvm8Function5beginEv called 0 returned 0% blocks executed 0%
    #####:  726:  iterator                begin()       { return BasicBlocks.begin(); }
    %%%%%:  726-block  0
Aufruf  0 niemals ausgeführt
        -:  727:  const_iterator          begin() const { return BasicBlocks.begin(); }
function _ZN4llvm8Function3endEv called 0 returned 0% blocks executed 0%
    #####:  728:  iterator                end  ()       { return BasicBlocks.end();   }
    %%%%%:  728-block  0
Aufruf  0 niemals ausgeführt
        -:  729:  const_iterator          end  () const { return BasicBlocks.end();   }
        -:  730:
        -:  731:  size_t                   size() const { return BasicBlocks.size();  }
        -:  732:  bool                    empty() const { return BasicBlocks.empty(); }
        -:  733:  const BasicBlock       &front() const { return BasicBlocks.front(); }
        -:  734:        BasicBlock       &front()       { return BasicBlocks.front(); }
        -:  735:  const BasicBlock        &back() const { return BasicBlocks.back();  }
        -:  736:        BasicBlock        &back()       { return BasicBlocks.back();  }
        -:  737:
        -:  738:/// @name Function Argument Iteration
        -:  739:/// @{
        -:  740:
        -:  741:  arg_iterator arg_begin() {
        -:  742:    CheckLazyArguments();
        -:  743:    return Arguments;
        -:  744:  }
        -:  745:  const_arg_iterator arg_begin() const {
        -:  746:    CheckLazyArguments();
        -:  747:    return Arguments;
        -:  748:  }
        -:  749:
        -:  750:  arg_iterator arg_end() {
        -:  751:    CheckLazyArguments();
        -:  752:    return Arguments + NumArgs;
        -:  753:  }
        -:  754:  const_arg_iterator arg_end() const {
        -:  755:    CheckLazyArguments();
        -:  756:    return Arguments + NumArgs;
        -:  757:  }
        -:  758:
        -:  759:  Argument* getArg(unsigned i) const {
        -:  760:    assert (i < NumArgs && "getArg() out of range!");
        -:  761:    CheckLazyArguments();
        -:  762:    return Arguments + i;
        -:  763:  }
        -:  764:
        -:  765:  iterator_range<arg_iterator> args() {
        -:  766:    return make_range(arg_begin(), arg_end());
        -:  767:  }
        -:  768:  iterator_range<const_arg_iterator> args() const {
        -:  769:    return make_range(arg_begin(), arg_end());
        -:  770:  }
        -:  771:
        -:  772:/// @}
        -:  773:
        -:  774:  size_t arg_size() const { return NumArgs; }
        -:  775:  bool arg_empty() const { return arg_size() == 0; }
        -:  776:
        -:  777:  /// Check whether this function has a personality function.
        -:  778:  bool hasPersonalityFn() const {
        -:  779:    return getSubclassDataFromValue() & (1<<3);
        -:  780:  }
        -:  781:
        -:  782:  /// Get the personality function associated with this function.
        -:  783:  Constant *getPersonalityFn() const;
        -:  784:  void setPersonalityFn(Constant *Fn);
        -:  785:
        -:  786:  /// Check whether this function has prefix data.
        -:  787:  bool hasPrefixData() const {
        -:  788:    return getSubclassDataFromValue() & (1<<1);
        -:  789:  }
        -:  790:
        -:  791:  /// Get the prefix data associated with this function.
        -:  792:  Constant *getPrefixData() const;
        -:  793:  void setPrefixData(Constant *PrefixData);
        -:  794:
        -:  795:  /// Check whether this function has prologue data.
        -:  796:  bool hasPrologueData() const {
        -:  797:    return getSubclassDataFromValue() & (1<<2);
        -:  798:  }
        -:  799:
        -:  800:  /// Get the prologue data associated with this function.
        -:  801:  Constant *getPrologueData() const;
        -:  802:  void setPrologueData(Constant *PrologueData);
        -:  803:
        -:  804:  /// Print the function to an output stream with an optional
        -:  805:  /// AssemblyAnnotationWriter.
        -:  806:  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW = nullptr,
        -:  807:             bool ShouldPreserveUseListOrder = false,
        -:  808:             bool IsForDebug = false) const;
        -:  809:
        -:  810:  /// viewCFG - This function is meant for use from the debugger.  You can just
        -:  811:  /// say 'call F->viewCFG()' and a ghostview window should pop up from the
        -:  812:  /// program, displaying the CFG of the current function with the code for each
        -:  813:  /// basic block inside.  This depends on there being a 'dot' and 'gv' program
        -:  814:  /// in your path.
        -:  815:  ///
        -:  816:  void viewCFG() const;
        -:  817:
        -:  818:  /// Extended form to print edge weights.
        -:  819:  void viewCFG(bool ViewCFGOnly, const BlockFrequencyInfo *BFI,
        -:  820:               const BranchProbabilityInfo *BPI) const;
        -:  821:
        -:  822:  /// viewCFGOnly - This function is meant for use from the debugger.  It works
        -:  823:  /// just like viewCFG, but it does not include the contents of basic blocks
        -:  824:  /// into the nodes, just the label.  If you are only interested in the CFG
        -:  825:  /// this can make the graph smaller.
        -:  826:  ///
        -:  827:  void viewCFGOnly() const;
        -:  828:
        -:  829:  /// Extended form to print edge weights.
        -:  830:  void viewCFGOnly(const BlockFrequencyInfo *BFI,
        -:  831:                   const BranchProbabilityInfo *BPI) const;
        -:  832:
        -:  833:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  834:  static bool classof(const Value *V) {
        -:  835:    return V->getValueID() == Value::FunctionVal;
        -:  836:  }
        -:  837:
        -:  838:  /// dropAllReferences() - This method causes all the subinstructions to "let
        -:  839:  /// go" of all references that they are maintaining.  This allows one to
        -:  840:  /// 'delete' a whole module at a time, even though there may be circular
        -:  841:  /// references... first all references are dropped, and all use counts go to
        -:  842:  /// zero.  Then everything is deleted for real.  Note that no operations are
        -:  843:  /// valid on an object that has "dropped all references", except operator
        -:  844:  /// delete.
        -:  845:  ///
        -:  846:  /// Since no other object in the module can have references into the body of a
        -:  847:  /// function, dropping all references deletes the entire body of the function,
        -:  848:  /// including any contained basic blocks.
        -:  849:  ///
        -:  850:  void dropAllReferences();
        -:  851:
        -:  852:  /// hasAddressTaken - returns true if there are any uses of this function
        -:  853:  /// other than direct calls or invokes to it, or blockaddress expressions.
        -:  854:  /// Optionally passes back an offending user for diagnostic purposes,
        -:  855:  /// ignores callback uses, assume like pointer annotation calls, references in
        -:  856:  /// llvm.used and llvm.compiler.used variables, and operand bundle
        -:  857:  /// "clang.arc.attachedcall".
        -:  858:  bool hasAddressTaken(const User ** = nullptr,
        -:  859:                       bool IgnoreCallbackUses = false,
        -:  860:                       bool IgnoreAssumeLikeCalls = true,
        -:  861:                       bool IngoreLLVMUsed = false,
        -:  862:                       bool IgnoreARCAttachedCall = false) const;
        -:  863:
        -:  864:  /// isDefTriviallyDead - Return true if it is trivially safe to remove
        -:  865:  /// this function definition from the module (because it isn't externally
        -:  866:  /// visible, does not have its address taken, and has no callers).  To make
        -:  867:  /// this more accurate, call removeDeadConstantUsers first.
        -:  868:  bool isDefTriviallyDead() const;
        -:  869:
        -:  870:  /// callsFunctionThatReturnsTwice - Return true if the function has a call to
        -:  871:  /// setjmp or other function that gcc recognizes as "returning twice".
        -:  872:  bool callsFunctionThatReturnsTwice() const;
        -:  873:
        -:  874:  /// Set the attached subprogram.
        -:  875:  ///
        -:  876:  /// Calls \a setMetadata() with \a LLVMContext::MD_dbg.
        -:  877:  void setSubprogram(DISubprogram *SP);
        -:  878:
        -:  879:  /// Get the attached subprogram.
        -:  880:  ///
        -:  881:  /// Calls \a getMetadata() with \a LLVMContext::MD_dbg and casts the result
        -:  882:  /// to \a DISubprogram.
        -:  883:  DISubprogram *getSubprogram() const;
        -:  884:
        -:  885:  /// Returns true if we should emit debug info for profiling.
        -:  886:  bool isDebugInfoForProfiling() const;
        -:  887:
        -:  888:  /// Check if null pointer dereferencing is considered undefined behavior for
        -:  889:  /// the function.
        -:  890:  /// Return value: false => null pointer dereference is undefined.
        -:  891:  /// Return value: true =>  null pointer dereference is not undefined.
        -:  892:  bool nullPointerIsDefined() const;
        -:  893:
        -:  894:private:
        -:  895:  void allocHungoffUselist();
        -:  896:  template<int Idx> void setHungoffOperand(Constant *C);
        -:  897:
        -:  898:  /// Shadow Value::setValueSubclassData with a private forwarding method so
        -:  899:  /// that subclasses cannot accidentally use it.
        -:  900:  void setValueSubclassData(unsigned short D) {
        -:  901:    Value::setValueSubclassData(D);
        -:  902:  }
        -:  903:  void setValueSubclassDataBit(unsigned Bit, bool On);
        -:  904:};
        -:  905:
        -:  906:/// Check whether null pointer dereferencing is considered undefined behavior
        -:  907:/// for a given function or an address space.
        -:  908:/// Null pointer access in non-zero address space is not considered undefined.
        -:  909:/// Return value: false => null pointer dereference is undefined.
        -:  910:/// Return value: true =>  null pointer dereference is not undefined.
        -:  911:bool NullPointerIsDefined(const Function *F, unsigned AS = 0);
        -:  912:
        -:  913:template <>
        -:  914:struct OperandTraits<Function> : public HungoffOperandTraits<3> {};
        -:  915:
        -:  916:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(Function, Value)
        -:  917:
        -:  918:} // end namespace llvm
        -:  919:
        -:  920:#endif // LLVM_IR_FUNCTION_H
