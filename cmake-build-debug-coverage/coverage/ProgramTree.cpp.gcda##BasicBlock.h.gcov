        -:    0:Source:/usr/include/llvm/IR/BasicBlock.h
        -:    0:Graph:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/src/main/include/ProgramTree/ProgramTree.cpp.gcno
        -:    0:Data:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/src/main/include/ProgramTree/ProgramTree.cpp.gcda
        -:    0:Runs:1
        -:    1://===- llvm/BasicBlock.h - Represent a basic block in the VM ----*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file contains the declaration of the BasicBlock class.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef LLVM_IR_BASICBLOCK_H
        -:   14:#define LLVM_IR_BASICBLOCK_H
        -:   15:
        -:   16:#include "llvm-c/Types.h"
        -:   17:#include "llvm/ADT/Twine.h"
        -:   18:#include "llvm/ADT/ilist.h"
        -:   19:#include "llvm/ADT/ilist_node.h"
        -:   20:#include "llvm/ADT/iterator.h"
        -:   21:#include "llvm/ADT/iterator_range.h"
        -:   22:#include "llvm/IR/Instruction.h"
        -:   23:#include "llvm/IR/SymbolTableListTraits.h"
        -:   24:#include "llvm/IR/Value.h"
        -:   25:#include <cassert>
        -:   26:#include <cstddef>
        -:   27:#include <iterator>
        -:   28:
        -:   29:namespace llvm {
        -:   30:
        -:   31:class AssemblyAnnotationWriter;
        -:   32:class CallInst;
        -:   33:class Function;
        -:   34:class LandingPadInst;
        -:   35:class LLVMContext;
        -:   36:class Module;
        -:   37:class PHINode;
        -:   38:class ValueSymbolTable;
        -:   39:
        -:   40:/// LLVM Basic Block Representation
        -:   41:///
        -:   42:/// This represents a single basic block in LLVM. A basic block is simply a
        -:   43:/// container of instructions that execute sequentially. Basic blocks are Values
        -:   44:/// because they are referenced by instructions such as branches and switch
        -:   45:/// tables. The type of a BasicBlock is "Type::LabelTy" because the basic block
        -:   46:/// represents a label to which a branch can jump.
        -:   47:///
        -:   48:/// A well formed basic block is formed of a list of non-terminating
        -:   49:/// instructions followed by a single terminator instruction. Terminator
        -:   50:/// instructions may not occur in the middle of basic blocks, and must terminate
        -:   51:/// the blocks. The BasicBlock class allows malformed basic blocks to occur
        -:   52:/// because it may be useful in the intermediate stage of constructing or
        -:   53:/// modifying a program. However, the verifier will ensure that basic blocks are
        -:   54:/// "well formed".
        -:   55:class BasicBlock final : public Value, // Basic blocks are data objects also
        -:   56:                         public ilist_node_with_parent<BasicBlock, Function> {
        -:   57:public:
        -:   58:  using InstListType = SymbolTableList<Instruction>;
        -:   59:
        -:   60:private:
        -:   61:  friend class BlockAddress;
        -:   62:  friend class SymbolTableListTraits<BasicBlock>;
        -:   63:
        -:   64:  InstListType InstList;
        -:   65:  Function *Parent;
        -:   66:
        -:   67:  void setParent(Function *parent);
        -:   68:
        -:   69:  /// Constructor.
        -:   70:  ///
        -:   71:  /// If the function parameter is specified, the basic block is automatically
        -:   72:  /// inserted at either the end of the function (if InsertBefore is null), or
        -:   73:  /// before the specified basic block.
        -:   74:  explicit BasicBlock(LLVMContext &C, const Twine &Name = "",
        -:   75:                      Function *Parent = nullptr,
        -:   76:                      BasicBlock *InsertBefore = nullptr);
        -:   77:
        -:   78:public:
        -:   79:  BasicBlock(const BasicBlock &) = delete;
        -:   80:  BasicBlock &operator=(const BasicBlock &) = delete;
        -:   81:  ~BasicBlock();
        -:   82:
        -:   83:  /// Get the context in which this basic block lives.
        -:   84:  LLVMContext &getContext() const;
        -:   85:
        -:   86:  /// Instruction iterators...
        -:   87:  using iterator = InstListType::iterator;
        -:   88:  using const_iterator = InstListType::const_iterator;
        -:   89:  using reverse_iterator = InstListType::reverse_iterator;
        -:   90:  using const_reverse_iterator = InstListType::const_reverse_iterator;
        -:   91:
        -:   92:  /// Creates a new BasicBlock.
        -:   93:  ///
        -:   94:  /// If the Parent parameter is specified, the basic block is automatically
        -:   95:  /// inserted at either the end of the function (if InsertBefore is 0), or
        -:   96:  /// before the specified basic block.
        -:   97:  static BasicBlock *Create(LLVMContext &Context, const Twine &Name = "",
        -:   98:                            Function *Parent = nullptr,
        -:   99:                            BasicBlock *InsertBefore = nullptr) {
        -:  100:    return new BasicBlock(Context, Name, Parent, InsertBefore);
        -:  101:  }
        -:  102:
        -:  103:  /// Return the enclosing method, or null if none.
        -:  104:  const Function *getParent() const { return Parent; }
        -:  105:        Function *getParent()       { return Parent; }
        -:  106:
        -:  107:  /// Return the module owning the function this basic block belongs to, or
        -:  108:  /// nullptr if the function does not have a module.
        -:  109:  ///
        -:  110:  /// Note: this is undefined behavior if the block does not have a parent.
        -:  111:  const Module *getModule() const;
        -:  112:  Module *getModule() {
        -:  113:    return const_cast<Module *>(
        -:  114:                            static_cast<const BasicBlock *>(this)->getModule());
        -:  115:  }
        -:  116:
        -:  117:  /// Returns the terminator instruction if the block is well formed or null
        -:  118:  /// if the block is not well formed.
function _ZNK4llvm10BasicBlock13getTerminatorEv called 0 returned 0% blocks executed 0%
    #####:  119:  const Instruction *getTerminator() const LLVM_READONLY {
    #####:  120:    if (InstList.empty() || !InstList.back().isTerminator())
    %%%%%:  120-block  0
Aufruf  0 niemals ausgeführt
Zweig  1 niemals ausgeführt
Zweig  2 niemals ausgeführt
    %%%%%:  120-block  1
Aufruf  3 niemals ausgeführt
Aufruf  4 niemals ausgeführt
Zweig  5 niemals ausgeführt
Zweig  6 niemals ausgeführt
    %%%%%:  120-block  2
    %%%%%:  120-block  3
    %%%%%:  120-block  4
Zweig  7 niemals ausgeführt
Zweig  8 niemals ausgeführt
    #####:  121:      return nullptr;
    %%%%%:  121-block  0
    #####:  122:    return &InstList.back();
    %%%%%:  122-block  0
Aufruf  0 niemals ausgeführt
        -:  123:  }
function _ZN4llvm10BasicBlock13getTerminatorEv called 0 returned 0% blocks executed 0%
    #####:  124:  Instruction *getTerminator() {
        -:  125:    return const_cast<Instruction *>(
    #####:  126:        static_cast<const BasicBlock *>(this)->getTerminator());
    %%%%%:  126-block  0
Aufruf  0 niemals ausgeführt
        -:  127:  }
        -:  128:
        -:  129:  /// Returns the call instruction calling \@llvm.experimental.deoptimize
        -:  130:  /// prior to the terminating return instruction of this basic block, if such
        -:  131:  /// a call is present.  Otherwise, returns null.
        -:  132:  const CallInst *getTerminatingDeoptimizeCall() const;
        -:  133:  CallInst *getTerminatingDeoptimizeCall() {
        -:  134:    return const_cast<CallInst *>(
        -:  135:         static_cast<const BasicBlock *>(this)->getTerminatingDeoptimizeCall());
        -:  136:  }
        -:  137:
        -:  138:  /// Returns the call instruction calling \@llvm.experimental.deoptimize
        -:  139:  /// that is present either in current basic block or in block that is a unique
        -:  140:  /// successor to current block, if such call is present. Otherwise, returns null.
        -:  141:  const CallInst *getPostdominatingDeoptimizeCall() const;
        -:  142:  CallInst *getPostdominatingDeoptimizeCall() {
        -:  143:    return const_cast<CallInst *>(
        -:  144:         static_cast<const BasicBlock *>(this)->getPostdominatingDeoptimizeCall());
        -:  145:  }
        -:  146:
        -:  147:  /// Returns the call instruction marked 'musttail' prior to the terminating
        -:  148:  /// return instruction of this basic block, if such a call is present.
        -:  149:  /// Otherwise, returns null.
        -:  150:  const CallInst *getTerminatingMustTailCall() const;
        -:  151:  CallInst *getTerminatingMustTailCall() {
        -:  152:    return const_cast<CallInst *>(
        -:  153:           static_cast<const BasicBlock *>(this)->getTerminatingMustTailCall());
        -:  154:  }
        -:  155:
        -:  156:  /// Returns a pointer to the first instruction in this block that is not a
        -:  157:  /// PHINode instruction.
        -:  158:  ///
        -:  159:  /// When adding instructions to the beginning of the basic block, they should
        -:  160:  /// be added before the returned value, not before the first instruction,
        -:  161:  /// which might be PHI. Returns 0 is there's no non-PHI instruction.
        -:  162:  const Instruction* getFirstNonPHI() const;
        -:  163:  Instruction* getFirstNonPHI() {
        -:  164:    return const_cast<Instruction *>(
        -:  165:                       static_cast<const BasicBlock *>(this)->getFirstNonPHI());
        -:  166:  }
        -:  167:
        -:  168:  /// Returns a pointer to the first instruction in this block that is not a
        -:  169:  /// PHINode or a debug intrinsic, or any pseudo operation if \c SkipPseudoOp
        -:  170:  /// is true.
        -:  171:  const Instruction *getFirstNonPHIOrDbg(bool SkipPseudoOp = true) const;
        -:  172:  Instruction *getFirstNonPHIOrDbg(bool SkipPseudoOp = true) {
        -:  173:    return const_cast<Instruction *>(
        -:  174:        static_cast<const BasicBlock *>(this)->getFirstNonPHIOrDbg(
        -:  175:            SkipPseudoOp));
        -:  176:  }
        -:  177:
        -:  178:  /// Returns a pointer to the first instruction in this block that is not a
        -:  179:  /// PHINode, a debug intrinsic, or a lifetime intrinsic, or any pseudo
        -:  180:  /// operation if \c SkipPseudoOp is true.
        -:  181:  const Instruction *
        -:  182:  getFirstNonPHIOrDbgOrLifetime(bool SkipPseudoOp = true) const;
        -:  183:  Instruction *getFirstNonPHIOrDbgOrLifetime(bool SkipPseudoOp = true) {
        -:  184:    return const_cast<Instruction *>(
        -:  185:        static_cast<const BasicBlock *>(this)->getFirstNonPHIOrDbgOrLifetime(
        -:  186:            SkipPseudoOp));
        -:  187:  }
        -:  188:
        -:  189:  /// Returns an iterator to the first instruction in this block that is
        -:  190:  /// suitable for inserting a non-PHI instruction.
        -:  191:  ///
        -:  192:  /// In particular, it skips all PHIs and LandingPad instructions.
        -:  193:  const_iterator getFirstInsertionPt() const;
        -:  194:  iterator getFirstInsertionPt() {
        -:  195:    return static_cast<const BasicBlock *>(this)
        -:  196:                                          ->getFirstInsertionPt().getNonConst();
        -:  197:  }
        -:  198:
        -:  199:  /// Return a const iterator range over the instructions in the block, skipping
        -:  200:  /// any debug instructions. Skip any pseudo operations as well if \c
        -:  201:  /// SkipPseudoOp is true.
        -:  202:  iterator_range<filter_iterator<BasicBlock::const_iterator,
        -:  203:                                 std::function<bool(const Instruction &)>>>
        -:  204:  instructionsWithoutDebug(bool SkipPseudoOp = true) const;
        -:  205:
        -:  206:  /// Return an iterator range over the instructions in the block, skipping any
        -:  207:  /// debug instructions. Skip and any pseudo operations as well if \c
        -:  208:  /// SkipPseudoOp is true.
        -:  209:  iterator_range<
        -:  210:      filter_iterator<BasicBlock::iterator, std::function<bool(Instruction &)>>>
        -:  211:  instructionsWithoutDebug(bool SkipPseudoOp = true);
        -:  212:
        -:  213:  /// Return the size of the basic block ignoring debug instructions
        -:  214:  filter_iterator<BasicBlock::const_iterator,
        -:  215:                  std::function<bool(const Instruction &)>>::difference_type
        -:  216:  sizeWithoutDebug() const;
        -:  217:
        -:  218:  /// Unlink 'this' from the containing function, but do not delete it.
        -:  219:  void removeFromParent();
        -:  220:
        -:  221:  /// Unlink 'this' from the containing function and delete it.
        -:  222:  ///
        -:  223:  // \returns an iterator pointing to the element after the erased one.
        -:  224:  SymbolTableList<BasicBlock>::iterator eraseFromParent();
        -:  225:
        -:  226:  /// Unlink this basic block from its current function and insert it into
        -:  227:  /// the function that \p MovePos lives in, right before \p MovePos.
        -:  228:  void moveBefore(BasicBlock *MovePos);
        -:  229:
        -:  230:  /// Unlink this basic block from its current function and insert it
        -:  231:  /// right after \p MovePos in the function \p MovePos lives in.
        -:  232:  void moveAfter(BasicBlock *MovePos);
        -:  233:
        -:  234:  /// Insert unlinked basic block into a function.
        -:  235:  ///
        -:  236:  /// Inserts an unlinked basic block into \c Parent.  If \c InsertBefore is
        -:  237:  /// provided, inserts before that basic block, otherwise inserts at the end.
        -:  238:  ///
        -:  239:  /// \pre \a getParent() is \c nullptr.
        -:  240:  void insertInto(Function *Parent, BasicBlock *InsertBefore = nullptr);
        -:  241:
        -:  242:  /// Return the predecessor of this block if it has a single predecessor
        -:  243:  /// block. Otherwise return a null pointer.
        -:  244:  const BasicBlock *getSinglePredecessor() const;
        -:  245:  BasicBlock *getSinglePredecessor() {
        -:  246:    return const_cast<BasicBlock *>(
        -:  247:                 static_cast<const BasicBlock *>(this)->getSinglePredecessor());
        -:  248:  }
        -:  249:
        -:  250:  /// Return the predecessor of this block if it has a unique predecessor
        -:  251:  /// block. Otherwise return a null pointer.
        -:  252:  ///
        -:  253:  /// Note that unique predecessor doesn't mean single edge, there can be
        -:  254:  /// multiple edges from the unique predecessor to this block (for example a
        -:  255:  /// switch statement with multiple cases having the same destination).
        -:  256:  const BasicBlock *getUniquePredecessor() const;
        -:  257:  BasicBlock *getUniquePredecessor() {
        -:  258:    return const_cast<BasicBlock *>(
        -:  259:                 static_cast<const BasicBlock *>(this)->getUniquePredecessor());
        -:  260:  }
        -:  261:
        -:  262:  /// Return true if this block has exactly N predecessors.
        -:  263:  bool hasNPredecessors(unsigned N) const;
        -:  264:
        -:  265:  /// Return true if this block has N predecessors or more.
        -:  266:  bool hasNPredecessorsOrMore(unsigned N) const;
        -:  267:
        -:  268:  /// Return the successor of this block if it has a single successor.
        -:  269:  /// Otherwise return a null pointer.
        -:  270:  ///
        -:  271:  /// This method is analogous to getSinglePredecessor above.
        -:  272:  const BasicBlock *getSingleSuccessor() const;
        -:  273:  BasicBlock *getSingleSuccessor() {
        -:  274:    return const_cast<BasicBlock *>(
        -:  275:                   static_cast<const BasicBlock *>(this)->getSingleSuccessor());
        -:  276:  }
        -:  277:
        -:  278:  /// Return the successor of this block if it has a unique successor.
        -:  279:  /// Otherwise return a null pointer.
        -:  280:  ///
        -:  281:  /// This method is analogous to getUniquePredecessor above.
        -:  282:  const BasicBlock *getUniqueSuccessor() const;
        -:  283:  BasicBlock *getUniqueSuccessor() {
        -:  284:    return const_cast<BasicBlock *>(
        -:  285:                   static_cast<const BasicBlock *>(this)->getUniqueSuccessor());
        -:  286:  }
        -:  287:
        -:  288:  /// Print the basic block to an output stream with an optional
        -:  289:  /// AssemblyAnnotationWriter.
        -:  290:  void print(raw_ostream &OS, AssemblyAnnotationWriter *AAW = nullptr,
        -:  291:             bool ShouldPreserveUseListOrder = false,
        -:  292:             bool IsForDebug = false) const;
        -:  293:
        -:  294:  //===--------------------------------------------------------------------===//
        -:  295:  /// Instruction iterator methods
        -:  296:  ///
        -:  297:  inline iterator                begin()       { return InstList.begin(); }
        -:  298:  inline const_iterator          begin() const { return InstList.begin(); }
        -:  299:  inline iterator                end  ()       { return InstList.end();   }
        -:  300:  inline const_iterator          end  () const { return InstList.end();   }
        -:  301:
        -:  302:  inline reverse_iterator        rbegin()       { return InstList.rbegin(); }
        -:  303:  inline const_reverse_iterator  rbegin() const { return InstList.rbegin(); }
        -:  304:  inline reverse_iterator        rend  ()       { return InstList.rend();   }
        -:  305:  inline const_reverse_iterator  rend  () const { return InstList.rend();   }
        -:  306:
        -:  307:  inline size_t                   size() const { return InstList.size();  }
        -:  308:  inline bool                    empty() const { return InstList.empty(); }
        -:  309:  inline const Instruction      &front() const { return InstList.front(); }
        -:  310:  inline       Instruction      &front()       { return InstList.front(); }
        -:  311:  inline const Instruction       &back() const { return InstList.back();  }
        -:  312:  inline       Instruction       &back()       { return InstList.back();  }
        -:  313:
        -:  314:  /// Iterator to walk just the phi nodes in the basic block.
        -:  315:  template <typename PHINodeT = PHINode, typename BBIteratorT = iterator>
        -:  316:  class phi_iterator_impl
        -:  317:      : public iterator_facade_base<phi_iterator_impl<PHINodeT, BBIteratorT>,
        -:  318:                                    std::forward_iterator_tag, PHINodeT> {
        -:  319:    friend BasicBlock;
        -:  320:
        -:  321:    PHINodeT *PN;
        -:  322:
        -:  323:    phi_iterator_impl(PHINodeT *PN) : PN(PN) {}
        -:  324:
        -:  325:  public:
        -:  326:    // Allow default construction to build variables, but this doesn't build
        -:  327:    // a useful iterator.
        -:  328:    phi_iterator_impl() = default;
        -:  329:
        -:  330:    // Allow conversion between instantiations where valid.
        -:  331:    template <typename PHINodeU, typename BBIteratorU,
        -:  332:              typename = std::enable_if_t<
        -:  333:                  std::is_convertible<PHINodeU *, PHINodeT *>::value>>
        -:  334:    phi_iterator_impl(const phi_iterator_impl<PHINodeU, BBIteratorU> &Arg)
        -:  335:        : PN(Arg.PN) {}
        -:  336:
        -:  337:    bool operator==(const phi_iterator_impl &Arg) const { return PN == Arg.PN; }
        -:  338:
        -:  339:    PHINodeT &operator*() const { return *PN; }
        -:  340:
        -:  341:    using phi_iterator_impl::iterator_facade_base::operator++;
        -:  342:    phi_iterator_impl &operator++() {
        -:  343:      assert(PN && "Cannot increment the end iterator!");
        -:  344:      PN = dyn_cast<PHINodeT>(std::next(BBIteratorT(PN)));
        -:  345:      return *this;
        -:  346:    }
        -:  347:  };
        -:  348:  using phi_iterator = phi_iterator_impl<>;
        -:  349:  using const_phi_iterator =
        -:  350:      phi_iterator_impl<const PHINode, BasicBlock::const_iterator>;
        -:  351:
        -:  352:  /// Returns a range that iterates over the phis in the basic block.
        -:  353:  ///
        -:  354:  /// Note that this cannot be used with basic blocks that have no terminator.
        -:  355:  iterator_range<const_phi_iterator> phis() const {
        -:  356:    return const_cast<BasicBlock *>(this)->phis();
        -:  357:  }
        -:  358:  iterator_range<phi_iterator> phis();
        -:  359:
        -:  360:  /// Return the underlying instruction list container.
        -:  361:  ///
        -:  362:  /// Currently you need to access the underlying instruction list container
        -:  363:  /// directly if you want to modify it.
        -:  364:  const InstListType &getInstList() const { return InstList; }
        -:  365:        InstListType &getInstList()       { return InstList; }
        -:  366:
        -:  367:  /// Returns a pointer to a member of the instruction list.
        -:  368:  static InstListType BasicBlock::*getSublistAccess(Instruction*) {
        -:  369:    return &BasicBlock::InstList;
        -:  370:  }
        -:  371:
        -:  372:  /// Returns a pointer to the symbol table if one exists.
        -:  373:  ValueSymbolTable *getValueSymbolTable();
        -:  374:
        -:  375:  /// Methods for support type inquiry through isa, cast, and dyn_cast.
        -:  376:  static bool classof(const Value *V) {
        -:  377:    return V->getValueID() == Value::BasicBlockVal;
        -:  378:  }
        -:  379:
        -:  380:  /// Cause all subinstructions to "let go" of all the references that said
        -:  381:  /// subinstructions are maintaining.
        -:  382:  ///
        -:  383:  /// This allows one to 'delete' a whole class at a time, even though there may
        -:  384:  /// be circular references... first all references are dropped, and all use
        -:  385:  /// counts go to zero.  Then everything is delete'd for real.  Note that no
        -:  386:  /// operations are valid on an object that has "dropped all references",
        -:  387:  /// except operator delete.
        -:  388:  void dropAllReferences();
        -:  389:
        -:  390:  /// Update PHI nodes in this BasicBlock before removal of predecessor \p Pred.
        -:  391:  /// Note that this function does not actually remove the predecessor.
        -:  392:  ///
        -:  393:  /// If \p KeepOneInputPHIs is true then don't remove PHIs that are left with
        -:  394:  /// zero or one incoming values, and don't simplify PHIs with all incoming
        -:  395:  /// values the same.
        -:  396:  void removePredecessor(BasicBlock *Pred, bool KeepOneInputPHIs = false);
        -:  397:
        -:  398:  bool canSplitPredecessors() const;
        -:  399:
        -:  400:  /// Split the basic block into two basic blocks at the specified instruction.
        -:  401:  ///
        -:  402:  /// If \p Before is true, splitBasicBlockBefore handles the
        -:  403:  /// block splitting. Otherwise, execution proceeds as described below.
        -:  404:  ///
        -:  405:  /// Note that all instructions BEFORE the specified iterator
        -:  406:  /// stay as part of the original basic block, an unconditional branch is added
        -:  407:  /// to the original BB, and the rest of the instructions in the BB are moved
        -:  408:  /// to the new BB, including the old terminator.  The newly formed basic block
        -:  409:  /// is returned. This function invalidates the specified iterator.
        -:  410:  ///
        -:  411:  /// Note that this only works on well formed basic blocks (must have a
        -:  412:  /// terminator), and \p 'I' must not be the end of instruction list (which
        -:  413:  /// would cause a degenerate basic block to be formed, having a terminator
        -:  414:  /// inside of the basic block).
        -:  415:  ///
        -:  416:  /// Also note that this doesn't preserve any passes. To split blocks while
        -:  417:  /// keeping loop information consistent, use the SplitBlock utility function.
        -:  418:  BasicBlock *splitBasicBlock(iterator I, const Twine &BBName = "",
        -:  419:                              bool Before = false);
        -:  420:  BasicBlock *splitBasicBlock(Instruction *I, const Twine &BBName = "",
        -:  421:                              bool Before = false) {
        -:  422:    return splitBasicBlock(I->getIterator(), BBName, Before);
        -:  423:  }
        -:  424:
        -:  425:  /// Split the basic block into two basic blocks at the specified instruction
        -:  426:  /// and insert the new basic blocks as the predecessor of the current block.
        -:  427:  ///
        -:  428:  /// This function ensures all instructions AFTER and including the specified
        -:  429:  /// iterator \p I are part of the original basic block. All Instructions
        -:  430:  /// BEFORE the iterator \p I are moved to the new BB and an unconditional
        -:  431:  /// branch is added to the new BB. The new basic block is returned.
        -:  432:  ///
        -:  433:  /// Note that this only works on well formed basic blocks (must have a
        -:  434:  /// terminator), and \p 'I' must not be the end of instruction list (which
        -:  435:  /// would cause a degenerate basic block to be formed, having a terminator
        -:  436:  /// inside of the basic block).  \p 'I' cannot be a iterator for a PHINode
        -:  437:  /// with multiple incoming blocks.
        -:  438:  ///
        -:  439:  /// Also note that this doesn't preserve any passes. To split blocks while
        -:  440:  /// keeping loop information consistent, use the SplitBlockBefore utility
        -:  441:  /// function.
        -:  442:  BasicBlock *splitBasicBlockBefore(iterator I, const Twine &BBName = "");
        -:  443:  BasicBlock *splitBasicBlockBefore(Instruction *I, const Twine &BBName = "") {
        -:  444:    return splitBasicBlockBefore(I->getIterator(), BBName);
        -:  445:  }
        -:  446:
        -:  447:  /// Returns true if there are any uses of this basic block other than
        -:  448:  /// direct branches, switches, etc. to it.
        -:  449:  bool hasAddressTaken() const {
        -:  450:    return getBasicBlockBits().BlockAddressRefCount != 0;
        -:  451:  }
        -:  452:
        -:  453:  /// Update all phi nodes in this basic block to refer to basic block \p New
        -:  454:  /// instead of basic block \p Old.
        -:  455:  void replacePhiUsesWith(BasicBlock *Old, BasicBlock *New);
        -:  456:
        -:  457:  /// Update all phi nodes in this basic block's successors to refer to basic
        -:  458:  /// block \p New instead of basic block \p Old.
        -:  459:  void replaceSuccessorsPhiUsesWith(BasicBlock *Old, BasicBlock *New);
        -:  460:
        -:  461:  /// Update all phi nodes in this basic block's successors to refer to basic
        -:  462:  /// block \p New instead of to it.
        -:  463:  void replaceSuccessorsPhiUsesWith(BasicBlock *New);
        -:  464:
        -:  465:  /// Return true if this basic block is an exception handling block.
        -:  466:  bool isEHPad() const { return getFirstNonPHI()->isEHPad(); }
        -:  467:
        -:  468:  /// Return true if this basic block is a landing pad.
        -:  469:  ///
        -:  470:  /// Being a ``landing pad'' means that the basic block is the destination of
        -:  471:  /// the 'unwind' edge of an invoke instruction.
        -:  472:  bool isLandingPad() const;
        -:  473:
        -:  474:  /// Return the landingpad instruction associated with the landing pad.
        -:  475:  const LandingPadInst *getLandingPadInst() const;
        -:  476:  LandingPadInst *getLandingPadInst() {
        -:  477:    return const_cast<LandingPadInst *>(
        -:  478:                    static_cast<const BasicBlock *>(this)->getLandingPadInst());
        -:  479:  }
        -:  480:
        -:  481:  /// Return true if it is legal to hoist instructions into this block.
        -:  482:  bool isLegalToHoistInto() const;
        -:  483:
        -:  484:  /// Return true if this is the entry block of the containing function.
        -:  485:  /// This method can only be used on blocks that have a parent function.
        -:  486:  bool isEntryBlock() const;
        -:  487:
        -:  488:  Optional<uint64_t> getIrrLoopHeaderWeight() const;
        -:  489:
        -:  490:  /// Returns true if the Order field of child Instructions is valid.
        -:  491:  bool isInstrOrderValid() const {
        -:  492:    return getBasicBlockBits().InstrOrderValid;
        -:  493:  }
        -:  494:
        -:  495:  /// Mark instruction ordering invalid. Done on every instruction insert.
        -:  496:  void invalidateOrders() {
        -:  497:    validateInstrOrdering();
        -:  498:    BasicBlockBits Bits = getBasicBlockBits();
        -:  499:    Bits.InstrOrderValid = false;
        -:  500:    setBasicBlockBits(Bits);
        -:  501:  }
        -:  502:
        -:  503:  /// Renumber instructions and mark the ordering as valid.
        -:  504:  void renumberInstructions();
        -:  505:
        -:  506:  /// Asserts that instruction order numbers are marked invalid, or that they
        -:  507:  /// are in ascending order. This is constant time if the ordering is invalid,
        -:  508:  /// and linear in the number of instructions if the ordering is valid. Callers
        -:  509:  /// should be careful not to call this in ways that make common operations
        -:  510:  /// O(n^2). For example, it takes O(n) time to assign order numbers to
        -:  511:  /// instructions, so the order should be validated no more than once after
        -:  512:  /// each ordering to ensure that transforms have the same algorithmic
        -:  513:  /// complexity when asserts are enabled as when they are disabled.
        -:  514:  void validateInstrOrdering() const;
        -:  515:
        -:  516:private:
        -:  517:#if defined(_AIX) && (!defined(__GNUC__) || defined(__clang__))
        -:  518:// Except for GCC; by default, AIX compilers store bit-fields in 4-byte words
        -:  519:// and give the `pack` pragma push semantics.
        -:  520:#define BEGIN_TWO_BYTE_PACK() _Pragma("pack(2)")
        -:  521:#define END_TWO_BYTE_PACK() _Pragma("pack(pop)")
        -:  522:#else
        -:  523:#define BEGIN_TWO_BYTE_PACK()
        -:  524:#define END_TWO_BYTE_PACK()
        -:  525:#endif
        -:  526:
        -:  527:  BEGIN_TWO_BYTE_PACK()
        -:  528:  /// Bitfield to help interpret the bits in Value::SubclassData.
        -:  529:  struct BasicBlockBits {
        -:  530:    unsigned short BlockAddressRefCount : 15;
        -:  531:    unsigned short InstrOrderValid : 1;
        -:  532:  };
        -:  533:  END_TWO_BYTE_PACK()
        -:  534:
        -:  535:#undef BEGIN_TWO_BYTE_PACK
        -:  536:#undef END_TWO_BYTE_PACK
        -:  537:
        -:  538:  /// Safely reinterpret the subclass data bits to a more useful form.
        -:  539:  BasicBlockBits getBasicBlockBits() const {
        -:  540:    static_assert(sizeof(BasicBlockBits) == sizeof(unsigned short),
        -:  541:                  "too many bits for Value::SubclassData");
        -:  542:    unsigned short ValueData = getSubclassDataFromValue();
        -:  543:    BasicBlockBits AsBits;
        -:  544:    memcpy(&AsBits, &ValueData, sizeof(AsBits));
        -:  545:    return AsBits;
        -:  546:  }
        -:  547:
        -:  548:  /// Reinterpret our subclass bits and store them back into Value.
        -:  549:  void setBasicBlockBits(BasicBlockBits AsBits) {
        -:  550:    unsigned short D;
        -:  551:    memcpy(&D, &AsBits, sizeof(D));
        -:  552:    Value::setValueSubclassData(D);
        -:  553:  }
        -:  554:
        -:  555:  /// Increment the internal refcount of the number of BlockAddresses
        -:  556:  /// referencing this BasicBlock by \p Amt.
        -:  557:  ///
        -:  558:  /// This is almost always 0, sometimes one possibly, but almost never 2, and
        -:  559:  /// inconceivably 3 or more.
        -:  560:  void AdjustBlockAddressRefCount(int Amt) {
        -:  561:    BasicBlockBits Bits = getBasicBlockBits();
        -:  562:    Bits.BlockAddressRefCount += Amt;
        -:  563:    setBasicBlockBits(Bits);
        -:  564:    assert(Bits.BlockAddressRefCount < 255 && "Refcount wrap-around");
        -:  565:  }
        -:  566:
        -:  567:  /// Shadow Value::setValueSubclassData with a private forwarding method so
        -:  568:  /// that any future subclasses cannot accidentally use it.
        -:  569:  void setValueSubclassData(unsigned short D) {
        -:  570:    Value::setValueSubclassData(D);
        -:  571:  }
        -:  572:};
        -:  573:
        -:  574:// Create wrappers for C Binding types (see CBindingWrapping.h).
        -:  575:DEFINE_SIMPLE_CONVERSION_FUNCTIONS(BasicBlock, LLVMBasicBlockRef)
        -:  576:
        -:  577:/// Advance \p It while it points to a debug instruction and return the result.
        -:  578:/// This assumes that \p It is not at the end of a block.
        -:  579:BasicBlock::iterator skipDebugIntrinsics(BasicBlock::iterator It);
        -:  580:
        -:  581:#ifdef NDEBUG
        -:  582:/// In release builds, this is a no-op. For !NDEBUG builds, the checks are
        -:  583:/// implemented in the .cpp file to avoid circular header deps.
        -:  584:inline void BasicBlock::validateInstrOrdering() const {}
        -:  585:#endif
        -:  586:
        -:  587:} // end namespace llvm
        -:  588:
        -:  589:#endif // LLVM_IR_BASICBLOCK_H
