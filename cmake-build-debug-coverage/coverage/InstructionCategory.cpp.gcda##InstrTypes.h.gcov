        -:    0:Source:/usr/include/llvm/IR/InstrTypes.h
        -:    0:Graph:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/src/main/include/LLVM-Handler/InstructionCategory.cpp.gcno
        -:    0:Data:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/src/main/include/LLVM-Handler/InstructionCategory.cpp.gcda
        -:    0:Runs:1
        -:    1://===- llvm/InstrTypes.h - Important Instruction subclasses -----*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file defines various meta classes of instructions that exist in the VM
        -:   10:// representation.  Specific concrete subclasses of these may be found in the
        -:   11:// i*.h files...
        -:   12://
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#ifndef LLVM_IR_INSTRTYPES_H
        -:   16:#define LLVM_IR_INSTRTYPES_H
        -:   17:
        -:   18:#include "llvm/ADT/ArrayRef.h"
        -:   19:#include "llvm/ADT/None.h"
        -:   20:#include "llvm/ADT/Optional.h"
        -:   21:#include "llvm/ADT/STLExtras.h"
        -:   22:#include "llvm/ADT/Sequence.h"
        -:   23:#include "llvm/ADT/StringMap.h"
        -:   24:#include "llvm/ADT/Twine.h"
        -:   25:#include "llvm/ADT/iterator_range.h"
        -:   26:#include "llvm/IR/Attributes.h"
        -:   27:#include "llvm/IR/CallingConv.h"
        -:   28:#include "llvm/IR/DerivedTypes.h"
        -:   29:#include "llvm/IR/Function.h"
        -:   30:#include "llvm/IR/Instruction.h"
        -:   31:#include "llvm/IR/LLVMContext.h"
        -:   32:#include "llvm/IR/OperandTraits.h"
        -:   33:#include "llvm/IR/User.h"
        -:   34:#include <algorithm>
        -:   35:#include <cassert>
        -:   36:#include <cstddef>
        -:   37:#include <cstdint>
        -:   38:#include <iterator>
        -:   39:#include <string>
        -:   40:#include <vector>
        -:   41:
        -:   42:namespace llvm {
        -:   43:
        -:   44:class StringRef;
        -:   45:class Type;
        -:   46:class Value;
        -:   47:
        -:   48:namespace Intrinsic {
        -:   49:typedef unsigned ID;
        -:   50:}
        -:   51:
        -:   52://===----------------------------------------------------------------------===//
        -:   53://                          UnaryInstruction Class
        -:   54://===----------------------------------------------------------------------===//
        -:   55:
        -:   56:class UnaryInstruction : public Instruction {
        -:   57:protected:
        -:   58:  UnaryInstruction(Type *Ty, unsigned iType, Value *V,
        -:   59:                   Instruction *IB = nullptr)
        -:   60:    : Instruction(Ty, iType, &Op<0>(), 1, IB) {
        -:   61:    Op<0>() = V;
        -:   62:  }
        -:   63:  UnaryInstruction(Type *Ty, unsigned iType, Value *V, BasicBlock *IAE)
        -:   64:    : Instruction(Ty, iType, &Op<0>(), 1, IAE) {
        -:   65:    Op<0>() = V;
        -:   66:  }
        -:   67:
        -:   68:public:
        -:   69:  // allocate space for exactly one operand
        -:   70:  void *operator new(size_t S) { return User::operator new(S, 1); }
        -:   71:  void operator delete(void *Ptr) { User::operator delete(Ptr); }
        -:   72:
        -:   73:  /// Transparently provide more efficient getOperand methods.
        -:   74:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -:   75:
        -:   76:  // Methods for support type inquiry through isa, cast, and dyn_cast:
        -:   77:  static bool classof(const Instruction *I) {
        -:   78:    return I->isUnaryOp() ||
        -:   79:           I->getOpcode() == Instruction::Alloca ||
        -:   80:           I->getOpcode() == Instruction::Load ||
        -:   81:           I->getOpcode() == Instruction::VAArg ||
        -:   82:           I->getOpcode() == Instruction::ExtractValue ||
        -:   83:           (I->getOpcode() >= CastOpsBegin && I->getOpcode() < CastOpsEnd);
        -:   84:  }
        -:   85:  static bool classof(const Value *V) {
        -:   86:    return isa<Instruction>(V) && classof(cast<Instruction>(V));
        -:   87:  }
        -:   88:};
        -:   89:
        -:   90:template <>
        -:   91:struct OperandTraits<UnaryInstruction> :
        -:   92:  public FixedNumOperandTraits<UnaryInstruction, 1> {
        -:   93:};
        -:   94:
        -:   95:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(UnaryInstruction, Value)
        -:   96:
        -:   97://===----------------------------------------------------------------------===//
        -:   98://                                UnaryOperator Class
        -:   99://===----------------------------------------------------------------------===//
        -:  100:
        -:  101:class UnaryOperator : public UnaryInstruction {
        -:  102:  void AssertOK();
        -:  103:
        -:  104:protected:
        -:  105:  UnaryOperator(UnaryOps iType, Value *S, Type *Ty,
        -:  106:                const Twine &Name, Instruction *InsertBefore);
        -:  107:  UnaryOperator(UnaryOps iType, Value *S, Type *Ty,
        -:  108:                const Twine &Name, BasicBlock *InsertAtEnd);
        -:  109:
        -:  110:  // Note: Instruction needs to be a friend here to call cloneImpl.
        -:  111:  friend class Instruction;
        -:  112:
        -:  113:  UnaryOperator *cloneImpl() const;
        -:  114:
        -:  115:public:
        -:  116:
        -:  117:  /// Construct a unary instruction, given the opcode and an operand.
        -:  118:  /// Optionally (if InstBefore is specified) insert the instruction
        -:  119:  /// into a BasicBlock right before the specified instruction.  The specified
        -:  120:  /// Instruction is allowed to be a dereferenced end iterator.
        -:  121:  ///
        -:  122:  static UnaryOperator *Create(UnaryOps Op, Value *S,
        -:  123:                               const Twine &Name = Twine(),
        -:  124:                               Instruction *InsertBefore = nullptr);
        -:  125:
        -:  126:  /// Construct a unary instruction, given the opcode and an operand.
        -:  127:  /// Also automatically insert this instruction to the end of the
        -:  128:  /// BasicBlock specified.
        -:  129:  ///
        -:  130:  static UnaryOperator *Create(UnaryOps Op, Value *S,
        -:  131:                               const Twine &Name,
        -:  132:                               BasicBlock *InsertAtEnd);
        -:  133:
        -:  134:  /// These methods just forward to Create, and are useful when you
        -:  135:  /// statically know what type of instruction you're going to create.  These
        -:  136:  /// helpers just save some typing.
        -:  137:#define HANDLE_UNARY_INST(N, OPC, CLASS) \
        -:  138:  static UnaryOperator *Create##OPC(Value *V, const Twine &Name = "") {\
        -:  139:    return Create(Instruction::OPC, V, Name);\
        -:  140:  }
        -:  141:#include "llvm/IR/Instruction.def"
        -:  142:#define HANDLE_UNARY_INST(N, OPC, CLASS) \
        -:  143:  static UnaryOperator *Create##OPC(Value *V, const Twine &Name, \
        -:  144:                                    BasicBlock *BB) {\
        -:  145:    return Create(Instruction::OPC, V, Name, BB);\
        -:  146:  }
        -:  147:#include "llvm/IR/Instruction.def"
        -:  148:#define HANDLE_UNARY_INST(N, OPC, CLASS) \
        -:  149:  static UnaryOperator *Create##OPC(Value *V, const Twine &Name, \
        -:  150:                                    Instruction *I) {\
        -:  151:    return Create(Instruction::OPC, V, Name, I);\
        -:  152:  }
        -:  153:#include "llvm/IR/Instruction.def"
        -:  154:
        -:  155:  static UnaryOperator *
        -:  156:  CreateWithCopiedFlags(UnaryOps Opc, Value *V, Instruction *CopyO,
        -:  157:                        const Twine &Name = "",
        -:  158:                        Instruction *InsertBefore = nullptr) {
        -:  159:    UnaryOperator *UO = Create(Opc, V, Name, InsertBefore);
        -:  160:    UO->copyIRFlags(CopyO);
        -:  161:    return UO;
        -:  162:  }
        -:  163:
        -:  164:  static UnaryOperator *CreateFNegFMF(Value *Op, Instruction *FMFSource,
        -:  165:                                      const Twine &Name = "",
        -:  166:                                      Instruction *InsertBefore = nullptr) {
        -:  167:    return CreateWithCopiedFlags(Instruction::FNeg, Op, FMFSource, Name,
        -:  168:                                 InsertBefore);
        -:  169:  }
        -:  170:
        -:  171:  UnaryOps getOpcode() const {
        -:  172:    return static_cast<UnaryOps>(Instruction::getOpcode());
        -:  173:  }
        -:  174:
        -:  175:  // Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  176:  static bool classof(const Instruction *I) {
        -:  177:    return I->isUnaryOp();
        -:  178:  }
        -:  179:  static bool classof(const Value *V) {
        -:  180:    return isa<Instruction>(V) && classof(cast<Instruction>(V));
        -:  181:  }
        -:  182:};
        -:  183:
        -:  184://===----------------------------------------------------------------------===//
        -:  185://                           BinaryOperator Class
        -:  186://===----------------------------------------------------------------------===//
        -:  187:
        -:  188:class BinaryOperator : public Instruction {
        -:  189:  void AssertOK();
        -:  190:
        -:  191:protected:
        -:  192:  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,
        -:  193:                 const Twine &Name, Instruction *InsertBefore);
        -:  194:  BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty,
        -:  195:                 const Twine &Name, BasicBlock *InsertAtEnd);
        -:  196:
        -:  197:  // Note: Instruction needs to be a friend here to call cloneImpl.
        -:  198:  friend class Instruction;
        -:  199:
        -:  200:  BinaryOperator *cloneImpl() const;
        -:  201:
        -:  202:public:
        -:  203:  // allocate space for exactly two operands
        -:  204:  void *operator new(size_t S) { return User::operator new(S, 2); }
        -:  205:  void operator delete(void *Ptr) { User::operator delete(Ptr); }
        -:  206:
        -:  207:  /// Transparently provide more efficient getOperand methods.
        -:  208:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -:  209:
        -:  210:  /// Construct a binary instruction, given the opcode and the two
        -:  211:  /// operands.  Optionally (if InstBefore is specified) insert the instruction
        -:  212:  /// into a BasicBlock right before the specified instruction.  The specified
        -:  213:  /// Instruction is allowed to be a dereferenced end iterator.
        -:  214:  ///
        -:  215:  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,
        -:  216:                                const Twine &Name = Twine(),
        -:  217:                                Instruction *InsertBefore = nullptr);
        -:  218:
        -:  219:  /// Construct a binary instruction, given the opcode and the two
        -:  220:  /// operands.  Also automatically insert this instruction to the end of the
        -:  221:  /// BasicBlock specified.
        -:  222:  ///
        -:  223:  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,
        -:  224:                                const Twine &Name, BasicBlock *InsertAtEnd);
        -:  225:
        -:  226:  /// These methods just forward to Create, and are useful when you
        -:  227:  /// statically know what type of instruction you're going to create.  These
        -:  228:  /// helpers just save some typing.
        -:  229:#define HANDLE_BINARY_INST(N, OPC, CLASS) \
        -:  230:  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \
        -:  231:                                     const Twine &Name = "") {\
        -:  232:    return Create(Instruction::OPC, V1, V2, Name);\
        -:  233:  }
        -:  234:#include "llvm/IR/Instruction.def"
        -:  235:#define HANDLE_BINARY_INST(N, OPC, CLASS) \
        -:  236:  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \
        -:  237:                                     const Twine &Name, BasicBlock *BB) {\
        -:  238:    return Create(Instruction::OPC, V1, V2, Name, BB);\
        -:  239:  }
        -:  240:#include "llvm/IR/Instruction.def"
        -:  241:#define HANDLE_BINARY_INST(N, OPC, CLASS) \
        -:  242:  static BinaryOperator *Create##OPC(Value *V1, Value *V2, \
        -:  243:                                     const Twine &Name, Instruction *I) {\
        -:  244:    return Create(Instruction::OPC, V1, V2, Name, I);\
        -:  245:  }
        -:  246:#include "llvm/IR/Instruction.def"
        -:  247:
        -:  248:  static BinaryOperator *
        -:  249:  CreateWithCopiedFlags(BinaryOps Opc, Value *V1, Value *V2, Instruction *CopyO,
        -:  250:                        const Twine &Name = "",
        -:  251:                        Instruction *InsertBefore = nullptr) {
        -:  252:    BinaryOperator *BO = Create(Opc, V1, V2, Name, InsertBefore);
        -:  253:    BO->copyIRFlags(CopyO);
        -:  254:    return BO;
        -:  255:  }
        -:  256:
        -:  257:  static BinaryOperator *CreateFAddFMF(Value *V1, Value *V2,
        -:  258:                                       Instruction *FMFSource,
        -:  259:                                       const Twine &Name = "") {
        -:  260:    return CreateWithCopiedFlags(Instruction::FAdd, V1, V2, FMFSource, Name);
        -:  261:  }
        -:  262:  static BinaryOperator *CreateFSubFMF(Value *V1, Value *V2,
        -:  263:                                       Instruction *FMFSource,
        -:  264:                                       const Twine &Name = "") {
        -:  265:    return CreateWithCopiedFlags(Instruction::FSub, V1, V2, FMFSource, Name);
        -:  266:  }
        -:  267:  static BinaryOperator *CreateFMulFMF(Value *V1, Value *V2,
        -:  268:                                       Instruction *FMFSource,
        -:  269:                                       const Twine &Name = "") {
        -:  270:    return CreateWithCopiedFlags(Instruction::FMul, V1, V2, FMFSource, Name);
        -:  271:  }
        -:  272:  static BinaryOperator *CreateFDivFMF(Value *V1, Value *V2,
        -:  273:                                       Instruction *FMFSource,
        -:  274:                                       const Twine &Name = "") {
        -:  275:    return CreateWithCopiedFlags(Instruction::FDiv, V1, V2, FMFSource, Name);
        -:  276:  }
        -:  277:  static BinaryOperator *CreateFRemFMF(Value *V1, Value *V2,
        -:  278:                                       Instruction *FMFSource,
        -:  279:                                       const Twine &Name = "") {
        -:  280:    return CreateWithCopiedFlags(Instruction::FRem, V1, V2, FMFSource, Name);
        -:  281:  }
        -:  282:
        -:  283:  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,
        -:  284:                                   const Twine &Name = "") {
        -:  285:    BinaryOperator *BO = Create(Opc, V1, V2, Name);
        -:  286:    BO->setHasNoSignedWrap(true);
        -:  287:    return BO;
        -:  288:  }
        -:  289:  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,
        -:  290:                                   const Twine &Name, BasicBlock *BB) {
        -:  291:    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);
        -:  292:    BO->setHasNoSignedWrap(true);
        -:  293:    return BO;
        -:  294:  }
        -:  295:  static BinaryOperator *CreateNSW(BinaryOps Opc, Value *V1, Value *V2,
        -:  296:                                   const Twine &Name, Instruction *I) {
        -:  297:    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);
        -:  298:    BO->setHasNoSignedWrap(true);
        -:  299:    return BO;
        -:  300:  }
        -:  301:
        -:  302:  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,
        -:  303:                                   const Twine &Name = "") {
        -:  304:    BinaryOperator *BO = Create(Opc, V1, V2, Name);
        -:  305:    BO->setHasNoUnsignedWrap(true);
        -:  306:    return BO;
        -:  307:  }
        -:  308:  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,
        -:  309:                                   const Twine &Name, BasicBlock *BB) {
        -:  310:    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);
        -:  311:    BO->setHasNoUnsignedWrap(true);
        -:  312:    return BO;
        -:  313:  }
        -:  314:  static BinaryOperator *CreateNUW(BinaryOps Opc, Value *V1, Value *V2,
        -:  315:                                   const Twine &Name, Instruction *I) {
        -:  316:    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);
        -:  317:    BO->setHasNoUnsignedWrap(true);
        -:  318:    return BO;
        -:  319:  }
        -:  320:
        -:  321:  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,
        -:  322:                                     const Twine &Name = "") {
        -:  323:    BinaryOperator *BO = Create(Opc, V1, V2, Name);
        -:  324:    BO->setIsExact(true);
        -:  325:    return BO;
        -:  326:  }
        -:  327:  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,
        -:  328:                                     const Twine &Name, BasicBlock *BB) {
        -:  329:    BinaryOperator *BO = Create(Opc, V1, V2, Name, BB);
        -:  330:    BO->setIsExact(true);
        -:  331:    return BO;
        -:  332:  }
        -:  333:  static BinaryOperator *CreateExact(BinaryOps Opc, Value *V1, Value *V2,
        -:  334:                                     const Twine &Name, Instruction *I) {
        -:  335:    BinaryOperator *BO = Create(Opc, V1, V2, Name, I);
        -:  336:    BO->setIsExact(true);
        -:  337:    return BO;
        -:  338:  }
        -:  339:
        -:  340:#define DEFINE_HELPERS(OPC, NUWNSWEXACT)                                       \
        -:  341:  static BinaryOperator *Create##NUWNSWEXACT##OPC(Value *V1, Value *V2,        \
        -:  342:                                                  const Twine &Name = "") {    \
        -:  343:    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name);                \
        -:  344:  }                                                                            \
        -:  345:  static BinaryOperator *Create##NUWNSWEXACT##OPC(                             \
        -:  346:      Value *V1, Value *V2, const Twine &Name, BasicBlock *BB) {               \
        -:  347:    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name, BB);            \
        -:  348:  }                                                                            \
        -:  349:  static BinaryOperator *Create##NUWNSWEXACT##OPC(                             \
        -:  350:      Value *V1, Value *V2, const Twine &Name, Instruction *I) {               \
        -:  351:    return Create##NUWNSWEXACT(Instruction::OPC, V1, V2, Name, I);             \
        -:  352:  }
        -:  353:
        -:  354:  DEFINE_HELPERS(Add, NSW) // CreateNSWAdd
        -:  355:  DEFINE_HELPERS(Add, NUW) // CreateNUWAdd
        -:  356:  DEFINE_HELPERS(Sub, NSW) // CreateNSWSub
        -:  357:  DEFINE_HELPERS(Sub, NUW) // CreateNUWSub
        -:  358:  DEFINE_HELPERS(Mul, NSW) // CreateNSWMul
        -:  359:  DEFINE_HELPERS(Mul, NUW) // CreateNUWMul
        -:  360:  DEFINE_HELPERS(Shl, NSW) // CreateNSWShl
        -:  361:  DEFINE_HELPERS(Shl, NUW) // CreateNUWShl
        -:  362:
        -:  363:  DEFINE_HELPERS(SDiv, Exact)  // CreateExactSDiv
        -:  364:  DEFINE_HELPERS(UDiv, Exact)  // CreateExactUDiv
        -:  365:  DEFINE_HELPERS(AShr, Exact)  // CreateExactAShr
        -:  366:  DEFINE_HELPERS(LShr, Exact)  // CreateExactLShr
        -:  367:
        -:  368:#undef DEFINE_HELPERS
        -:  369:
        -:  370:  /// Helper functions to construct and inspect unary operations (NEG and NOT)
        -:  371:  /// via binary operators SUB and XOR:
        -:  372:  ///
        -:  373:  /// Create the NEG and NOT instructions out of SUB and XOR instructions.
        -:  374:  ///
        -:  375:  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name = "",
        -:  376:                                   Instruction *InsertBefore = nullptr);
        -:  377:  static BinaryOperator *CreateNeg(Value *Op, const Twine &Name,
        -:  378:                                   BasicBlock *InsertAtEnd);
        -:  379:  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name = "",
        -:  380:                                      Instruction *InsertBefore = nullptr);
        -:  381:  static BinaryOperator *CreateNSWNeg(Value *Op, const Twine &Name,
        -:  382:                                      BasicBlock *InsertAtEnd);
        -:  383:  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name = "",
        -:  384:                                      Instruction *InsertBefore = nullptr);
        -:  385:  static BinaryOperator *CreateNUWNeg(Value *Op, const Twine &Name,
        -:  386:                                      BasicBlock *InsertAtEnd);
        -:  387:  static BinaryOperator *CreateNot(Value *Op, const Twine &Name = "",
        -:  388:                                   Instruction *InsertBefore = nullptr);
        -:  389:  static BinaryOperator *CreateNot(Value *Op, const Twine &Name,
        -:  390:                                   BasicBlock *InsertAtEnd);
        -:  391:
        -:  392:  BinaryOps getOpcode() const {
        -:  393:    return static_cast<BinaryOps>(Instruction::getOpcode());
        -:  394:  }
        -:  395:
        -:  396:  /// Exchange the two operands to this instruction.
        -:  397:  /// This instruction is safe to use on any binary instruction and
        -:  398:  /// does not modify the semantics of the instruction.  If the instruction
        -:  399:  /// cannot be reversed (ie, it's a Div), then return true.
        -:  400:  ///
        -:  401:  bool swapOperands();
        -:  402:
        -:  403:  // Methods for support type inquiry through isa, cast, and dyn_cast:
function _ZN4llvm14BinaryOperator7classofEPKNS_11InstructionE called 0 returned 0% blocks executed 0%
    #####:  404:  static bool classof(const Instruction *I) {
    #####:  405:    return I->isBinaryOp();
    %%%%%:  405-block  0
Aufruf  0 niemals ausgeführt
        -:  406:  }
        -:  407:  static bool classof(const Value *V) {
        -:  408:    return isa<Instruction>(V) && classof(cast<Instruction>(V));
        -:  409:  }
        -:  410:};
        -:  411:
        -:  412:template <>
        -:  413:struct OperandTraits<BinaryOperator> :
        -:  414:  public FixedNumOperandTraits<BinaryOperator, 2> {
        -:  415:};
        -:  416:
        -:  417:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(BinaryOperator, Value)
        -:  418:
        -:  419://===----------------------------------------------------------------------===//
        -:  420://                               CastInst Class
        -:  421://===----------------------------------------------------------------------===//
        -:  422:
        -:  423:/// This is the base class for all instructions that perform data
        -:  424:/// casts. It is simply provided so that instruction category testing
        -:  425:/// can be performed with code like:
        -:  426:///
        -:  427:/// if (isa<CastInst>(Instr)) { ... }
        -:  428:/// Base class of casting instructions.
        -:  429:class CastInst : public UnaryInstruction {
        -:  430:protected:
        -:  431:  /// Constructor with insert-before-instruction semantics for subclasses
        -:  432:  CastInst(Type *Ty, unsigned iType, Value *S,
        -:  433:           const Twine &NameStr = "", Instruction *InsertBefore = nullptr)
        -:  434:    : UnaryInstruction(Ty, iType, S, InsertBefore) {
        -:  435:    setName(NameStr);
        -:  436:  }
        -:  437:  /// Constructor with insert-at-end-of-block semantics for subclasses
        -:  438:  CastInst(Type *Ty, unsigned iType, Value *S,
        -:  439:           const Twine &NameStr, BasicBlock *InsertAtEnd)
        -:  440:    : UnaryInstruction(Ty, iType, S, InsertAtEnd) {
        -:  441:    setName(NameStr);
        -:  442:  }
        -:  443:
        -:  444:public:
        -:  445:  /// Provides a way to construct any of the CastInst subclasses using an
        -:  446:  /// opcode instead of the subclass's constructor. The opcode must be in the
        -:  447:  /// CastOps category (Instruction::isCast(opcode) returns true). This
        -:  448:  /// constructor has insert-before-instruction semantics to automatically
        -:  449:  /// insert the new CastInst before InsertBefore (if it is non-null).
        -:  450:  /// Construct any of the CastInst subclasses
        -:  451:  static CastInst *Create(
        -:  452:    Instruction::CastOps,    ///< The opcode of the cast instruction
        -:  453:    Value *S,                ///< The value to be casted (operand 0)
        -:  454:    Type *Ty,          ///< The type to which cast should be made
        -:  455:    const Twine &Name = "", ///< Name for the instruction
        -:  456:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  457:  );
        -:  458:  /// Provides a way to construct any of the CastInst subclasses using an
        -:  459:  /// opcode instead of the subclass's constructor. The opcode must be in the
        -:  460:  /// CastOps category. This constructor has insert-at-end-of-block semantics
        -:  461:  /// to automatically insert the new CastInst at the end of InsertAtEnd (if
        -:  462:  /// its non-null).
        -:  463:  /// Construct any of the CastInst subclasses
        -:  464:  static CastInst *Create(
        -:  465:    Instruction::CastOps,    ///< The opcode for the cast instruction
        -:  466:    Value *S,                ///< The value to be casted (operand 0)
        -:  467:    Type *Ty,          ///< The type to which operand is casted
        -:  468:    const Twine &Name, ///< The name for the instruction
        -:  469:    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into
        -:  470:  );
        -:  471:
        -:  472:  /// Create a ZExt or BitCast cast instruction
        -:  473:  static CastInst *CreateZExtOrBitCast(
        -:  474:    Value *S,                ///< The value to be casted (operand 0)
        -:  475:    Type *Ty,          ///< The type to which cast should be made
        -:  476:    const Twine &Name = "", ///< Name for the instruction
        -:  477:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  478:  );
        -:  479:
        -:  480:  /// Create a ZExt or BitCast cast instruction
        -:  481:  static CastInst *CreateZExtOrBitCast(
        -:  482:    Value *S,                ///< The value to be casted (operand 0)
        -:  483:    Type *Ty,          ///< The type to which operand is casted
        -:  484:    const Twine &Name, ///< The name for the instruction
        -:  485:    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into
        -:  486:  );
        -:  487:
        -:  488:  /// Create a SExt or BitCast cast instruction
        -:  489:  static CastInst *CreateSExtOrBitCast(
        -:  490:    Value *S,                ///< The value to be casted (operand 0)
        -:  491:    Type *Ty,          ///< The type to which cast should be made
        -:  492:    const Twine &Name = "", ///< Name for the instruction
        -:  493:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  494:  );
        -:  495:
        -:  496:  /// Create a SExt or BitCast cast instruction
        -:  497:  static CastInst *CreateSExtOrBitCast(
        -:  498:    Value *S,                ///< The value to be casted (operand 0)
        -:  499:    Type *Ty,          ///< The type to which operand is casted
        -:  500:    const Twine &Name, ///< The name for the instruction
        -:  501:    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into
        -:  502:  );
        -:  503:
        -:  504:  /// Create a BitCast AddrSpaceCast, or a PtrToInt cast instruction.
        -:  505:  static CastInst *CreatePointerCast(
        -:  506:    Value *S,                ///< The pointer value to be casted (operand 0)
        -:  507:    Type *Ty,          ///< The type to which operand is casted
        -:  508:    const Twine &Name, ///< The name for the instruction
        -:  509:    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into
        -:  510:  );
        -:  511:
        -:  512:  /// Create a BitCast, AddrSpaceCast or a PtrToInt cast instruction.
        -:  513:  static CastInst *CreatePointerCast(
        -:  514:    Value *S,                ///< The pointer value to be casted (operand 0)
        -:  515:    Type *Ty,          ///< The type to which cast should be made
        -:  516:    const Twine &Name = "", ///< Name for the instruction
        -:  517:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  518:  );
        -:  519:
        -:  520:  /// Create a BitCast or an AddrSpaceCast cast instruction.
        -:  521:  static CastInst *CreatePointerBitCastOrAddrSpaceCast(
        -:  522:    Value *S,                ///< The pointer value to be casted (operand 0)
        -:  523:    Type *Ty,          ///< The type to which operand is casted
        -:  524:    const Twine &Name, ///< The name for the instruction
        -:  525:    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into
        -:  526:  );
        -:  527:
        -:  528:  /// Create a BitCast or an AddrSpaceCast cast instruction.
        -:  529:  static CastInst *CreatePointerBitCastOrAddrSpaceCast(
        -:  530:    Value *S,                ///< The pointer value to be casted (operand 0)
        -:  531:    Type *Ty,          ///< The type to which cast should be made
        -:  532:    const Twine &Name = "", ///< Name for the instruction
        -:  533:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  534:  );
        -:  535:
        -:  536:  /// Create a BitCast, a PtrToInt, or an IntToPTr cast instruction.
        -:  537:  ///
        -:  538:  /// If the value is a pointer type and the destination an integer type,
        -:  539:  /// creates a PtrToInt cast. If the value is an integer type and the
        -:  540:  /// destination a pointer type, creates an IntToPtr cast. Otherwise, creates
        -:  541:  /// a bitcast.
        -:  542:  static CastInst *CreateBitOrPointerCast(
        -:  543:    Value *S,                ///< The pointer value to be casted (operand 0)
        -:  544:    Type *Ty,          ///< The type to which cast should be made
        -:  545:    const Twine &Name = "", ///< Name for the instruction
        -:  546:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  547:  );
        -:  548:
        -:  549:  /// Create a ZExt, BitCast, or Trunc for int -> int casts.
        -:  550:  static CastInst *CreateIntegerCast(
        -:  551:    Value *S,                ///< The pointer value to be casted (operand 0)
        -:  552:    Type *Ty,          ///< The type to which cast should be made
        -:  553:    bool isSigned,           ///< Whether to regard S as signed or not
        -:  554:    const Twine &Name = "", ///< Name for the instruction
        -:  555:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  556:  );
        -:  557:
        -:  558:  /// Create a ZExt, BitCast, or Trunc for int -> int casts.
        -:  559:  static CastInst *CreateIntegerCast(
        -:  560:    Value *S,                ///< The integer value to be casted (operand 0)
        -:  561:    Type *Ty,          ///< The integer type to which operand is casted
        -:  562:    bool isSigned,           ///< Whether to regard S as signed or not
        -:  563:    const Twine &Name, ///< The name for the instruction
        -:  564:    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into
        -:  565:  );
        -:  566:
        -:  567:  /// Create an FPExt, BitCast, or FPTrunc for fp -> fp casts
        -:  568:  static CastInst *CreateFPCast(
        -:  569:    Value *S,                ///< The floating point value to be casted
        -:  570:    Type *Ty,          ///< The floating point type to cast to
        -:  571:    const Twine &Name = "", ///< Name for the instruction
        -:  572:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  573:  );
        -:  574:
        -:  575:  /// Create an FPExt, BitCast, or FPTrunc for fp -> fp casts
        -:  576:  static CastInst *CreateFPCast(
        -:  577:    Value *S,                ///< The floating point value to be casted
        -:  578:    Type *Ty,          ///< The floating point type to cast to
        -:  579:    const Twine &Name, ///< The name for the instruction
        -:  580:    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into
        -:  581:  );
        -:  582:
        -:  583:  /// Create a Trunc or BitCast cast instruction
        -:  584:  static CastInst *CreateTruncOrBitCast(
        -:  585:    Value *S,                ///< The value to be casted (operand 0)
        -:  586:    Type *Ty,          ///< The type to which cast should be made
        -:  587:    const Twine &Name = "", ///< Name for the instruction
        -:  588:    Instruction *InsertBefore = nullptr ///< Place to insert the instruction
        -:  589:  );
        -:  590:
        -:  591:  /// Create a Trunc or BitCast cast instruction
        -:  592:  static CastInst *CreateTruncOrBitCast(
        -:  593:    Value *S,                ///< The value to be casted (operand 0)
        -:  594:    Type *Ty,          ///< The type to which operand is casted
        -:  595:    const Twine &Name, ///< The name for the instruction
        -:  596:    BasicBlock *InsertAtEnd  ///< The block to insert the instruction into
        -:  597:  );
        -:  598:
        -:  599:  /// Check whether a bitcast between these types is valid
        -:  600:  static bool isBitCastable(
        -:  601:    Type *SrcTy, ///< The Type from which the value should be cast.
        -:  602:    Type *DestTy ///< The Type to which the value should be cast.
        -:  603:  );
        -:  604:
        -:  605:  /// Check whether a bitcast, inttoptr, or ptrtoint cast between these
        -:  606:  /// types is valid and a no-op.
        -:  607:  ///
        -:  608:  /// This ensures that any pointer<->integer cast has enough bits in the
        -:  609:  /// integer and any other cast is a bitcast.
        -:  610:  static bool isBitOrNoopPointerCastable(
        -:  611:      Type *SrcTy,  ///< The Type from which the value should be cast.
        -:  612:      Type *DestTy, ///< The Type to which the value should be cast.
        -:  613:      const DataLayout &DL);
        -:  614:
        -:  615:  /// Returns the opcode necessary to cast Val into Ty using usual casting
        -:  616:  /// rules.
        -:  617:  /// Infer the opcode for cast operand and type
        -:  618:  static Instruction::CastOps getCastOpcode(
        -:  619:    const Value *Val, ///< The value to cast
        -:  620:    bool SrcIsSigned, ///< Whether to treat the source as signed
        -:  621:    Type *Ty,   ///< The Type to which the value should be casted
        -:  622:    bool DstIsSigned  ///< Whether to treate the dest. as signed
        -:  623:  );
        -:  624:
        -:  625:  /// There are several places where we need to know if a cast instruction
        -:  626:  /// only deals with integer source and destination types. To simplify that
        -:  627:  /// logic, this method is provided.
        -:  628:  /// @returns true iff the cast has only integral typed operand and dest type.
        -:  629:  /// Determine if this is an integer-only cast.
        -:  630:  bool isIntegerCast() const;
        -:  631:
        -:  632:  /// A lossless cast is one that does not alter the basic value. It implies
        -:  633:  /// a no-op cast but is more stringent, preventing things like int->float,
        -:  634:  /// long->double, or int->ptr.
        -:  635:  /// @returns true iff the cast is lossless.
        -:  636:  /// Determine if this is a lossless cast.
        -:  637:  bool isLosslessCast() const;
        -:  638:
        -:  639:  /// A no-op cast is one that can be effected without changing any bits.
        -:  640:  /// It implies that the source and destination types are the same size. The
        -:  641:  /// DataLayout argument is to determine the pointer size when examining casts
        -:  642:  /// involving Integer and Pointer types. They are no-op casts if the integer
        -:  643:  /// is the same size as the pointer. However, pointer size varies with
        -:  644:  /// platform.  Note that a precondition of this method is that the cast is
        -:  645:  /// legal - i.e. the instruction formed with these operands would verify.
        -:  646:  static bool isNoopCast(
        -:  647:    Instruction::CastOps Opcode, ///< Opcode of cast
        -:  648:    Type *SrcTy,         ///< SrcTy of cast
        -:  649:    Type *DstTy,         ///< DstTy of cast
        -:  650:    const DataLayout &DL ///< DataLayout to get the Int Ptr type from.
        -:  651:  );
        -:  652:
        -:  653:  /// Determine if this cast is a no-op cast.
        -:  654:  ///
        -:  655:  /// \param DL is the DataLayout to determine pointer size.
        -:  656:  bool isNoopCast(const DataLayout &DL) const;
        -:  657:
        -:  658:  /// Determine how a pair of casts can be eliminated, if they can be at all.
        -:  659:  /// This is a helper function for both CastInst and ConstantExpr.
        -:  660:  /// @returns 0 if the CastInst pair can't be eliminated, otherwise
        -:  661:  /// returns Instruction::CastOps value for a cast that can replace
        -:  662:  /// the pair, casting SrcTy to DstTy.
        -:  663:  /// Determine if a cast pair is eliminable
        -:  664:  static unsigned isEliminableCastPair(
        -:  665:    Instruction::CastOps firstOpcode,  ///< Opcode of first cast
        -:  666:    Instruction::CastOps secondOpcode, ///< Opcode of second cast
        -:  667:    Type *SrcTy, ///< SrcTy of 1st cast
        -:  668:    Type *MidTy, ///< DstTy of 1st cast & SrcTy of 2nd cast
        -:  669:    Type *DstTy, ///< DstTy of 2nd cast
        -:  670:    Type *SrcIntPtrTy, ///< Integer type corresponding to Ptr SrcTy, or null
        -:  671:    Type *MidIntPtrTy, ///< Integer type corresponding to Ptr MidTy, or null
        -:  672:    Type *DstIntPtrTy  ///< Integer type corresponding to Ptr DstTy, or null
        -:  673:  );
        -:  674:
        -:  675:  /// Return the opcode of this CastInst
        -:  676:  Instruction::CastOps getOpcode() const {
        -:  677:    return Instruction::CastOps(Instruction::getOpcode());
        -:  678:  }
        -:  679:
        -:  680:  /// Return the source type, as a convenience
        -:  681:  Type* getSrcTy() const { return getOperand(0)->getType(); }
        -:  682:  /// Return the destination type, as a convenience
        -:  683:  Type* getDestTy() const { return getType(); }
        -:  684:
        -:  685:  /// This method can be used to determine if a cast from SrcTy to DstTy using
        -:  686:  /// Opcode op is valid or not.
        -:  687:  /// @returns true iff the proposed cast is valid.
        -:  688:  /// Determine if a cast is valid without creating one.
        -:  689:  static bool castIsValid(Instruction::CastOps op, Type *SrcTy, Type *DstTy);
        -:  690:  static bool castIsValid(Instruction::CastOps op, Value *S, Type *DstTy) {
        -:  691:    return castIsValid(op, S->getType(), DstTy);
        -:  692:  }
        -:  693:
        -:  694:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -:  695:  static bool classof(const Instruction *I) {
        -:  696:    return I->isCast();
        -:  697:  }
        -:  698:  static bool classof(const Value *V) {
        -:  699:    return isa<Instruction>(V) && classof(cast<Instruction>(V));
        -:  700:  }
        -:  701:};
        -:  702:
        -:  703://===----------------------------------------------------------------------===//
        -:  704://                               CmpInst Class
        -:  705://===----------------------------------------------------------------------===//
        -:  706:
        -:  707:/// This class is the base class for the comparison instructions.
        -:  708:/// Abstract base class of comparison instructions.
        -:  709:class CmpInst : public Instruction {
        -:  710:public:
        -:  711:  /// This enumeration lists the possible predicates for CmpInst subclasses.
        -:  712:  /// Values in the range 0-31 are reserved for FCmpInst, while values in the
        -:  713:  /// range 32-64 are reserved for ICmpInst. This is necessary to ensure the
        -:  714:  /// predicate values are not overlapping between the classes.
        -:  715:  ///
        -:  716:  /// Some passes (e.g. InstCombine) depend on the bit-wise characteristics of
        -:  717:  /// FCMP_* values. Changing the bit patterns requires a potential change to
        -:  718:  /// those passes.
        -:  719:  enum Predicate : unsigned {
        -:  720:    // Opcode            U L G E    Intuitive operation
        -:  721:    FCMP_FALSE = 0, ///< 0 0 0 0    Always false (always folded)
        -:  722:    FCMP_OEQ = 1,   ///< 0 0 0 1    True if ordered and equal
        -:  723:    FCMP_OGT = 2,   ///< 0 0 1 0    True if ordered and greater than
        -:  724:    FCMP_OGE = 3,   ///< 0 0 1 1    True if ordered and greater than or equal
        -:  725:    FCMP_OLT = 4,   ///< 0 1 0 0    True if ordered and less than
        -:  726:    FCMP_OLE = 5,   ///< 0 1 0 1    True if ordered and less than or equal
        -:  727:    FCMP_ONE = 6,   ///< 0 1 1 0    True if ordered and operands are unequal
        -:  728:    FCMP_ORD = 7,   ///< 0 1 1 1    True if ordered (no nans)
        -:  729:    FCMP_UNO = 8,   ///< 1 0 0 0    True if unordered: isnan(X) | isnan(Y)
        -:  730:    FCMP_UEQ = 9,   ///< 1 0 0 1    True if unordered or equal
        -:  731:    FCMP_UGT = 10,  ///< 1 0 1 0    True if unordered or greater than
        -:  732:    FCMP_UGE = 11,  ///< 1 0 1 1    True if unordered, greater than, or equal
        -:  733:    FCMP_ULT = 12,  ///< 1 1 0 0    True if unordered or less than
        -:  734:    FCMP_ULE = 13,  ///< 1 1 0 1    True if unordered, less than, or equal
        -:  735:    FCMP_UNE = 14,  ///< 1 1 1 0    True if unordered or not equal
        -:  736:    FCMP_TRUE = 15, ///< 1 1 1 1    Always true (always folded)
        -:  737:    FIRST_FCMP_PREDICATE = FCMP_FALSE,
        -:  738:    LAST_FCMP_PREDICATE = FCMP_TRUE,
        -:  739:    BAD_FCMP_PREDICATE = FCMP_TRUE + 1,
        -:  740:    ICMP_EQ = 32,  ///< equal
        -:  741:    ICMP_NE = 33,  ///< not equal
        -:  742:    ICMP_UGT = 34, ///< unsigned greater than
        -:  743:    ICMP_UGE = 35, ///< unsigned greater or equal
        -:  744:    ICMP_ULT = 36, ///< unsigned less than
        -:  745:    ICMP_ULE = 37, ///< unsigned less or equal
        -:  746:    ICMP_SGT = 38, ///< signed greater than
        -:  747:    ICMP_SGE = 39, ///< signed greater or equal
        -:  748:    ICMP_SLT = 40, ///< signed less than
        -:  749:    ICMP_SLE = 41, ///< signed less or equal
        -:  750:    FIRST_ICMP_PREDICATE = ICMP_EQ,
        -:  751:    LAST_ICMP_PREDICATE = ICMP_SLE,
        -:  752:    BAD_ICMP_PREDICATE = ICMP_SLE + 1
        -:  753:  };
        -:  754:  using PredicateField =
        -:  755:      Bitfield::Element<Predicate, 0, 6, LAST_ICMP_PREDICATE>;
        -:  756:
        -:  757:  /// Returns the sequence of all FCmp predicates.
        -:  758:  static auto FCmpPredicates() {
        -:  759:    return enum_seq_inclusive(Predicate::FIRST_FCMP_PREDICATE,
        -:  760:                              Predicate::LAST_FCMP_PREDICATE,
        -:  761:                              force_iteration_on_noniterable_enum);
        -:  762:  }
        -:  763:
        -:  764:  /// Returns the sequence of all ICmp predicates.
        -:  765:  static auto ICmpPredicates() {
        -:  766:    return enum_seq_inclusive(Predicate::FIRST_ICMP_PREDICATE,
        -:  767:                              Predicate::LAST_ICMP_PREDICATE,
        -:  768:                              force_iteration_on_noniterable_enum);
        -:  769:  }
        -:  770:
        -:  771:protected:
        -:  772:  CmpInst(Type *ty, Instruction::OtherOps op, Predicate pred,
        -:  773:          Value *LHS, Value *RHS, const Twine &Name = "",
        -:  774:          Instruction *InsertBefore = nullptr,
        -:  775:          Instruction *FlagsSource = nullptr);
        -:  776:
        -:  777:  CmpInst(Type *ty, Instruction::OtherOps op, Predicate pred,
        -:  778:          Value *LHS, Value *RHS, const Twine &Name,
        -:  779:          BasicBlock *InsertAtEnd);
        -:  780:
        -:  781:public:
        -:  782:  // allocate space for exactly two operands
        -:  783:  void *operator new(size_t S) { return User::operator new(S, 2); }
        -:  784:  void operator delete(void *Ptr) { User::operator delete(Ptr); }
        -:  785:
        -:  786:  /// Construct a compare instruction, given the opcode, the predicate and
        -:  787:  /// the two operands.  Optionally (if InstBefore is specified) insert the
        -:  788:  /// instruction into a BasicBlock right before the specified instruction.
        -:  789:  /// The specified Instruction is allowed to be a dereferenced end iterator.
        -:  790:  /// Create a CmpInst
        -:  791:  static CmpInst *Create(OtherOps Op,
        -:  792:                         Predicate predicate, Value *S1,
        -:  793:                         Value *S2, const Twine &Name = "",
        -:  794:                         Instruction *InsertBefore = nullptr);
        -:  795:
        -:  796:  /// Construct a compare instruction, given the opcode, the predicate and the
        -:  797:  /// two operands.  Also automatically insert this instruction to the end of
        -:  798:  /// the BasicBlock specified.
        -:  799:  /// Create a CmpInst
        -:  800:  static CmpInst *Create(OtherOps Op, Predicate predicate, Value *S1,
        -:  801:                         Value *S2, const Twine &Name, BasicBlock *InsertAtEnd);
        -:  802:
        -:  803:  /// Get the opcode casted to the right type
        -:  804:  OtherOps getOpcode() const {
        -:  805:    return static_cast<OtherOps>(Instruction::getOpcode());
        -:  806:  }
        -:  807:
        -:  808:  /// Return the predicate for this instruction.
        -:  809:  Predicate getPredicate() const { return getSubclassData<PredicateField>(); }
        -:  810:
        -:  811:  /// Set the predicate for this instruction to the specified value.
        -:  812:  void setPredicate(Predicate P) { setSubclassData<PredicateField>(P); }
        -:  813:
        -:  814:  static bool isFPPredicate(Predicate P) {
        -:  815:    static_assert(FIRST_FCMP_PREDICATE == 0,
        -:  816:                  "FIRST_FCMP_PREDICATE is required to be 0");
        -:  817:    return P <= LAST_FCMP_PREDICATE;
        -:  818:  }
        -:  819:
        -:  820:  static bool isIntPredicate(Predicate P) {
        -:  821:    return P >= FIRST_ICMP_PREDICATE && P <= LAST_ICMP_PREDICATE;
        -:  822:  }
        -:  823:
        -:  824:  static StringRef getPredicateName(Predicate P);
        -:  825:
        -:  826:  bool isFPPredicate() const { return isFPPredicate(getPredicate()); }
        -:  827:  bool isIntPredicate() const { return isIntPredicate(getPredicate()); }
        -:  828:
        -:  829:  /// For example, EQ -> NE, UGT -> ULE, SLT -> SGE,
        -:  830:  ///              OEQ -> UNE, UGT -> OLE, OLT -> UGE, etc.
        -:  831:  /// @returns the inverse predicate for the instruction's current predicate.
        -:  832:  /// Return the inverse of the instruction's predicate.
        -:  833:  Predicate getInversePredicate() const {
        -:  834:    return getInversePredicate(getPredicate());
        -:  835:  }
        -:  836:
        -:  837:  /// For example, EQ -> NE, UGT -> ULE, SLT -> SGE,
        -:  838:  ///              OEQ -> UNE, UGT -> OLE, OLT -> UGE, etc.
        -:  839:  /// @returns the inverse predicate for predicate provided in \p pred.
        -:  840:  /// Return the inverse of a given predicate
        -:  841:  static Predicate getInversePredicate(Predicate pred);
        -:  842:
        -:  843:  /// For example, EQ->EQ, SLE->SGE, ULT->UGT,
        -:  844:  ///              OEQ->OEQ, ULE->UGE, OLT->OGT, etc.
        -:  845:  /// @returns the predicate that would be the result of exchanging the two
        -:  846:  /// operands of the CmpInst instruction without changing the result
        -:  847:  /// produced.
        -:  848:  /// Return the predicate as if the operands were swapped
        -:  849:  Predicate getSwappedPredicate() const {
        -:  850:    return getSwappedPredicate(getPredicate());
        -:  851:  }
        -:  852:
        -:  853:  /// This is a static version that you can use without an instruction
        -:  854:  /// available.
        -:  855:  /// Return the predicate as if the operands were swapped.
        -:  856:  static Predicate getSwappedPredicate(Predicate pred);
        -:  857:
        -:  858:  /// This is a static version that you can use without an instruction
        -:  859:  /// available.
        -:  860:  /// @returns true if the comparison predicate is strict, false otherwise.
        -:  861:  static bool isStrictPredicate(Predicate predicate);
        -:  862:
        -:  863:  /// @returns true if the comparison predicate is strict, false otherwise.
        -:  864:  /// Determine if this instruction is using an strict comparison predicate.
        -:  865:  bool isStrictPredicate() const { return isStrictPredicate(getPredicate()); }
        -:  866:
        -:  867:  /// This is a static version that you can use without an instruction
        -:  868:  /// available.
        -:  869:  /// @returns true if the comparison predicate is non-strict, false otherwise.
        -:  870:  static bool isNonStrictPredicate(Predicate predicate);
        -:  871:
        -:  872:  /// @returns true if the comparison predicate is non-strict, false otherwise.
        -:  873:  /// Determine if this instruction is using an non-strict comparison predicate.
        -:  874:  bool isNonStrictPredicate() const {
        -:  875:    return isNonStrictPredicate(getPredicate());
        -:  876:  }
        -:  877:
        -:  878:  /// For example, SGE -> SGT, SLE -> SLT, ULE -> ULT, UGE -> UGT.
        -:  879:  /// Returns the strict version of non-strict comparisons.
        -:  880:  Predicate getStrictPredicate() const {
        -:  881:    return getStrictPredicate(getPredicate());
        -:  882:  }
        -:  883:
        -:  884:  /// This is a static version that you can use without an instruction
        -:  885:  /// available.
        -:  886:  /// @returns the strict version of comparison provided in \p pred.
        -:  887:  /// If \p pred is not a strict comparison predicate, returns \p pred.
        -:  888:  /// Returns the strict version of non-strict comparisons.
        -:  889:  static Predicate getStrictPredicate(Predicate pred);
        -:  890:
        -:  891:  /// For example, SGT -> SGE, SLT -> SLE, ULT -> ULE, UGT -> UGE.
        -:  892:  /// Returns the non-strict version of strict comparisons.
        -:  893:  Predicate getNonStrictPredicate() const {
        -:  894:    return getNonStrictPredicate(getPredicate());
        -:  895:  }
        -:  896:
        -:  897:  /// This is a static version that you can use without an instruction
        -:  898:  /// available.
        -:  899:  /// @returns the non-strict version of comparison provided in \p pred.
        -:  900:  /// If \p pred is not a strict comparison predicate, returns \p pred.
        -:  901:  /// Returns the non-strict version of strict comparisons.
        -:  902:  static Predicate getNonStrictPredicate(Predicate pred);
        -:  903:
        -:  904:  /// This is a static version that you can use without an instruction
        -:  905:  /// available.
        -:  906:  /// Return the flipped strictness of predicate
        -:  907:  static Predicate getFlippedStrictnessPredicate(Predicate pred);
        -:  908:
        -:  909:  /// For predicate of kind "is X or equal to 0" returns the predicate "is X".
        -:  910:  /// For predicate of kind "is X" returns the predicate "is X or equal to 0".
        -:  911:  /// does not support other kind of predicates.
        -:  912:  /// @returns the predicate that does not contains is equal to zero if
        -:  913:  /// it had and vice versa.
        -:  914:  /// Return the flipped strictness of predicate
        -:  915:  Predicate getFlippedStrictnessPredicate() const {
        -:  916:    return getFlippedStrictnessPredicate(getPredicate());
        -:  917:  }
        -:  918:
        -:  919:  /// Provide more efficient getOperand methods.
        -:  920:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -:  921:
        -:  922:  /// This is just a convenience that dispatches to the subclasses.
        -:  923:  /// Swap the operands and adjust predicate accordingly to retain
        -:  924:  /// the same comparison.
        -:  925:  void swapOperands();
        -:  926:
        -:  927:  /// This is just a convenience that dispatches to the subclasses.
        -:  928:  /// Determine if this CmpInst is commutative.
        -:  929:  bool isCommutative() const;
        -:  930:
        -:  931:  /// Determine if this is an equals/not equals predicate.
        -:  932:  /// This is a static version that you can use without an instruction
        -:  933:  /// available.
        -:  934:  static bool isEquality(Predicate pred);
        -:  935:
        -:  936:  /// Determine if this is an equals/not equals predicate.
        -:  937:  bool isEquality() const { return isEquality(getPredicate()); }
        -:  938:
        -:  939:  /// Return true if the predicate is relational (not EQ or NE).
        -:  940:  static bool isRelational(Predicate P) { return !isEquality(P); }
        -:  941:
        -:  942:  /// Return true if the predicate is relational (not EQ or NE).
        -:  943:  bool isRelational() const { return !isEquality(); }
        -:  944:
        -:  945:  /// @returns true if the comparison is signed, false otherwise.
        -:  946:  /// Determine if this instruction is using a signed comparison.
        -:  947:  bool isSigned() const {
        -:  948:    return isSigned(getPredicate());
        -:  949:  }
        -:  950:
        -:  951:  /// @returns true if the comparison is unsigned, false otherwise.
        -:  952:  /// Determine if this instruction is using an unsigned comparison.
        -:  953:  bool isUnsigned() const {
        -:  954:    return isUnsigned(getPredicate());
        -:  955:  }
        -:  956:
        -:  957:  /// For example, ULT->SLT, ULE->SLE, UGT->SGT, UGE->SGE, SLT->Failed assert
        -:  958:  /// @returns the signed version of the unsigned predicate pred.
        -:  959:  /// return the signed version of a predicate
        -:  960:  static Predicate getSignedPredicate(Predicate pred);
        -:  961:
        -:  962:  /// For example, ULT->SLT, ULE->SLE, UGT->SGT, UGE->SGE, SLT->Failed assert
        -:  963:  /// @returns the signed version of the predicate for this instruction (which
        -:  964:  /// has to be an unsigned predicate).
        -:  965:  /// return the signed version of a predicate
        -:  966:  Predicate getSignedPredicate() {
        -:  967:    return getSignedPredicate(getPredicate());
        -:  968:  }
        -:  969:
        -:  970:  /// For example, SLT->ULT, SLE->ULE, SGT->UGT, SGE->UGE, ULT->Failed assert
        -:  971:  /// @returns the unsigned version of the signed predicate pred.
        -:  972:  static Predicate getUnsignedPredicate(Predicate pred);
        -:  973:
        -:  974:  /// For example, SLT->ULT, SLE->ULE, SGT->UGT, SGE->UGE, ULT->Failed assert
        -:  975:  /// @returns the unsigned version of the predicate for this instruction (which
        -:  976:  /// has to be an signed predicate).
        -:  977:  /// return the unsigned version of a predicate
        -:  978:  Predicate getUnsignedPredicate() {
        -:  979:    return getUnsignedPredicate(getPredicate());
        -:  980:  }
        -:  981:
        -:  982:  /// For example, SLT->ULT, ULT->SLT, SLE->ULE, ULE->SLE, EQ->Failed assert
        -:  983:  /// @returns the unsigned version of the signed predicate pred or
        -:  984:  ///          the signed version of the signed predicate pred.
        -:  985:  static Predicate getFlippedSignednessPredicate(Predicate pred);
        -:  986:
        -:  987:  /// For example, SLT->ULT, ULT->SLT, SLE->ULE, ULE->SLE, EQ->Failed assert
        -:  988:  /// @returns the unsigned version of the signed predicate pred or
        -:  989:  ///          the signed version of the signed predicate pred.
        -:  990:  Predicate getFlippedSignednessPredicate() {
        -:  991:    return getFlippedSignednessPredicate(getPredicate());
        -:  992:  }
        -:  993:
        -:  994:  /// This is just a convenience.
        -:  995:  /// Determine if this is true when both operands are the same.
        -:  996:  bool isTrueWhenEqual() const {
        -:  997:    return isTrueWhenEqual(getPredicate());
        -:  998:  }
        -:  999:
        -: 1000:  /// This is just a convenience.
        -: 1001:  /// Determine if this is false when both operands are the same.
        -: 1002:  bool isFalseWhenEqual() const {
        -: 1003:    return isFalseWhenEqual(getPredicate());
        -: 1004:  }
        -: 1005:
        -: 1006:  /// @returns true if the predicate is unsigned, false otherwise.
        -: 1007:  /// Determine if the predicate is an unsigned operation.
        -: 1008:  static bool isUnsigned(Predicate predicate);
        -: 1009:
        -: 1010:  /// @returns true if the predicate is signed, false otherwise.
        -: 1011:  /// Determine if the predicate is an signed operation.
        -: 1012:  static bool isSigned(Predicate predicate);
        -: 1013:
        -: 1014:  /// Determine if the predicate is an ordered operation.
        -: 1015:  static bool isOrdered(Predicate predicate);
        -: 1016:
        -: 1017:  /// Determine if the predicate is an unordered operation.
        -: 1018:  static bool isUnordered(Predicate predicate);
        -: 1019:
        -: 1020:  /// Determine if the predicate is true when comparing a value with itself.
        -: 1021:  static bool isTrueWhenEqual(Predicate predicate);
        -: 1022:
        -: 1023:  /// Determine if the predicate is false when comparing a value with itself.
        -: 1024:  static bool isFalseWhenEqual(Predicate predicate);
        -: 1025:
        -: 1026:  /// Determine if Pred1 implies Pred2 is true when two compares have matching
        -: 1027:  /// operands.
        -: 1028:  static bool isImpliedTrueByMatchingCmp(Predicate Pred1, Predicate Pred2);
        -: 1029:
        -: 1030:  /// Determine if Pred1 implies Pred2 is false when two compares have matching
        -: 1031:  /// operands.
        -: 1032:  static bool isImpliedFalseByMatchingCmp(Predicate Pred1, Predicate Pred2);
        -: 1033:
        -: 1034:  /// Methods for support type inquiry through isa, cast, and dyn_cast:
        -: 1035:  static bool classof(const Instruction *I) {
        -: 1036:    return I->getOpcode() == Instruction::ICmp ||
        -: 1037:           I->getOpcode() == Instruction::FCmp;
        -: 1038:  }
        -: 1039:  static bool classof(const Value *V) {
        -: 1040:    return isa<Instruction>(V) && classof(cast<Instruction>(V));
        -: 1041:  }
        -: 1042:
        -: 1043:  /// Create a result type for fcmp/icmp
        -: 1044:  static Type* makeCmpResultType(Type* opnd_type) {
        -: 1045:    if (VectorType* vt = dyn_cast<VectorType>(opnd_type)) {
        -: 1046:      return VectorType::get(Type::getInt1Ty(opnd_type->getContext()),
        -: 1047:                             vt->getElementCount());
        -: 1048:    }
        -: 1049:    return Type::getInt1Ty(opnd_type->getContext());
        -: 1050:  }
        -: 1051:
        -: 1052:private:
        -: 1053:  // Shadow Value::setValueSubclassData with a private forwarding method so that
        -: 1054:  // subclasses cannot accidentally use it.
        -: 1055:  void setValueSubclassData(unsigned short D) {
        -: 1056:    Value::setValueSubclassData(D);
        -: 1057:  }
        -: 1058:};
        -: 1059:
        -: 1060:// FIXME: these are redundant if CmpInst < BinaryOperator
        -: 1061:template <>
        -: 1062:struct OperandTraits<CmpInst> : public FixedNumOperandTraits<CmpInst, 2> {
        -: 1063:};
        -: 1064:
        -: 1065:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(CmpInst, Value)
        -: 1066:
        -: 1067:/// A lightweight accessor for an operand bundle meant to be passed
        -: 1068:/// around by value.
        -: 1069:struct OperandBundleUse {
        -: 1070:  ArrayRef<Use> Inputs;
        -: 1071:
        -: 1072:  OperandBundleUse() = default;
        -: 1073:  explicit OperandBundleUse(StringMapEntry<uint32_t> *Tag, ArrayRef<Use> Inputs)
        -: 1074:      : Inputs(Inputs), Tag(Tag) {}
        -: 1075:
        -: 1076:  /// Return true if the operand at index \p Idx in this operand bundle
        -: 1077:  /// has the attribute A.
        -: 1078:  bool operandHasAttr(unsigned Idx, Attribute::AttrKind A) const {
        -: 1079:    if (isDeoptOperandBundle())
        -: 1080:      if (A == Attribute::ReadOnly || A == Attribute::NoCapture)
        -: 1081:        return Inputs[Idx]->getType()->isPointerTy();
        -: 1082:
        -: 1083:    // Conservative answer:  no operands have any attributes.
        -: 1084:    return false;
        -: 1085:  }
        -: 1086:
        -: 1087:  /// Return the tag of this operand bundle as a string.
        -: 1088:  StringRef getTagName() const {
        -: 1089:    return Tag->getKey();
        -: 1090:  }
        -: 1091:
        -: 1092:  /// Return the tag of this operand bundle as an integer.
        -: 1093:  ///
        -: 1094:  /// Operand bundle tags are interned by LLVMContextImpl::getOrInsertBundleTag,
        -: 1095:  /// and this function returns the unique integer getOrInsertBundleTag
        -: 1096:  /// associated the tag of this operand bundle to.
        -: 1097:  uint32_t getTagID() const {
        -: 1098:    return Tag->getValue();
        -: 1099:  }
        -: 1100:
        -: 1101:  /// Return true if this is a "deopt" operand bundle.
        -: 1102:  bool isDeoptOperandBundle() const {
        -: 1103:    return getTagID() == LLVMContext::OB_deopt;
        -: 1104:  }
        -: 1105:
        -: 1106:  /// Return true if this is a "funclet" operand bundle.
        -: 1107:  bool isFuncletOperandBundle() const {
        -: 1108:    return getTagID() == LLVMContext::OB_funclet;
        -: 1109:  }
        -: 1110:
        -: 1111:  /// Return true if this is a "cfguardtarget" operand bundle.
        -: 1112:  bool isCFGuardTargetOperandBundle() const {
        -: 1113:    return getTagID() == LLVMContext::OB_cfguardtarget;
        -: 1114:  }
        -: 1115:
        -: 1116:private:
        -: 1117:  /// Pointer to an entry in LLVMContextImpl::getOrInsertBundleTag.
        -: 1118:  StringMapEntry<uint32_t> *Tag;
        -: 1119:};
        -: 1120:
        -: 1121:/// A container for an operand bundle being viewed as a set of values
        -: 1122:/// rather than a set of uses.
        -: 1123:///
        -: 1124:/// Unlike OperandBundleUse, OperandBundleDefT owns the memory it carries, and
        -: 1125:/// so it is possible to create and pass around "self-contained" instances of
        -: 1126:/// OperandBundleDef and ConstOperandBundleDef.
        -: 1127:template <typename InputTy> class OperandBundleDefT {
        -: 1128:  std::string Tag;
        -: 1129:  std::vector<InputTy> Inputs;
        -: 1130:
        -: 1131:public:
        -: 1132:  explicit OperandBundleDefT(std::string Tag, std::vector<InputTy> Inputs)
        -: 1133:      : Tag(std::move(Tag)), Inputs(std::move(Inputs)) {}
        -: 1134:  explicit OperandBundleDefT(std::string Tag, ArrayRef<InputTy> Inputs)
        -: 1135:      : Tag(std::move(Tag)), Inputs(Inputs) {}
        -: 1136:
        -: 1137:  explicit OperandBundleDefT(const OperandBundleUse &OBU) {
        -: 1138:    Tag = std::string(OBU.getTagName());
        -: 1139:    llvm::append_range(Inputs, OBU.Inputs);
        -: 1140:  }
        -: 1141:
        -: 1142:  ArrayRef<InputTy> inputs() const { return Inputs; }
        -: 1143:
        -: 1144:  using input_iterator = typename std::vector<InputTy>::const_iterator;
        -: 1145:
        -: 1146:  size_t input_size() const { return Inputs.size(); }
        -: 1147:  input_iterator input_begin() const { return Inputs.begin(); }
        -: 1148:  input_iterator input_end() const { return Inputs.end(); }
        -: 1149:
        -: 1150:  StringRef getTag() const { return Tag; }
        -: 1151:};
        -: 1152:
        -: 1153:using OperandBundleDef = OperandBundleDefT<Value *>;
        -: 1154:using ConstOperandBundleDef = OperandBundleDefT<const Value *>;
        -: 1155:
        -: 1156://===----------------------------------------------------------------------===//
        -: 1157://                               CallBase Class
        -: 1158://===----------------------------------------------------------------------===//
        -: 1159:
        -: 1160:/// Base class for all callable instructions (InvokeInst and CallInst)
        -: 1161:/// Holds everything related to calling a function.
        -: 1162:///
        -: 1163:/// All call-like instructions are required to use a common operand layout:
        -: 1164:/// - Zero or more arguments to the call,
        -: 1165:/// - Zero or more operand bundles with zero or more operand inputs each
        -: 1166:///   bundle,
        -: 1167:/// - Zero or more subclass controlled operands
        -: 1168:/// - The called function.
        -: 1169:///
        -: 1170:/// This allows this base class to easily access the called function and the
        -: 1171:/// start of the arguments without knowing how many other operands a particular
        -: 1172:/// subclass requires. Note that accessing the end of the argument list isn't
        -: 1173:/// as cheap as most other operations on the base class.
        -: 1174:class CallBase : public Instruction {
        -: 1175:protected:
        -: 1176:  // The first two bits are reserved by CallInst for fast retrieval,
        -: 1177:  using CallInstReservedField = Bitfield::Element<unsigned, 0, 2>;
        -: 1178:  using CallingConvField =
        -: 1179:      Bitfield::Element<CallingConv::ID, CallInstReservedField::NextBit, 10,
        -: 1180:                        CallingConv::MaxID>;
        -: 1181:  static_assert(
        -: 1182:      Bitfield::areContiguous<CallInstReservedField, CallingConvField>(),
        -: 1183:      "Bitfields must be contiguous");
        -: 1184:
        -: 1185:  /// The last operand is the called operand.
        -: 1186:  static constexpr int CalledOperandOpEndIdx = -1;
        -: 1187:
        -: 1188:  AttributeList Attrs; ///< parameter attributes for callable
        -: 1189:  FunctionType *FTy;
        -: 1190:
        -: 1191:  template <class... ArgsTy>
        -: 1192:  CallBase(AttributeList const &A, FunctionType *FT, ArgsTy &&... Args)
        -: 1193:      : Instruction(std::forward<ArgsTy>(Args)...), Attrs(A), FTy(FT) {}
        -: 1194:
        -: 1195:  using Instruction::Instruction;
        -: 1196:
        -: 1197:  bool hasDescriptor() const { return Value::HasDescriptor; }
        -: 1198:
        -: 1199:  unsigned getNumSubclassExtraOperands() const {
        -: 1200:    switch (getOpcode()) {
        -: 1201:    case Instruction::Call:
        -: 1202:      return 0;
        -: 1203:    case Instruction::Invoke:
        -: 1204:      return 2;
        -: 1205:    case Instruction::CallBr:
        -: 1206:      return getNumSubclassExtraOperandsDynamic();
        -: 1207:    }
        -: 1208:    llvm_unreachable("Invalid opcode!");
        -: 1209:  }
        -: 1210:
        -: 1211:  /// Get the number of extra operands for instructions that don't have a fixed
        -: 1212:  /// number of extra operands.
        -: 1213:  unsigned getNumSubclassExtraOperandsDynamic() const;
        -: 1214:
        -: 1215:public:
        -: 1216:  using Instruction::getContext;
        -: 1217:
        -: 1218:  /// Create a clone of \p CB with a different set of operand bundles and
        -: 1219:  /// insert it before \p InsertPt.
        -: 1220:  ///
        -: 1221:  /// The returned call instruction is identical \p CB in every way except that
        -: 1222:  /// the operand bundles for the new instruction are set to the operand bundles
        -: 1223:  /// in \p Bundles.
        -: 1224:  static CallBase *Create(CallBase *CB, ArrayRef<OperandBundleDef> Bundles,
        -: 1225:                          Instruction *InsertPt = nullptr);
        -: 1226:
        -: 1227:  /// Create a clone of \p CB with the operand bundle with the tag matching
        -: 1228:  /// \p Bundle's tag replaced with Bundle, and insert it before \p InsertPt.
        -: 1229:  ///
        -: 1230:  /// The returned call instruction is identical \p CI in every way except that
        -: 1231:  /// the specified operand bundle has been replaced.
        -: 1232:  static CallBase *Create(CallBase *CB,
        -: 1233:                          OperandBundleDef Bundle,
        -: 1234:                          Instruction *InsertPt = nullptr);
        -: 1235:
        -: 1236:  /// Create a clone of \p CB with operand bundle \p OB added.
        -: 1237:  static CallBase *addOperandBundle(CallBase *CB, uint32_t ID,
        -: 1238:                                    OperandBundleDef OB,
        -: 1239:                                    Instruction *InsertPt = nullptr);
        -: 1240:
        -: 1241:  /// Create a clone of \p CB with operand bundle \p ID removed.
        -: 1242:  static CallBase *removeOperandBundle(CallBase *CB, uint32_t ID,
        -: 1243:                                       Instruction *InsertPt = nullptr);
        -: 1244:
        -: 1245:  static bool classof(const Instruction *I) {
        -: 1246:    return I->getOpcode() == Instruction::Call ||
        -: 1247:           I->getOpcode() == Instruction::Invoke ||
        -: 1248:           I->getOpcode() == Instruction::CallBr;
        -: 1249:  }
        -: 1250:  static bool classof(const Value *V) {
        -: 1251:    return isa<Instruction>(V) && classof(cast<Instruction>(V));
        -: 1252:  }
        -: 1253:
        -: 1254:  FunctionType *getFunctionType() const { return FTy; }
        -: 1255:
        -: 1256:  void mutateFunctionType(FunctionType *FTy) {
        -: 1257:    Value::mutateType(FTy->getReturnType());
        -: 1258:    this->FTy = FTy;
        -: 1259:  }
        -: 1260:
        -: 1261:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -: 1262:
        -: 1263:  /// data_operands_begin/data_operands_end - Return iterators iterating over
        -: 1264:  /// the call / invoke argument list and bundle operands.  For invokes, this is
        -: 1265:  /// the set of instruction operands except the invoke target and the two
        -: 1266:  /// successor blocks; and for calls this is the set of instruction operands
        -: 1267:  /// except the call target.
        -: 1268:  User::op_iterator data_operands_begin() { return op_begin(); }
        -: 1269:  User::const_op_iterator data_operands_begin() const {
        -: 1270:    return const_cast<CallBase *>(this)->data_operands_begin();
        -: 1271:  }
        -: 1272:  User::op_iterator data_operands_end() {
        -: 1273:    // Walk from the end of the operands over the called operand and any
        -: 1274:    // subclass operands.
        -: 1275:    return op_end() - getNumSubclassExtraOperands() - 1;
        -: 1276:  }
        -: 1277:  User::const_op_iterator data_operands_end() const {
        -: 1278:    return const_cast<CallBase *>(this)->data_operands_end();
        -: 1279:  }
        -: 1280:  iterator_range<User::op_iterator> data_ops() {
        -: 1281:    return make_range(data_operands_begin(), data_operands_end());
        -: 1282:  }
        -: 1283:  iterator_range<User::const_op_iterator> data_ops() const {
        -: 1284:    return make_range(data_operands_begin(), data_operands_end());
        -: 1285:  }
        -: 1286:  bool data_operands_empty() const {
        -: 1287:    return data_operands_end() == data_operands_begin();
        -: 1288:  }
        -: 1289:  unsigned data_operands_size() const {
        -: 1290:    return std::distance(data_operands_begin(), data_operands_end());
        -: 1291:  }
        -: 1292:
        -: 1293:  bool isDataOperand(const Use *U) const {
        -: 1294:    assert(this == U->getUser() &&
        -: 1295:           "Only valid to query with a use of this instruction!");
        -: 1296:    return data_operands_begin() <= U && U < data_operands_end();
        -: 1297:  }
        -: 1298:  bool isDataOperand(Value::const_user_iterator UI) const {
        -: 1299:    return isDataOperand(&UI.getUse());
        -: 1300:  }
        -: 1301:
        -: 1302:  /// Given a value use iterator, return the data operand corresponding to it.
        -: 1303:  /// Iterator must actually correspond to a data operand.
        -: 1304:  unsigned getDataOperandNo(Value::const_user_iterator UI) const {
        -: 1305:    return getDataOperandNo(&UI.getUse());
        -: 1306:  }
        -: 1307:
        -: 1308:  /// Given a use for a data operand, get the data operand number that
        -: 1309:  /// corresponds to it.
        -: 1310:  unsigned getDataOperandNo(const Use *U) const {
        -: 1311:    assert(isDataOperand(U) && "Data operand # out of range!");
        -: 1312:    return U - data_operands_begin();
        -: 1313:  }
        -: 1314:
        -: 1315:  /// Return the iterator pointing to the beginning of the argument list.
        -: 1316:  User::op_iterator arg_begin() { return op_begin(); }
        -: 1317:  User::const_op_iterator arg_begin() const {
        -: 1318:    return const_cast<CallBase *>(this)->arg_begin();
        -: 1319:  }
        -: 1320:
        -: 1321:  /// Return the iterator pointing to the end of the argument list.
        -: 1322:  User::op_iterator arg_end() {
        -: 1323:    // From the end of the data operands, walk backwards past the bundle
        -: 1324:    // operands.
        -: 1325:    return data_operands_end() - getNumTotalBundleOperands();
        -: 1326:  }
        -: 1327:  User::const_op_iterator arg_end() const {
        -: 1328:    return const_cast<CallBase *>(this)->arg_end();
        -: 1329:  }
        -: 1330:
        -: 1331:  /// Iteration adapter for range-for loops.
        -: 1332:  iterator_range<User::op_iterator> args() {
        -: 1333:    return make_range(arg_begin(), arg_end());
        -: 1334:  }
        -: 1335:  iterator_range<User::const_op_iterator> args() const {
        -: 1336:    return make_range(arg_begin(), arg_end());
        -: 1337:  }
        -: 1338:  bool arg_empty() const { return arg_end() == arg_begin(); }
        -: 1339:  unsigned arg_size() const { return arg_end() - arg_begin(); }
        -: 1340:
        -: 1341:  Value *getArgOperand(unsigned i) const {
        -: 1342:    assert(i < arg_size() && "Out of bounds!");
        -: 1343:    return getOperand(i);
        -: 1344:  }
        -: 1345:
        -: 1346:  void setArgOperand(unsigned i, Value *v) {
        -: 1347:    assert(i < arg_size() && "Out of bounds!");
        -: 1348:    setOperand(i, v);
        -: 1349:  }
        -: 1350:
        -: 1351:  /// Wrappers for getting the \c Use of a call argument.
        -: 1352:  const Use &getArgOperandUse(unsigned i) const {
        -: 1353:    assert(i < arg_size() && "Out of bounds!");
        -: 1354:    return User::getOperandUse(i);
        -: 1355:  }
        -: 1356:  Use &getArgOperandUse(unsigned i) {
        -: 1357:    assert(i < arg_size() && "Out of bounds!");
        -: 1358:    return User::getOperandUse(i);
        -: 1359:  }
        -: 1360:
        -: 1361:  bool isArgOperand(const Use *U) const {
        -: 1362:    assert(this == U->getUser() &&
        -: 1363:           "Only valid to query with a use of this instruction!");
        -: 1364:    return arg_begin() <= U && U < arg_end();
        -: 1365:  }
        -: 1366:  bool isArgOperand(Value::const_user_iterator UI) const {
        -: 1367:    return isArgOperand(&UI.getUse());
        -: 1368:  }
        -: 1369:
        -: 1370:  /// Given a use for a arg operand, get the arg operand number that
        -: 1371:  /// corresponds to it.
        -: 1372:  unsigned getArgOperandNo(const Use *U) const {
        -: 1373:    assert(isArgOperand(U) && "Arg operand # out of range!");
        -: 1374:    return U - arg_begin();
        -: 1375:  }
        -: 1376:
        -: 1377:  /// Given a value use iterator, return the arg operand number corresponding to
        -: 1378:  /// it. Iterator must actually correspond to a data operand.
        -: 1379:  unsigned getArgOperandNo(Value::const_user_iterator UI) const {
        -: 1380:    return getArgOperandNo(&UI.getUse());
        -: 1381:  }
        -: 1382:
        -: 1383:  /// Returns true if this CallSite passes the given Value* as an argument to
        -: 1384:  /// the called function.
        -: 1385:  bool hasArgument(const Value *V) const {
        -: 1386:    return llvm::is_contained(args(), V);
        -: 1387:  }
        -: 1388:
        -: 1389:  Value *getCalledOperand() const { return Op<CalledOperandOpEndIdx>(); }
        -: 1390:
        -: 1391:  const Use &getCalledOperandUse() const { return Op<CalledOperandOpEndIdx>(); }
        -: 1392:  Use &getCalledOperandUse() { return Op<CalledOperandOpEndIdx>(); }
        -: 1393:
        -: 1394:  /// Returns the function called, or null if this is an indirect function
        -: 1395:  /// invocation or the function signature does not match the call signature.
        -: 1396:  Function *getCalledFunction() const {
        -: 1397:    if (auto *F = dyn_cast_or_null<Function>(getCalledOperand()))
        -: 1398:      if (F->getValueType() == getFunctionType())
        -: 1399:        return F;
        -: 1400:    return nullptr;
        -: 1401:  }
        -: 1402:
        -: 1403:  /// Return true if the callsite is an indirect call.
        -: 1404:  bool isIndirectCall() const;
        -: 1405:
        -: 1406:  /// Determine whether the passed iterator points to the callee operand's Use.
        -: 1407:  bool isCallee(Value::const_user_iterator UI) const {
        -: 1408:    return isCallee(&UI.getUse());
        -: 1409:  }
        -: 1410:
        -: 1411:  /// Determine whether this Use is the callee operand's Use.
        -: 1412:  bool isCallee(const Use *U) const { return &getCalledOperandUse() == U; }
        -: 1413:
        -: 1414:  /// Helper to get the caller (the parent function).
        -: 1415:  Function *getCaller();
        -: 1416:  const Function *getCaller() const {
        -: 1417:    return const_cast<CallBase *>(this)->getCaller();
        -: 1418:  }
        -: 1419:
        -: 1420:  /// Tests if this call site must be tail call optimized. Only a CallInst can
        -: 1421:  /// be tail call optimized.
        -: 1422:  bool isMustTailCall() const;
        -: 1423:
        -: 1424:  /// Tests if this call site is marked as a tail call.
        -: 1425:  bool isTailCall() const;
        -: 1426:
        -: 1427:  /// Returns the intrinsic ID of the intrinsic called or
        -: 1428:  /// Intrinsic::not_intrinsic if the called function is not an intrinsic, or if
        -: 1429:  /// this is an indirect call.
        -: 1430:  Intrinsic::ID getIntrinsicID() const;
        -: 1431:
        -: 1432:  void setCalledOperand(Value *V) { Op<CalledOperandOpEndIdx>() = V; }
        -: 1433:
        -: 1434:  /// Sets the function called, including updating the function type.
        -: 1435:  void setCalledFunction(Function *Fn) {
        -: 1436:    setCalledFunction(Fn->getFunctionType(), Fn);
        -: 1437:  }
        -: 1438:
        -: 1439:  /// Sets the function called, including updating the function type.
        -: 1440:  void setCalledFunction(FunctionCallee Fn) {
        -: 1441:    setCalledFunction(Fn.getFunctionType(), Fn.getCallee());
        -: 1442:  }
        -: 1443:
        -: 1444:  /// Sets the function called, including updating to the specified function
        -: 1445:  /// type.
        -: 1446:  void setCalledFunction(FunctionType *FTy, Value *Fn) {
        -: 1447:    this->FTy = FTy;
        -: 1448:    assert(cast<PointerType>(Fn->getType())->isOpaqueOrPointeeTypeMatches(FTy));
        -: 1449:    // This function doesn't mutate the return type, only the function
        -: 1450:    // type. Seems broken, but I'm just gonna stick an assert in for now.
        -: 1451:    assert(getType() == FTy->getReturnType());
        -: 1452:    setCalledOperand(Fn);
        -: 1453:  }
        -: 1454:
        -: 1455:  CallingConv::ID getCallingConv() const {
        -: 1456:    return getSubclassData<CallingConvField>();
        -: 1457:  }
        -: 1458:
        -: 1459:  void setCallingConv(CallingConv::ID CC) {
        -: 1460:    setSubclassData<CallingConvField>(CC);
        -: 1461:  }
        -: 1462:
        -: 1463:  /// Check if this call is an inline asm statement.
        -: 1464:  bool isInlineAsm() const { return isa<InlineAsm>(getCalledOperand()); }
        -: 1465:
        -: 1466:  /// \name Attribute API
        -: 1467:  ///
        -: 1468:  /// These methods access and modify attributes on this call (including
        -: 1469:  /// looking through to the attributes on the called function when necessary).
        -: 1470:  ///@{
        -: 1471:
        -: 1472:  /// Return the parameter attributes for this call.
        -: 1473:  ///
        -: 1474:  AttributeList getAttributes() const { return Attrs; }
        -: 1475:
        -: 1476:  /// Set the parameter attributes for this call.
        -: 1477:  ///
        -: 1478:  void setAttributes(AttributeList A) { Attrs = A; }
        -: 1479:
        -: 1480:  /// Determine whether this call has the given attribute. If it does not
        -: 1481:  /// then determine if the called function has the attribute, but only if
        -: 1482:  /// the attribute is allowed for the call.
        -: 1483:  bool hasFnAttr(Attribute::AttrKind Kind) const {
        -: 1484:    assert(Kind != Attribute::NoBuiltin &&
        -: 1485:           "Use CallBase::isNoBuiltin() to check for Attribute::NoBuiltin");
        -: 1486:    return hasFnAttrImpl(Kind);
        -: 1487:  }
        -: 1488:
        -: 1489:  /// Determine whether this call has the given attribute. If it does not
        -: 1490:  /// then determine if the called function has the attribute, but only if
        -: 1491:  /// the attribute is allowed for the call.
        -: 1492:  bool hasFnAttr(StringRef Kind) const { return hasFnAttrImpl(Kind); }
        -: 1493:
        -: 1494:  // TODO: remove non-AtIndex versions of these methods.
        -: 1495:  /// adds the attribute to the list of attributes.
        -: 1496:  void addAttributeAtIndex(unsigned i, Attribute::AttrKind Kind) {
        -: 1497:    Attrs = Attrs.addAttributeAtIndex(getContext(), i, Kind);
        -: 1498:  }
        -: 1499:
        -: 1500:  /// adds the attribute to the list of attributes.
        -: 1501:  void addAttributeAtIndex(unsigned i, Attribute Attr) {
        -: 1502:    Attrs = Attrs.addAttributeAtIndex(getContext(), i, Attr);
        -: 1503:  }
        -: 1504:
        -: 1505:  /// Adds the attribute to the function.
        -: 1506:  void addFnAttr(Attribute::AttrKind Kind) {
        -: 1507:    Attrs = Attrs.addFnAttribute(getContext(), Kind);
        -: 1508:  }
        -: 1509:
        -: 1510:  /// Adds the attribute to the function.
        -: 1511:  void addFnAttr(Attribute Attr) {
        -: 1512:    Attrs = Attrs.addFnAttribute(getContext(), Attr);
        -: 1513:  }
        -: 1514:
        -: 1515:  /// Adds the attribute to the return value.
        -: 1516:  void addRetAttr(Attribute::AttrKind Kind) {
        -: 1517:    Attrs = Attrs.addRetAttribute(getContext(), Kind);
        -: 1518:  }
        -: 1519:
        -: 1520:  /// Adds the attribute to the return value.
        -: 1521:  void addRetAttr(Attribute Attr) {
        -: 1522:    Attrs = Attrs.addRetAttribute(getContext(), Attr);
        -: 1523:  }
        -: 1524:
        -: 1525:  /// Adds the attribute to the indicated argument
        -: 1526:  void addParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) {
        -: 1527:    assert(ArgNo < arg_size() && "Out of bounds");
        -: 1528:    Attrs = Attrs.addParamAttribute(getContext(), ArgNo, Kind);
        -: 1529:  }
        -: 1530:
        -: 1531:  /// Adds the attribute to the indicated argument
        -: 1532:  void addParamAttr(unsigned ArgNo, Attribute Attr) {
        -: 1533:    assert(ArgNo < arg_size() && "Out of bounds");
        -: 1534:    Attrs = Attrs.addParamAttribute(getContext(), ArgNo, Attr);
        -: 1535:  }
        -: 1536:
        -: 1537:  /// removes the attribute from the list of attributes.
        -: 1538:  void removeAttributeAtIndex(unsigned i, Attribute::AttrKind Kind) {
        -: 1539:    Attrs = Attrs.removeAttributeAtIndex(getContext(), i, Kind);
        -: 1540:  }
        -: 1541:
        -: 1542:  /// removes the attribute from the list of attributes.
        -: 1543:  void removeAttributeAtIndex(unsigned i, StringRef Kind) {
        -: 1544:    Attrs = Attrs.removeAttributeAtIndex(getContext(), i, Kind);
        -: 1545:  }
        -: 1546:
        -: 1547:  /// Removes the attributes from the function
        -: 1548:  void removeFnAttrs(const AttributeMask &AttrsToRemove) {
        -: 1549:    Attrs = Attrs.removeFnAttributes(getContext(), AttrsToRemove);
        -: 1550:  }
        -: 1551:
        -: 1552:  /// Removes the attribute from the function
        -: 1553:  void removeFnAttr(Attribute::AttrKind Kind) {
        -: 1554:    Attrs = Attrs.removeFnAttribute(getContext(), Kind);
        -: 1555:  }
        -: 1556:
        -: 1557:  /// Removes the attribute from the return value
        -: 1558:  void removeRetAttr(Attribute::AttrKind Kind) {
        -: 1559:    Attrs = Attrs.removeRetAttribute(getContext(), Kind);
        -: 1560:  }
        -: 1561:
        -: 1562:  /// Removes the attributes from the return value
        -: 1563:  void removeRetAttrs(const AttributeMask &AttrsToRemove) {
        -: 1564:    Attrs = Attrs.removeRetAttributes(getContext(), AttrsToRemove);
        -: 1565:  }
        -: 1566:
        -: 1567:  /// Removes the attribute from the given argument
        -: 1568:  void removeParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) {
        -: 1569:    assert(ArgNo < arg_size() && "Out of bounds");
        -: 1570:    Attrs = Attrs.removeParamAttribute(getContext(), ArgNo, Kind);
        -: 1571:  }
        -: 1572:
        -: 1573:  /// Removes the attribute from the given argument
        -: 1574:  void removeParamAttr(unsigned ArgNo, StringRef Kind) {
        -: 1575:    assert(ArgNo < arg_size() && "Out of bounds");
        -: 1576:    Attrs = Attrs.removeParamAttribute(getContext(), ArgNo, Kind);
        -: 1577:  }
        -: 1578:
        -: 1579:  /// Removes the attributes from the given argument
        -: 1580:  void removeParamAttrs(unsigned ArgNo, const AttributeMask &AttrsToRemove) {
        -: 1581:    Attrs = Attrs.removeParamAttributes(getContext(), ArgNo, AttrsToRemove);
        -: 1582:  }
        -: 1583:
        -: 1584:  /// adds the dereferenceable attribute to the list of attributes.
        -: 1585:  void addDereferenceableParamAttr(unsigned i, uint64_t Bytes) {
        -: 1586:    Attrs = Attrs.addDereferenceableParamAttr(getContext(), i, Bytes);
        -: 1587:  }
        -: 1588:
        -: 1589:  /// adds the dereferenceable attribute to the list of attributes.
        -: 1590:  void addDereferenceableRetAttr(uint64_t Bytes) {
        -: 1591:    Attrs = Attrs.addDereferenceableRetAttr(getContext(), Bytes);
        -: 1592:  }
        -: 1593:
        -: 1594:  /// Determine whether the return value has the given attribute.
        -: 1595:  bool hasRetAttr(Attribute::AttrKind Kind) const {
        -: 1596:    return hasRetAttrImpl(Kind);
        -: 1597:  }
        -: 1598:  /// Determine whether the return value has the given attribute.
        -: 1599:  bool hasRetAttr(StringRef Kind) const { return hasRetAttrImpl(Kind); }
        -: 1600:
        -: 1601:  /// Determine whether the argument or parameter has the given attribute.
        -: 1602:  bool paramHasAttr(unsigned ArgNo, Attribute::AttrKind Kind) const;
        -: 1603:
        -: 1604:  /// Get the attribute of a given kind at a position.
        -: 1605:  Attribute getAttributeAtIndex(unsigned i, Attribute::AttrKind Kind) const {
        -: 1606:    return getAttributes().getAttributeAtIndex(i, Kind);
        -: 1607:  }
        -: 1608:
        -: 1609:  /// Get the attribute of a given kind at a position.
        -: 1610:  Attribute getAttributeAtIndex(unsigned i, StringRef Kind) const {
        -: 1611:    return getAttributes().getAttributeAtIndex(i, Kind);
        -: 1612:  }
        -: 1613:
        -: 1614:  /// Get the attribute of a given kind for the function.
        -: 1615:  Attribute getFnAttr(StringRef Kind) const {
        -: 1616:    Attribute Attr = getAttributes().getFnAttr(Kind);
        -: 1617:    if (Attr.isValid())
        -: 1618:      return Attr;
        -: 1619:    return getFnAttrOnCalledFunction(Kind);
        -: 1620:  }
        -: 1621:
        -: 1622:  /// Get the attribute of a given kind for the function.
        -: 1623:  Attribute getFnAttr(Attribute::AttrKind Kind) const {
        -: 1624:    Attribute A = getAttributes().getFnAttr(Kind);
        -: 1625:    if (A.isValid())
        -: 1626:      return A;
        -: 1627:    return getFnAttrOnCalledFunction(Kind);
        -: 1628:  }
        -: 1629:
        -: 1630:  /// Get the attribute of a given kind from a given arg
        -: 1631:  Attribute getParamAttr(unsigned ArgNo, Attribute::AttrKind Kind) const {
        -: 1632:    assert(ArgNo < arg_size() && "Out of bounds");
        -: 1633:    return getAttributes().getParamAttr(ArgNo, Kind);
        -: 1634:  }
        -: 1635:
        -: 1636:  /// Get the attribute of a given kind from a given arg
        -: 1637:  Attribute getParamAttr(unsigned ArgNo, StringRef Kind) const {
        -: 1638:    assert(ArgNo < arg_size() && "Out of bounds");
        -: 1639:    return getAttributes().getParamAttr(ArgNo, Kind);
        -: 1640:  }
        -: 1641:
        -: 1642:  /// Return true if the data operand at index \p i has the attribute \p
        -: 1643:  /// A.
        -: 1644:  ///
        -: 1645:  /// Data operands include call arguments and values used in operand bundles,
        -: 1646:  /// but does not include the callee operand.
        -: 1647:  ///
        -: 1648:  /// The index \p i is interpreted as
        -: 1649:  ///
        -: 1650:  ///  \p i in [0, arg_size)  -> argument number (\p i)
        -: 1651:  ///  \p i in [arg_size, data_operand_size) -> bundle operand at index
        -: 1652:  ///     (\p i) in the operand list.
        -: 1653:  bool dataOperandHasImpliedAttr(unsigned i, Attribute::AttrKind Kind) const {
        -: 1654:    // Note that we have to add one because `i` isn't zero-indexed.
        -: 1655:    assert(i < arg_size() + getNumTotalBundleOperands() &&
        -: 1656:           "Data operand index out of bounds!");
        -: 1657:
        -: 1658:    // The attribute A can either be directly specified, if the operand in
        -: 1659:    // question is a call argument; or be indirectly implied by the kind of its
        -: 1660:    // containing operand bundle, if the operand is a bundle operand.
        -: 1661:
        -: 1662:    if (i < arg_size())
        -: 1663:      return paramHasAttr(i, Kind);
        -: 1664:
        -: 1665:    assert(hasOperandBundles() && i >= getBundleOperandsStartIndex() &&
        -: 1666:           "Must be either a call argument or an operand bundle!");
        -: 1667:    return bundleOperandHasAttr(i, Kind);
        -: 1668:  }
        -: 1669:
        -: 1670:  /// Determine whether this data operand is not captured.
        -: 1671:  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to
        -: 1672:  // better indicate that this may return a conservative answer.
        -: 1673:  bool doesNotCapture(unsigned OpNo) const {
        -: 1674:    return dataOperandHasImpliedAttr(OpNo, Attribute::NoCapture);
        -: 1675:  }
        -: 1676:
        -: 1677:  /// Determine whether this argument is passed by value.
        -: 1678:  bool isByValArgument(unsigned ArgNo) const {
        -: 1679:    return paramHasAttr(ArgNo, Attribute::ByVal);
        -: 1680:  }
        -: 1681:
        -: 1682:  /// Determine whether this argument is passed in an alloca.
        -: 1683:  bool isInAllocaArgument(unsigned ArgNo) const {
        -: 1684:    return paramHasAttr(ArgNo, Attribute::InAlloca);
        -: 1685:  }
        -: 1686:
        -: 1687:  /// Determine whether this argument is passed by value, in an alloca, or is
        -: 1688:  /// preallocated.
        -: 1689:  bool isPassPointeeByValueArgument(unsigned ArgNo) const {
        -: 1690:    return paramHasAttr(ArgNo, Attribute::ByVal) ||
        -: 1691:           paramHasAttr(ArgNo, Attribute::InAlloca) ||
        -: 1692:           paramHasAttr(ArgNo, Attribute::Preallocated);
        -: 1693:  }
        -: 1694:
        -: 1695:  /// Determine whether passing undef to this argument is undefined behavior.
        -: 1696:  /// If passing undef to this argument is UB, passing poison is UB as well
        -: 1697:  /// because poison is more undefined than undef.
        -: 1698:  bool isPassingUndefUB(unsigned ArgNo) const {
        -: 1699:    return paramHasAttr(ArgNo, Attribute::NoUndef) ||
        -: 1700:           // dereferenceable implies noundef.
        -: 1701:           paramHasAttr(ArgNo, Attribute::Dereferenceable) ||
        -: 1702:           // dereferenceable implies noundef, and null is a well-defined value.
        -: 1703:           paramHasAttr(ArgNo, Attribute::DereferenceableOrNull);
        -: 1704:  }
        -: 1705:
        -: 1706:  /// Determine if there are is an inalloca argument. Only the last argument can
        -: 1707:  /// have the inalloca attribute.
        -: 1708:  bool hasInAllocaArgument() const {
        -: 1709:    return !arg_empty() && paramHasAttr(arg_size() - 1, Attribute::InAlloca);
        -: 1710:  }
        -: 1711:
        -: 1712:  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to
        -: 1713:  // better indicate that this may return a conservative answer.
        -: 1714:  bool doesNotAccessMemory(unsigned OpNo) const {
        -: 1715:    return dataOperandHasImpliedAttr(OpNo, Attribute::ReadNone);
        -: 1716:  }
        -: 1717:
        -: 1718:  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to
        -: 1719:  // better indicate that this may return a conservative answer.
        -: 1720:  bool onlyReadsMemory(unsigned OpNo) const {
        -: 1721:    return dataOperandHasImpliedAttr(OpNo, Attribute::ReadOnly) ||
        -: 1722:           dataOperandHasImpliedAttr(OpNo, Attribute::ReadNone);
        -: 1723:  }
        -: 1724:
        -: 1725:  // FIXME: Once this API is no longer duplicated in `CallSite`, rename this to
        -: 1726:  // better indicate that this may return a conservative answer.
        -: 1727:  bool onlyWritesMemory(unsigned OpNo) const {
        -: 1728:    return dataOperandHasImpliedAttr(OpNo, Attribute::WriteOnly) ||
        -: 1729:           dataOperandHasImpliedAttr(OpNo, Attribute::ReadNone);
        -: 1730:  }
        -: 1731:
        -: 1732:  /// Extract the alignment of the return value.
        -: 1733:  MaybeAlign getRetAlign() const {
        -: 1734:    if (auto Align = Attrs.getRetAlignment())
        -: 1735:      return Align;
        -: 1736:    if (const Function *F = getCalledFunction())
        -: 1737:      return F->getAttributes().getRetAlignment();
        -: 1738:    return None;
        -: 1739:  }
        -: 1740:
        -: 1741:  /// Extract the alignment for a call or parameter (0=unknown).
        -: 1742:  MaybeAlign getParamAlign(unsigned ArgNo) const {
        -: 1743:    return Attrs.getParamAlignment(ArgNo);
        -: 1744:  }
        -: 1745:
        -: 1746:  MaybeAlign getParamStackAlign(unsigned ArgNo) const {
        -: 1747:    return Attrs.getParamStackAlignment(ArgNo);
        -: 1748:  }
        -: 1749:
        -: 1750:  /// Extract the byval type for a call or parameter.
        -: 1751:  Type *getParamByValType(unsigned ArgNo) const {
        -: 1752:    if (auto *Ty = Attrs.getParamByValType(ArgNo))
        -: 1753:      return Ty;
        -: 1754:    if (const Function *F = getCalledFunction())
        -: 1755:      return F->getAttributes().getParamByValType(ArgNo);
        -: 1756:    return nullptr;
        -: 1757:  }
        -: 1758:
        -: 1759:  /// Extract the preallocated type for a call or parameter.
        -: 1760:  Type *getParamPreallocatedType(unsigned ArgNo) const {
        -: 1761:    if (auto *Ty = Attrs.getParamPreallocatedType(ArgNo))
        -: 1762:      return Ty;
        -: 1763:    if (const Function *F = getCalledFunction())
        -: 1764:      return F->getAttributes().getParamPreallocatedType(ArgNo);
        -: 1765:    return nullptr;
        -: 1766:  }
        -: 1767:
        -: 1768:  /// Extract the inalloca type for a call or parameter.
        -: 1769:  Type *getParamInAllocaType(unsigned ArgNo) const {
        -: 1770:    if (auto *Ty = Attrs.getParamInAllocaType(ArgNo))
        -: 1771:      return Ty;
        -: 1772:    if (const Function *F = getCalledFunction())
        -: 1773:      return F->getAttributes().getParamInAllocaType(ArgNo);
        -: 1774:    return nullptr;
        -: 1775:  }
        -: 1776:
        -: 1777:  /// Extract the sret type for a call or parameter.
        -: 1778:  Type *getParamStructRetType(unsigned ArgNo) const {
        -: 1779:    if (auto *Ty = Attrs.getParamStructRetType(ArgNo))
        -: 1780:      return Ty;
        -: 1781:    if (const Function *F = getCalledFunction())
        -: 1782:      return F->getAttributes().getParamStructRetType(ArgNo);
        -: 1783:    return nullptr;
        -: 1784:  }
        -: 1785:
        -: 1786:  /// Extract the elementtype type for a parameter.
        -: 1787:  /// Note that elementtype() can only be applied to call arguments, not
        -: 1788:  /// function declaration parameters.
        -: 1789:  Type *getParamElementType(unsigned ArgNo) const {
        -: 1790:    return Attrs.getParamElementType(ArgNo);
        -: 1791:  }
        -: 1792:
        -: 1793:  /// Extract the number of dereferenceable bytes for a call or
        -: 1794:  /// parameter (0=unknown).
        -: 1795:  uint64_t getRetDereferenceableBytes() const {
        -: 1796:    return Attrs.getRetDereferenceableBytes();
        -: 1797:  }
        -: 1798:
        -: 1799:  /// Extract the number of dereferenceable bytes for a call or
        -: 1800:  /// parameter (0=unknown).
        -: 1801:  uint64_t getParamDereferenceableBytes(unsigned i) const {
        -: 1802:    return Attrs.getParamDereferenceableBytes(i);
        -: 1803:  }
        -: 1804:
        -: 1805:  /// Extract the number of dereferenceable_or_null bytes for a call
        -: 1806:  /// (0=unknown).
        -: 1807:  uint64_t getRetDereferenceableOrNullBytes() const {
        -: 1808:    return Attrs.getRetDereferenceableOrNullBytes();
        -: 1809:  }
        -: 1810:
        -: 1811:  /// Extract the number of dereferenceable_or_null bytes for a
        -: 1812:  /// parameter (0=unknown).
        -: 1813:  uint64_t getParamDereferenceableOrNullBytes(unsigned i) const {
        -: 1814:    return Attrs.getParamDereferenceableOrNullBytes(i);
        -: 1815:  }
        -: 1816:
        -: 1817:  /// Return true if the return value is known to be not null.
        -: 1818:  /// This may be because it has the nonnull attribute, or because at least
        -: 1819:  /// one byte is dereferenceable and the pointer is in addrspace(0).
        -: 1820:  bool isReturnNonNull() const;
        -: 1821:
        -: 1822:  /// Determine if the return value is marked with NoAlias attribute.
        -: 1823:  bool returnDoesNotAlias() const {
        -: 1824:    return Attrs.hasRetAttr(Attribute::NoAlias);
        -: 1825:  }
        -: 1826:
        -: 1827:  /// If one of the arguments has the 'returned' attribute, returns its
        -: 1828:  /// operand value. Otherwise, return nullptr.
        -: 1829:  Value *getReturnedArgOperand() const {
        -: 1830:    return getArgOperandWithAttribute(Attribute::Returned);
        -: 1831:  }
        -: 1832:
        -: 1833:  /// If one of the arguments has the specified attribute, returns its
        -: 1834:  /// operand value. Otherwise, return nullptr.
        -: 1835:  Value *getArgOperandWithAttribute(Attribute::AttrKind Kind) const;
        -: 1836:
        -: 1837:  /// Return true if the call should not be treated as a call to a
        -: 1838:  /// builtin.
        -: 1839:  bool isNoBuiltin() const {
        -: 1840:    return hasFnAttrImpl(Attribute::NoBuiltin) &&
        -: 1841:           !hasFnAttrImpl(Attribute::Builtin);
        -: 1842:  }
        -: 1843:
        -: 1844:  /// Determine if the call requires strict floating point semantics.
        -: 1845:  bool isStrictFP() const { return hasFnAttr(Attribute::StrictFP); }
        -: 1846:
        -: 1847:  /// Return true if the call should not be inlined.
        -: 1848:  bool isNoInline() const { return hasFnAttr(Attribute::NoInline); }
        -: 1849:  void setIsNoInline() { addFnAttr(Attribute::NoInline); }
        -: 1850:  /// Determine if the call does not access memory.
        -: 1851:  bool doesNotAccessMemory() const { return hasFnAttr(Attribute::ReadNone); }
        -: 1852:  void setDoesNotAccessMemory() { addFnAttr(Attribute::ReadNone); }
        -: 1853:
        -: 1854:  /// Determine if the call does not access or only reads memory.
        -: 1855:  bool onlyReadsMemory() const {
        -: 1856:    return hasImpliedFnAttr(Attribute::ReadOnly);
        -: 1857:  }
        -: 1858:
        -: 1859:  void setOnlyReadsMemory() { addFnAttr(Attribute::ReadOnly); }
        -: 1860:
        -: 1861:  /// Determine if the call does not access or only writes memory.
        -: 1862:  bool onlyWritesMemory() const {
        -: 1863:    return hasImpliedFnAttr(Attribute::WriteOnly);
        -: 1864:  }
        -: 1865:  void setOnlyWritesMemory() { addFnAttr(Attribute::WriteOnly); }
        -: 1866:
        -: 1867:  /// Determine if the call can access memmory only using pointers based
        -: 1868:  /// on its arguments.
        -: 1869:  bool onlyAccessesArgMemory() const {
        -: 1870:    return hasFnAttr(Attribute::ArgMemOnly);
        -: 1871:  }
        -: 1872:  void setOnlyAccessesArgMemory() { addFnAttr(Attribute::ArgMemOnly); }
        -: 1873:
        -: 1874:  /// Determine if the function may only access memory that is
        -: 1875:  /// inaccessible from the IR.
        -: 1876:  bool onlyAccessesInaccessibleMemory() const {
        -: 1877:    return hasFnAttr(Attribute::InaccessibleMemOnly);
        -: 1878:  }
        -: 1879:  void setOnlyAccessesInaccessibleMemory() {
        -: 1880:    addFnAttr(Attribute::InaccessibleMemOnly);
        -: 1881:  }
        -: 1882:
        -: 1883:  /// Determine if the function may only access memory that is
        -: 1884:  /// either inaccessible from the IR or pointed to by its arguments.
        -: 1885:  bool onlyAccessesInaccessibleMemOrArgMem() const {
        -: 1886:    return hasFnAttr(Attribute::InaccessibleMemOrArgMemOnly);
        -: 1887:  }
        -: 1888:  void setOnlyAccessesInaccessibleMemOrArgMem() {
        -: 1889:    addFnAttr(Attribute::InaccessibleMemOrArgMemOnly);
        -: 1890:  }
        -: 1891:  /// Determine if the call cannot return.
        -: 1892:  bool doesNotReturn() const { return hasFnAttr(Attribute::NoReturn); }
        -: 1893:  void setDoesNotReturn() { addFnAttr(Attribute::NoReturn); }
        -: 1894:
        -: 1895:  /// Determine if the call should not perform indirect branch tracking.
        -: 1896:  bool doesNoCfCheck() const { return hasFnAttr(Attribute::NoCfCheck); }
        -: 1897:
        -: 1898:  /// Determine if the call cannot unwind.
        -: 1899:  bool doesNotThrow() const { return hasFnAttr(Attribute::NoUnwind); }
        -: 1900:  void setDoesNotThrow() { addFnAttr(Attribute::NoUnwind); }
        -: 1901:
        -: 1902:  /// Determine if the invoke cannot be duplicated.
        -: 1903:  bool cannotDuplicate() const { return hasFnAttr(Attribute::NoDuplicate); }
        -: 1904:  void setCannotDuplicate() { addFnAttr(Attribute::NoDuplicate); }
        -: 1905:
        -: 1906:  /// Determine if the call cannot be tail merged.
        -: 1907:  bool cannotMerge() const { return hasFnAttr(Attribute::NoMerge); }
        -: 1908:  void setCannotMerge() { addFnAttr(Attribute::NoMerge); }
        -: 1909:
        -: 1910:  /// Determine if the invoke is convergent
        -: 1911:  bool isConvergent() const { return hasFnAttr(Attribute::Convergent); }
        -: 1912:  void setConvergent() { addFnAttr(Attribute::Convergent); }
        -: 1913:  void setNotConvergent() { removeFnAttr(Attribute::Convergent); }
        -: 1914:
        -: 1915:  /// Determine if the call returns a structure through first
        -: 1916:  /// pointer argument.
        -: 1917:  bool hasStructRetAttr() const {
        -: 1918:    if (arg_empty())
        -: 1919:      return false;
        -: 1920:
        -: 1921:    // Be friendly and also check the callee.
        -: 1922:    return paramHasAttr(0, Attribute::StructRet);
        -: 1923:  }
        -: 1924:
        -: 1925:  /// Determine if any call argument is an aggregate passed by value.
        -: 1926:  bool hasByValArgument() const {
        -: 1927:    return Attrs.hasAttrSomewhere(Attribute::ByVal);
        -: 1928:  }
        -: 1929:
        -: 1930:  ///@{
        -: 1931:  // End of attribute API.
        -: 1932:
        -: 1933:  /// \name Operand Bundle API
        -: 1934:  ///
        -: 1935:  /// This group of methods provides the API to access and manipulate operand
        -: 1936:  /// bundles on this call.
        -: 1937:  /// @{
        -: 1938:
        -: 1939:  /// Return the number of operand bundles associated with this User.
        -: 1940:  unsigned getNumOperandBundles() const {
        -: 1941:    return std::distance(bundle_op_info_begin(), bundle_op_info_end());
        -: 1942:  }
        -: 1943:
        -: 1944:  /// Return true if this User has any operand bundles.
        -: 1945:  bool hasOperandBundles() const { return getNumOperandBundles() != 0; }
        -: 1946:
        -: 1947:  /// Return the index of the first bundle operand in the Use array.
        -: 1948:  unsigned getBundleOperandsStartIndex() const {
        -: 1949:    assert(hasOperandBundles() && "Don't call otherwise!");
        -: 1950:    return bundle_op_info_begin()->Begin;
        -: 1951:  }
        -: 1952:
        -: 1953:  /// Return the index of the last bundle operand in the Use array.
        -: 1954:  unsigned getBundleOperandsEndIndex() const {
        -: 1955:    assert(hasOperandBundles() && "Don't call otherwise!");
        -: 1956:    return bundle_op_info_end()[-1].End;
        -: 1957:  }
        -: 1958:
        -: 1959:  /// Return true if the operand at index \p Idx is a bundle operand.
        -: 1960:  bool isBundleOperand(unsigned Idx) const {
        -: 1961:    return hasOperandBundles() && Idx >= getBundleOperandsStartIndex() &&
        -: 1962:           Idx < getBundleOperandsEndIndex();
        -: 1963:  }
        -: 1964:
        -: 1965:  /// Return true if the operand at index \p Idx is a bundle operand that has
        -: 1966:  /// tag ID \p ID.
        -: 1967:  bool isOperandBundleOfType(uint32_t ID, unsigned Idx) const {
        -: 1968:    return isBundleOperand(Idx) &&
        -: 1969:           getOperandBundleForOperand(Idx).getTagID() == ID;
        -: 1970:  }
        -: 1971:
        -: 1972:  /// Returns true if the use is a bundle operand.
        -: 1973:  bool isBundleOperand(const Use *U) const {
        -: 1974:    assert(this == U->getUser() &&
        -: 1975:           "Only valid to query with a use of this instruction!");
        -: 1976:    return hasOperandBundles() && isBundleOperand(U - op_begin());
        -: 1977:  }
        -: 1978:  bool isBundleOperand(Value::const_user_iterator UI) const {
        -: 1979:    return isBundleOperand(&UI.getUse());
        -: 1980:  }
        -: 1981:
        -: 1982:  /// Return the total number operands (not operand bundles) used by
        -: 1983:  /// every operand bundle in this OperandBundleUser.
        -: 1984:  unsigned getNumTotalBundleOperands() const {
        -: 1985:    if (!hasOperandBundles())
        -: 1986:      return 0;
        -: 1987:
        -: 1988:    unsigned Begin = getBundleOperandsStartIndex();
        -: 1989:    unsigned End = getBundleOperandsEndIndex();
        -: 1990:
        -: 1991:    assert(Begin <= End && "Should be!");
        -: 1992:    return End - Begin;
        -: 1993:  }
        -: 1994:
        -: 1995:  /// Return the operand bundle at a specific index.
        -: 1996:  OperandBundleUse getOperandBundleAt(unsigned Index) const {
        -: 1997:    assert(Index < getNumOperandBundles() && "Index out of bounds!");
        -: 1998:    return operandBundleFromBundleOpInfo(*(bundle_op_info_begin() + Index));
        -: 1999:  }
        -: 2000:
        -: 2001:  /// Return the number of operand bundles with the tag Name attached to
        -: 2002:  /// this instruction.
        -: 2003:  unsigned countOperandBundlesOfType(StringRef Name) const {
        -: 2004:    unsigned Count = 0;
        -: 2005:    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)
        -: 2006:      if (getOperandBundleAt(i).getTagName() == Name)
        -: 2007:        Count++;
        -: 2008:
        -: 2009:    return Count;
        -: 2010:  }
        -: 2011:
        -: 2012:  /// Return the number of operand bundles with the tag ID attached to
        -: 2013:  /// this instruction.
        -: 2014:  unsigned countOperandBundlesOfType(uint32_t ID) const {
        -: 2015:    unsigned Count = 0;
        -: 2016:    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i)
        -: 2017:      if (getOperandBundleAt(i).getTagID() == ID)
        -: 2018:        Count++;
        -: 2019:
        -: 2020:    return Count;
        -: 2021:  }
        -: 2022:
        -: 2023:  /// Return an operand bundle by name, if present.
        -: 2024:  ///
        -: 2025:  /// It is an error to call this for operand bundle types that may have
        -: 2026:  /// multiple instances of them on the same instruction.
        -: 2027:  Optional<OperandBundleUse> getOperandBundle(StringRef Name) const {
        -: 2028:    assert(countOperandBundlesOfType(Name) < 2 && "Precondition violated!");
        -: 2029:
        -: 2030:    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {
        -: 2031:      OperandBundleUse U = getOperandBundleAt(i);
        -: 2032:      if (U.getTagName() == Name)
        -: 2033:        return U;
        -: 2034:    }
        -: 2035:
        -: 2036:    return None;
        -: 2037:  }
        -: 2038:
        -: 2039:  /// Return an operand bundle by tag ID, if present.
        -: 2040:  ///
        -: 2041:  /// It is an error to call this for operand bundle types that may have
        -: 2042:  /// multiple instances of them on the same instruction.
        -: 2043:  Optional<OperandBundleUse> getOperandBundle(uint32_t ID) const {
        -: 2044:    assert(countOperandBundlesOfType(ID) < 2 && "Precondition violated!");
        -: 2045:
        -: 2046:    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {
        -: 2047:      OperandBundleUse U = getOperandBundleAt(i);
        -: 2048:      if (U.getTagID() == ID)
        -: 2049:        return U;
        -: 2050:    }
        -: 2051:
        -: 2052:    return None;
        -: 2053:  }
        -: 2054:
        -: 2055:  /// Return the list of operand bundles attached to this instruction as
        -: 2056:  /// a vector of OperandBundleDefs.
        -: 2057:  ///
        -: 2058:  /// This function copies the OperandBundeUse instances associated with this
        -: 2059:  /// OperandBundleUser to a vector of OperandBundleDefs.  Note:
        -: 2060:  /// OperandBundeUses and OperandBundleDefs are non-trivially *different*
        -: 2061:  /// representations of operand bundles (see documentation above).
        -: 2062:  void getOperandBundlesAsDefs(SmallVectorImpl<OperandBundleDef> &Defs) const;
        -: 2063:
        -: 2064:  /// Return the operand bundle for the operand at index OpIdx.
        -: 2065:  ///
        -: 2066:  /// It is an error to call this with an OpIdx that does not correspond to an
        -: 2067:  /// bundle operand.
        -: 2068:  OperandBundleUse getOperandBundleForOperand(unsigned OpIdx) const {
        -: 2069:    return operandBundleFromBundleOpInfo(getBundleOpInfoForOperand(OpIdx));
        -: 2070:  }
        -: 2071:
        -: 2072:  /// Return true if this operand bundle user has operand bundles that
        -: 2073:  /// may read from the heap.
        -: 2074:  bool hasReadingOperandBundles() const;
        -: 2075:
        -: 2076:  /// Return true if this operand bundle user has operand bundles that
        -: 2077:  /// may write to the heap.
        -: 2078:  bool hasClobberingOperandBundles() const {
        -: 2079:    for (auto &BOI : bundle_op_infos()) {
        -: 2080:      if (BOI.Tag->second == LLVMContext::OB_deopt ||
        -: 2081:          BOI.Tag->second == LLVMContext::OB_funclet ||
        -: 2082:          BOI.Tag->second == LLVMContext::OB_ptrauth)
        -: 2083:        continue;
        -: 2084:
        -: 2085:      // This instruction has an operand bundle that is not known to us.
        -: 2086:      // Assume the worst.
        -: 2087:      return true;
        -: 2088:    }
        -: 2089:
        -: 2090:    return false;
        -: 2091:  }
        -: 2092:
        -: 2093:  /// Return true if the bundle operand at index \p OpIdx has the
        -: 2094:  /// attribute \p A.
        -: 2095:  bool bundleOperandHasAttr(unsigned OpIdx,  Attribute::AttrKind A) const {
        -: 2096:    auto &BOI = getBundleOpInfoForOperand(OpIdx);
        -: 2097:    auto OBU = operandBundleFromBundleOpInfo(BOI);
        -: 2098:    return OBU.operandHasAttr(OpIdx - BOI.Begin, A);
        -: 2099:  }
        -: 2100:
        -: 2101:  /// Return true if \p Other has the same sequence of operand bundle
        -: 2102:  /// tags with the same number of operands on each one of them as this
        -: 2103:  /// OperandBundleUser.
        -: 2104:  bool hasIdenticalOperandBundleSchema(const CallBase &Other) const {
        -: 2105:    if (getNumOperandBundles() != Other.getNumOperandBundles())
        -: 2106:      return false;
        -: 2107:
        -: 2108:    return std::equal(bundle_op_info_begin(), bundle_op_info_end(),
        -: 2109:                      Other.bundle_op_info_begin());
        -: 2110:  }
        -: 2111:
        -: 2112:  /// Return true if this operand bundle user contains operand bundles
        -: 2113:  /// with tags other than those specified in \p IDs.
        -: 2114:  bool hasOperandBundlesOtherThan(ArrayRef<uint32_t> IDs) const {
        -: 2115:    for (unsigned i = 0, e = getNumOperandBundles(); i != e; ++i) {
        -: 2116:      uint32_t ID = getOperandBundleAt(i).getTagID();
        -: 2117:      if (!is_contained(IDs, ID))
        -: 2118:        return true;
        -: 2119:    }
        -: 2120:    return false;
        -: 2121:  }
        -: 2122:
        -: 2123:  /// Is the function attribute S disallowed by some operand bundle on
        -: 2124:  /// this operand bundle user?
        -: 2125:  bool isFnAttrDisallowedByOpBundle(StringRef S) const {
        -: 2126:    // Operand bundles only possibly disallow memory access attributes.  All
        -: 2127:    // String attributes are fine.
        -: 2128:    return false;
        -: 2129:  }
        -: 2130:
        -: 2131:  /// Is the function attribute A disallowed by some operand bundle on
        -: 2132:  /// this operand bundle user?
        -: 2133:  bool isFnAttrDisallowedByOpBundle(Attribute::AttrKind A) const {
        -: 2134:    switch (A) {
        -: 2135:    default:
        -: 2136:      return false;
        -: 2137:
        -: 2138:    case Attribute::InaccessibleMemOrArgMemOnly:
        -: 2139:      return hasReadingOperandBundles();
        -: 2140:
        -: 2141:    case Attribute::InaccessibleMemOnly:
        -: 2142:      return hasReadingOperandBundles();
        -: 2143:
        -: 2144:    case Attribute::ArgMemOnly:
        -: 2145:      return hasReadingOperandBundles();
        -: 2146:
        -: 2147:    case Attribute::ReadNone:
        -: 2148:      return hasReadingOperandBundles();
        -: 2149:
        -: 2150:    case Attribute::ReadOnly:
        -: 2151:      return hasClobberingOperandBundles();
        -: 2152:
        -: 2153:    case Attribute::WriteOnly:
        -: 2154:      return hasReadingOperandBundles();
        -: 2155:    }
        -: 2156:
        -: 2157:    llvm_unreachable("switch has a default case!");
        -: 2158:  }
        -: 2159:
        -: 2160:  /// Used to keep track of an operand bundle.  See the main comment on
        -: 2161:  /// OperandBundleUser above.
        -: 2162:  struct BundleOpInfo {
        -: 2163:    /// The operand bundle tag, interned by
        -: 2164:    /// LLVMContextImpl::getOrInsertBundleTag.
        -: 2165:    StringMapEntry<uint32_t> *Tag;
        -: 2166:
        -: 2167:    /// The index in the Use& vector where operands for this operand
        -: 2168:    /// bundle starts.
        -: 2169:    uint32_t Begin;
        -: 2170:
        -: 2171:    /// The index in the Use& vector where operands for this operand
        -: 2172:    /// bundle ends.
        -: 2173:    uint32_t End;
        -: 2174:
        -: 2175:    bool operator==(const BundleOpInfo &Other) const {
        -: 2176:      return Tag == Other.Tag && Begin == Other.Begin && End == Other.End;
        -: 2177:    }
        -: 2178:  };
        -: 2179:
        -: 2180:  /// Simple helper function to map a BundleOpInfo to an
        -: 2181:  /// OperandBundleUse.
        -: 2182:  OperandBundleUse
        -: 2183:  operandBundleFromBundleOpInfo(const BundleOpInfo &BOI) const {
        -: 2184:    auto begin = op_begin();
        -: 2185:    ArrayRef<Use> Inputs(begin + BOI.Begin, begin + BOI.End);
        -: 2186:    return OperandBundleUse(BOI.Tag, Inputs);
        -: 2187:  }
        -: 2188:
        -: 2189:  using bundle_op_iterator = BundleOpInfo *;
        -: 2190:  using const_bundle_op_iterator = const BundleOpInfo *;
        -: 2191:
        -: 2192:  /// Return the start of the list of BundleOpInfo instances associated
        -: 2193:  /// with this OperandBundleUser.
        -: 2194:  ///
        -: 2195:  /// OperandBundleUser uses the descriptor area co-allocated with the host User
        -: 2196:  /// to store some meta information about which operands are "normal" operands,
        -: 2197:  /// and which ones belong to some operand bundle.
        -: 2198:  ///
        -: 2199:  /// The layout of an operand bundle user is
        -: 2200:  ///
        -: 2201:  ///          +-----------uint32_t End-------------------------------------+
        -: 2202:  ///          |                                                            |
        -: 2203:  ///          |  +--------uint32_t Begin--------------------+              |
        -: 2204:  ///          |  |                                          |              |
        -: 2205:  ///          ^  ^                                          v              v
        -: 2206:  ///  |------|------|----|----|----|----|----|---------|----|---------|----|-----
        -: 2207:  ///  | BOI0 | BOI1 | .. | DU | U0 | U1 | .. | BOI0_U0 | .. | BOI1_U0 | .. | Un
        -: 2208:  ///  |------|------|----|----|----|----|----|---------|----|---------|----|-----
        -: 2209:  ///   v  v                                  ^              ^
        -: 2210:  ///   |  |                                  |              |
        -: 2211:  ///   |  +--------uint32_t Begin------------+              |
        -: 2212:  ///   |                                                    |
        -: 2213:  ///   +-----------uint32_t End-----------------------------+
        -: 2214:  ///
        -: 2215:  ///
        -: 2216:  /// BOI0, BOI1 ... are descriptions of operand bundles in this User's use
        -: 2217:  /// list. These descriptions are installed and managed by this class, and
        -: 2218:  /// they're all instances of OperandBundleUser<T>::BundleOpInfo.
        -: 2219:  ///
        -: 2220:  /// DU is an additional descriptor installed by User's 'operator new' to keep
        -: 2221:  /// track of the 'BOI0 ... BOIN' co-allocation.  OperandBundleUser does not
        -: 2222:  /// access or modify DU in any way, it's an implementation detail private to
        -: 2223:  /// User.
        -: 2224:  ///
        -: 2225:  /// The regular Use& vector for the User starts at U0.  The operand bundle
        -: 2226:  /// uses are part of the Use& vector, just like normal uses.  In the diagram
        -: 2227:  /// above, the operand bundle uses start at BOI0_U0.  Each instance of
        -: 2228:  /// BundleOpInfo has information about a contiguous set of uses constituting
        -: 2229:  /// an operand bundle, and the total set of operand bundle uses themselves
        -: 2230:  /// form a contiguous set of uses (i.e. there are no gaps between uses
        -: 2231:  /// corresponding to individual operand bundles).
        -: 2232:  ///
        -: 2233:  /// This class does not know the location of the set of operand bundle uses
        -: 2234:  /// within the use list -- that is decided by the User using this class via
        -: 2235:  /// the BeginIdx argument in populateBundleOperandInfos.
        -: 2236:  ///
        -: 2237:  /// Currently operand bundle users with hung-off operands are not supported.
        -: 2238:  bundle_op_iterator bundle_op_info_begin() {
        -: 2239:    if (!hasDescriptor())
        -: 2240:      return nullptr;
        -: 2241:
        -: 2242:    uint8_t *BytesBegin = getDescriptor().begin();
        -: 2243:    return reinterpret_cast<bundle_op_iterator>(BytesBegin);
        -: 2244:  }
        -: 2245:
        -: 2246:  /// Return the start of the list of BundleOpInfo instances associated
        -: 2247:  /// with this OperandBundleUser.
        -: 2248:  const_bundle_op_iterator bundle_op_info_begin() const {
        -: 2249:    auto *NonConstThis = const_cast<CallBase *>(this);
        -: 2250:    return NonConstThis->bundle_op_info_begin();
        -: 2251:  }
        -: 2252:
        -: 2253:  /// Return the end of the list of BundleOpInfo instances associated
        -: 2254:  /// with this OperandBundleUser.
        -: 2255:  bundle_op_iterator bundle_op_info_end() {
        -: 2256:    if (!hasDescriptor())
        -: 2257:      return nullptr;
        -: 2258:
        -: 2259:    uint8_t *BytesEnd = getDescriptor().end();
        -: 2260:    return reinterpret_cast<bundle_op_iterator>(BytesEnd);
        -: 2261:  }
        -: 2262:
        -: 2263:  /// Return the end of the list of BundleOpInfo instances associated
        -: 2264:  /// with this OperandBundleUser.
        -: 2265:  const_bundle_op_iterator bundle_op_info_end() const {
        -: 2266:    auto *NonConstThis = const_cast<CallBase *>(this);
        -: 2267:    return NonConstThis->bundle_op_info_end();
        -: 2268:  }
        -: 2269:
        -: 2270:  /// Return the range [\p bundle_op_info_begin, \p bundle_op_info_end).
        -: 2271:  iterator_range<bundle_op_iterator> bundle_op_infos() {
        -: 2272:    return make_range(bundle_op_info_begin(), bundle_op_info_end());
        -: 2273:  }
        -: 2274:
        -: 2275:  /// Return the range [\p bundle_op_info_begin, \p bundle_op_info_end).
        -: 2276:  iterator_range<const_bundle_op_iterator> bundle_op_infos() const {
        -: 2277:    return make_range(bundle_op_info_begin(), bundle_op_info_end());
        -: 2278:  }
        -: 2279:
        -: 2280:  /// Populate the BundleOpInfo instances and the Use& vector from \p
        -: 2281:  /// Bundles.  Return the op_iterator pointing to the Use& one past the last
        -: 2282:  /// last bundle operand use.
        -: 2283:  ///
        -: 2284:  /// Each \p OperandBundleDef instance is tracked by a OperandBundleInfo
        -: 2285:  /// instance allocated in this User's descriptor.
        -: 2286:  op_iterator populateBundleOperandInfos(ArrayRef<OperandBundleDef> Bundles,
        -: 2287:                                         const unsigned BeginIndex);
        -: 2288:
        -: 2289:public:
        -: 2290:  /// Return the BundleOpInfo for the operand at index OpIdx.
        -: 2291:  ///
        -: 2292:  /// It is an error to call this with an OpIdx that does not correspond to an
        -: 2293:  /// bundle operand.
        -: 2294:  BundleOpInfo &getBundleOpInfoForOperand(unsigned OpIdx);
        -: 2295:  const BundleOpInfo &getBundleOpInfoForOperand(unsigned OpIdx) const {
        -: 2296:    return const_cast<CallBase *>(this)->getBundleOpInfoForOperand(OpIdx);
        -: 2297:  }
        -: 2298:
        -: 2299:protected:
        -: 2300:  /// Return the total number of values used in \p Bundles.
        -: 2301:  static unsigned CountBundleInputs(ArrayRef<OperandBundleDef> Bundles) {
        -: 2302:    unsigned Total = 0;
        -: 2303:    for (auto &B : Bundles)
        -: 2304:      Total += B.input_size();
        -: 2305:    return Total;
        -: 2306:  }
        -: 2307:
        -: 2308:  /// @}
        -: 2309:  // End of operand bundle API.
        -: 2310:
        -: 2311:private:
        -: 2312:  bool hasFnAttrOnCalledFunction(Attribute::AttrKind Kind) const;
        -: 2313:  bool hasFnAttrOnCalledFunction(StringRef Kind) const;
        -: 2314:
        -: 2315:  template <typename AttrKind> bool hasFnAttrImpl(AttrKind Kind) const {
        -: 2316:    if (Attrs.hasFnAttr(Kind))
        -: 2317:      return true;
        -: 2318:
        -: 2319:    // Operand bundles override attributes on the called function, but don't
        -: 2320:    // override attributes directly present on the call instruction.
        -: 2321:    if (isFnAttrDisallowedByOpBundle(Kind))
        -: 2322:      return false;
        -: 2323:
        -: 2324:    return hasFnAttrOnCalledFunction(Kind);
        -: 2325:  }
        -: 2326:  template <typename AK> Attribute getFnAttrOnCalledFunction(AK Kind) const;
        -: 2327:
        -: 2328:  /// A specialized version of hasFnAttrImpl for when the caller wants to
        -: 2329:  /// know if an attribute's semantics are implied, not whether the attribute
        -: 2330:  /// is actually present.  This distinction only exists when checking whether
        -: 2331:  /// something is readonly or writeonly since readnone implies both.  The case
        -: 2332:  /// which motivates the specialized code is a callee with readnone, and an
        -: 2333:  /// operand bundle on the call which disallows readnone but not either
        -: 2334:  /// readonly or writeonly.
        -: 2335:  bool hasImpliedFnAttr(Attribute::AttrKind Kind) const {
        -: 2336:    assert((Kind == Attribute::ReadOnly || Kind == Attribute::WriteOnly) &&
        -: 2337:           "use hasFnAttrImpl instead");
        -: 2338:    if (Attrs.hasFnAttr(Kind) || Attrs.hasFnAttr(Attribute::ReadNone))
        -: 2339:      return true;
        -: 2340:
        -: 2341:    if (isFnAttrDisallowedByOpBundle(Kind))
        -: 2342:      return false;
        -: 2343:
        -: 2344:    return hasFnAttrOnCalledFunction(Kind) ||
        -: 2345:      hasFnAttrOnCalledFunction(Attribute::ReadNone);
        -: 2346:  }
        -: 2347:
        -: 2348:  /// Determine whether the return value has the given attribute. Supports
        -: 2349:  /// Attribute::AttrKind and StringRef as \p AttrKind types.
        -: 2350:  template <typename AttrKind> bool hasRetAttrImpl(AttrKind Kind) const {
        -: 2351:    if (Attrs.hasRetAttr(Kind))
        -: 2352:      return true;
        -: 2353:
        -: 2354:    // Look at the callee, if available.
        -: 2355:    if (const Function *F = getCalledFunction())
        -: 2356:      return F->getAttributes().hasRetAttr(Kind);
        -: 2357:    return false;
        -: 2358:  }
        -: 2359:};
        -: 2360:
        -: 2361:template <>
        -: 2362:struct OperandTraits<CallBase> : public VariadicOperandTraits<CallBase, 1> {};
        -: 2363:
        -: 2364:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(CallBase, Value)
        -: 2365:
        -: 2366://===----------------------------------------------------------------------===//
        -: 2367://                           FuncletPadInst Class
        -: 2368://===----------------------------------------------------------------------===//
        -: 2369:class FuncletPadInst : public Instruction {
        -: 2370:private:
        -: 2371:  FuncletPadInst(const FuncletPadInst &CPI);
        -: 2372:
        -: 2373:  explicit FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,
        -: 2374:                          ArrayRef<Value *> Args, unsigned Values,
        -: 2375:                          const Twine &NameStr, Instruction *InsertBefore);
        -: 2376:  explicit FuncletPadInst(Instruction::FuncletPadOps Op, Value *ParentPad,
        -: 2377:                          ArrayRef<Value *> Args, unsigned Values,
        -: 2378:                          const Twine &NameStr, BasicBlock *InsertAtEnd);
        -: 2379:
        -: 2380:  void init(Value *ParentPad, ArrayRef<Value *> Args, const Twine &NameStr);
        -: 2381:
        -: 2382:protected:
        -: 2383:  // Note: Instruction needs to be a friend here to call cloneImpl.
        -: 2384:  friend class Instruction;
        -: 2385:  friend class CatchPadInst;
        -: 2386:  friend class CleanupPadInst;
        -: 2387:
        -: 2388:  FuncletPadInst *cloneImpl() const;
        -: 2389:
        -: 2390:public:
        -: 2391:  /// Provide fast operand accessors
        -: 2392:  DECLARE_TRANSPARENT_OPERAND_ACCESSORS(Value);
        -: 2393:
        -: 2394:  /// getNumArgOperands - Return the number of funcletpad arguments.
        -: 2395:  ///
        -: 2396:  unsigned getNumArgOperands() const { return getNumOperands() - 1; }
        -: 2397:
        -: 2398:  /// Convenience accessors
        -: 2399:
        -: 2400:  /// Return the outer EH-pad this funclet is nested within.
        -: 2401:  ///
        -: 2402:  /// Note: This returns the associated CatchSwitchInst if this FuncletPadInst
        -: 2403:  /// is a CatchPadInst.
        -: 2404:  Value *getParentPad() const { return Op<-1>(); }
        -: 2405:  void setParentPad(Value *ParentPad) {
        -: 2406:    assert(ParentPad);
        -: 2407:    Op<-1>() = ParentPad;
        -: 2408:  }
        -: 2409:
        -: 2410:  /// getArgOperand/setArgOperand - Return/set the i-th funcletpad argument.
        -: 2411:  ///
        -: 2412:  Value *getArgOperand(unsigned i) const { return getOperand(i); }
        -: 2413:  void setArgOperand(unsigned i, Value *v) { setOperand(i, v); }
        -: 2414:
        -: 2415:  /// arg_operands - iteration adapter for range-for loops.
        -: 2416:  op_range arg_operands() { return op_range(op_begin(), op_end() - 1); }
        -: 2417:
        -: 2418:  /// arg_operands - iteration adapter for range-for loops.
        -: 2419:  const_op_range arg_operands() const {
        -: 2420:    return const_op_range(op_begin(), op_end() - 1);
        -: 2421:  }
        -: 2422:
        -: 2423:  // Methods for support type inquiry through isa, cast, and dyn_cast:
        -: 2424:  static bool classof(const Instruction *I) { return I->isFuncletPad(); }
        -: 2425:  static bool classof(const Value *V) {
        -: 2426:    return isa<Instruction>(V) && classof(cast<Instruction>(V));
        -: 2427:  }
        -: 2428:};
        -: 2429:
        -: 2430:template <>
        -: 2431:struct OperandTraits<FuncletPadInst>
        -: 2432:    : public VariadicOperandTraits<FuncletPadInst, /*MINARITY=*/1> {};
        -: 2433:
        -: 2434:DEFINE_TRANSPARENT_OPERAND_ACCESSORS(FuncletPadInst, Value)
        -: 2435:
        -: 2436:} // end namespace llvm
        -: 2437:
        -: 2438:#endif // LLVM_IR_INSTRTYPES_H
