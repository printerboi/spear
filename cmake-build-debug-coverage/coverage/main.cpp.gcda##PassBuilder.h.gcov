        -:    0:Source:/usr/include/llvm/Passes/PassBuilder.h
        -:    0:Graph:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/main.cpp.gcno
        -:    0:Data:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    1://===- Parsing, selection, and construction of pass pipelines --*- C++ -*--===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8:/// \file
        -:    9:///
        -:   10:/// Interfaces for registering analysis passes, producing common pass manager
        -:   11:/// configurations, and parsing of pass pipelines.
        -:   12:///
        -:   13://===----------------------------------------------------------------------===//
        -:   14:
        -:   15:#ifndef LLVM_PASSES_PASSBUILDER_H
        -:   16:#define LLVM_PASSES_PASSBUILDER_H
        -:   17:
        -:   18:#include "llvm/ADT/Optional.h"
        -:   19:#include "llvm/Analysis/CGSCCPassManager.h"
        -:   20:#include "llvm/IR/PassManager.h"
        -:   21:#include "llvm/Passes/OptimizationLevel.h"
        -:   22:#include "llvm/Support/Error.h"
        -:   23:#include "llvm/Support/PGOOptions.h"
        -:   24:#include "llvm/Support/raw_ostream.h"
        -:   25:#include "llvm/Transforms/IPO/Inliner.h"
        -:   26:#include "llvm/Transforms/IPO/ModuleInliner.h"
        -:   27:#include "llvm/Transforms/Instrumentation.h"
        -:   28:#include "llvm/Transforms/Scalar/LoopPassManager.h"
        -:   29:#include <vector>
        -:   30:
        -:   31:namespace llvm {
        -:   32:class StringRef;
        -:   33:class AAManager;
        -:   34:class TargetMachine;
        -:   35:class ModuleSummaryIndex;
        -:   36:
        -:   37:/// Tunable parameters for passes in the default pipelines.
        -:   38:class PipelineTuningOptions {
        -:   39:public:
        -:   40:  /// Constructor sets pipeline tuning defaults based on cl::opts. Each option
        -:   41:  /// can be set in the PassBuilder when using a LLVM as a library.
        -:   42:  PipelineTuningOptions();
        -:   43:
        -:   44:  /// Tuning option to set loop interleaving on/off, set based on opt level.
        -:   45:  bool LoopInterleaving;
        -:   46:
        -:   47:  /// Tuning option to enable/disable loop vectorization, set based on opt
        -:   48:  /// level.
        -:   49:  bool LoopVectorization;
        -:   50:
        -:   51:  /// Tuning option to enable/disable slp loop vectorization, set based on opt
        -:   52:  /// level.
        -:   53:  bool SLPVectorization;
        -:   54:
        -:   55:  /// Tuning option to enable/disable loop unrolling. Its default value is true.
        -:   56:  bool LoopUnrolling;
        -:   57:
        -:   58:  /// Tuning option to forget all SCEV loops in LoopUnroll. Its default value
        -:   59:  /// is that of the flag: `-forget-scev-loop-unroll`.
        -:   60:  bool ForgetAllSCEVInLoopUnroll;
        -:   61:
        -:   62:  /// Tuning option to cap the number of calls to retrive clobbering accesses in
        -:   63:  /// MemorySSA, in LICM.
        -:   64:  unsigned LicmMssaOptCap;
        -:   65:
        -:   66:  /// Tuning option to disable promotion to scalars in LICM with MemorySSA, if
        -:   67:  /// the number of access is too large.
        -:   68:  unsigned LicmMssaNoAccForPromotionCap;
        -:   69:
        -:   70:  /// Tuning option to enable/disable call graph profile. Its default value is
        -:   71:  /// that of the flag: `-enable-npm-call-graph-profile`.
        -:   72:  bool CallGraphProfile;
        -:   73:
        -:   74:  /// Tuning option to enable/disable function merging. Its default value is
        -:   75:  /// false.
        -:   76:  bool MergeFunctions;
        -:   77:
        -:   78:  // Experimental option to eagerly invalidate more analyses. This has the
        -:   79:  // potential to decrease max memory usage in exchange for more compile time.
        -:   80:  // This may affect codegen due to either passes using analyses only when
        -:   81:  // cached, or invalidating and recalculating an analysis that was
        -:   82:  // stale/imprecise but still valid. Currently this invalidates all function
        -:   83:  // analyses after various module->function or cgscc->function adaptors in the
        -:   84:  // default pipelines.
        -:   85:  bool EagerlyInvalidateAnalyses;
        -:   86:};
        -:   87:
        -:   88:/// This class provides access to building LLVM's passes.
        -:   89:///
        -:   90:/// Its members provide the baseline state available to passes during their
        -:   91:/// construction. The \c PassRegistry.def file specifies how to construct all
        -:   92:/// of the built-in passes, and those may reference these members during
        -:   93:/// construction.
        -:   94:class PassBuilder {
        -:   95:  TargetMachine *TM;
        -:   96:  PipelineTuningOptions PTO;
        -:   97:  Optional<PGOOptions> PGOOpt;
        -:   98:  PassInstrumentationCallbacks *PIC;
        -:   99:
        -:  100:public:
        -:  101:  /// A struct to capture parsed pass pipeline names.
        -:  102:  ///
        -:  103:  /// A pipeline is defined as a series of names, each of which may in itself
        -:  104:  /// recursively contain a nested pipeline. A name is either the name of a pass
        -:  105:  /// (e.g. "instcombine") or the name of a pipeline type (e.g. "cgscc"). If the
        -:  106:  /// name is the name of a pass, the InnerPipeline is empty, since passes
        -:  107:  /// cannot contain inner pipelines. See parsePassPipeline() for a more
        -:  108:  /// detailed description of the textual pipeline format.
        -:  109:  struct PipelineElement {
        -:  110:    StringRef Name;
        -:  111:    std::vector<PipelineElement> InnerPipeline;
        -:  112:  };
        -:  113:
        -:  114:  explicit PassBuilder(TargetMachine *TM = nullptr,
        -:  115:                       PipelineTuningOptions PTO = PipelineTuningOptions(),
        -:  116:                       Optional<PGOOptions> PGOOpt = None,
        -:  117:                       PassInstrumentationCallbacks *PIC = nullptr);
        -:  118:
        -:  119:  /// Cross register the analysis managers through their proxies.
        -:  120:  ///
        -:  121:  /// This is an interface that can be used to cross register each
        -:  122:  /// AnalysisManager with all the others analysis managers.
        -:  123:  void crossRegisterProxies(LoopAnalysisManager &LAM,
        -:  124:                            FunctionAnalysisManager &FAM,
        -:  125:                            CGSCCAnalysisManager &CGAM,
        -:  126:                            ModuleAnalysisManager &MAM);
        -:  127:
        -:  128:  /// Registers all available module analysis passes.
        -:  129:  ///
        -:  130:  /// This is an interface that can be used to populate a \c
        -:  131:  /// ModuleAnalysisManager with all registered module analyses. Callers can
        -:  132:  /// still manually register any additional analyses. Callers can also
        -:  133:  /// pre-register analyses and this will not override those.
        -:  134:  void registerModuleAnalyses(ModuleAnalysisManager &MAM);
        -:  135:
        -:  136:  /// Registers all available CGSCC analysis passes.
        -:  137:  ///
        -:  138:  /// This is an interface that can be used to populate a \c CGSCCAnalysisManager
        -:  139:  /// with all registered CGSCC analyses. Callers can still manually register any
        -:  140:  /// additional analyses. Callers can also pre-register analyses and this will
        -:  141:  /// not override those.
        -:  142:  void registerCGSCCAnalyses(CGSCCAnalysisManager &CGAM);
        -:  143:
        -:  144:  /// Registers all available function analysis passes.
        -:  145:  ///
        -:  146:  /// This is an interface that can be used to populate a \c
        -:  147:  /// FunctionAnalysisManager with all registered function analyses. Callers can
        -:  148:  /// still manually register any additional analyses. Callers can also
        -:  149:  /// pre-register analyses and this will not override those.
        -:  150:  void registerFunctionAnalyses(FunctionAnalysisManager &FAM);
        -:  151:
        -:  152:  /// Registers all available loop analysis passes.
        -:  153:  ///
        -:  154:  /// This is an interface that can be used to populate a \c LoopAnalysisManager
        -:  155:  /// with all registered loop analyses. Callers can still manually register any
        -:  156:  /// additional analyses.
        -:  157:  void registerLoopAnalyses(LoopAnalysisManager &LAM);
        -:  158:
        -:  159:  /// Construct the core LLVM function canonicalization and simplification
        -:  160:  /// pipeline.
        -:  161:  ///
        -:  162:  /// This is a long pipeline and uses most of the per-function optimization
        -:  163:  /// passes in LLVM to canonicalize and simplify the IR. It is suitable to run
        -:  164:  /// repeatedly over the IR and is not expected to destroy important
        -:  165:  /// information about the semantics of the IR.
        -:  166:  ///
        -:  167:  /// Note that \p Level cannot be `O0` here. The pipelines produced are
        -:  168:  /// only intended for use when attempting to optimize code. If frontends
        -:  169:  /// require some transformations for semantic reasons, they should explicitly
        -:  170:  /// build them.
        -:  171:  ///
        -:  172:  /// \p Phase indicates the current ThinLTO phase.
        -:  173:  FunctionPassManager
        -:  174:  buildFunctionSimplificationPipeline(OptimizationLevel Level,
        -:  175:                                      ThinOrFullLTOPhase Phase);
        -:  176:
        -:  177:  /// Construct the core LLVM module canonicalization and simplification
        -:  178:  /// pipeline.
        -:  179:  ///
        -:  180:  /// This pipeline focuses on canonicalizing and simplifying the entire module
        -:  181:  /// of IR. Much like the function simplification pipeline above, it is
        -:  182:  /// suitable to run repeatedly over the IR and is not expected to destroy
        -:  183:  /// important information. It does, however, perform inlining and other
        -:  184:  /// heuristic based simplifications that are not strictly reversible.
        -:  185:  ///
        -:  186:  /// Note that \p Level cannot be `O0` here. The pipelines produced are
        -:  187:  /// only intended for use when attempting to optimize code. If frontends
        -:  188:  /// require some transformations for semantic reasons, they should explicitly
        -:  189:  /// build them.
        -:  190:  ///
        -:  191:  /// \p Phase indicates the current ThinLTO phase.
        -:  192:  ModulePassManager buildModuleSimplificationPipeline(OptimizationLevel Level,
        -:  193:                                                      ThinOrFullLTOPhase Phase);
        -:  194:
        -:  195:  /// Construct the module pipeline that performs inlining as well as
        -:  196:  /// the inlining-driven cleanups.
        -:  197:  ModuleInlinerWrapperPass buildInlinerPipeline(OptimizationLevel Level,
        -:  198:                                                ThinOrFullLTOPhase Phase);
        -:  199:
        -:  200:  /// Construct the module pipeline that performs inlining with
        -:  201:  /// module inliner pass.
        -:  202:  ModulePassManager buildModuleInlinerPipeline(OptimizationLevel Level,
        -:  203:                                               ThinOrFullLTOPhase Phase);
        -:  204:
        -:  205:  /// Construct the core LLVM module optimization pipeline.
        -:  206:  ///
        -:  207:  /// This pipeline focuses on optimizing the execution speed of the IR. It
        -:  208:  /// uses cost modeling and thresholds to balance code growth against runtime
        -:  209:  /// improvements. It includes vectorization and other information destroying
        -:  210:  /// transformations. It also cannot generally be run repeatedly on a module
        -:  211:  /// without potentially seriously regressing either runtime performance of
        -:  212:  /// the code or serious code size growth.
        -:  213:  ///
        -:  214:  /// Note that \p Level cannot be `O0` here. The pipelines produced are
        -:  215:  /// only intended for use when attempting to optimize code. If frontends
        -:  216:  /// require some transformations for semantic reasons, they should explicitly
        -:  217:  /// build them.
        -:  218:  ModulePassManager
        -:  219:  buildModuleOptimizationPipeline(OptimizationLevel Level,
        -:  220:                                  ThinOrFullLTOPhase LTOPhase);
        -:  221:
        -:  222:  /// Build a per-module default optimization pipeline.
        -:  223:  ///
        -:  224:  /// This provides a good default optimization pipeline for per-module
        -:  225:  /// optimization and code generation without any link-time optimization. It
        -:  226:  /// typically correspond to frontend "-O[123]" options for optimization
        -:  227:  /// levels \c O1, \c O2 and \c O3 resp.
        -:  228:  ///
        -:  229:  /// Note that \p Level cannot be `O0` here. The pipelines produced are
        -:  230:  /// only intended for use when attempting to optimize code. If frontends
        -:  231:  /// require some transformations for semantic reasons, they should explicitly
        -:  232:  /// build them.
        -:  233:  ModulePassManager buildPerModuleDefaultPipeline(OptimizationLevel Level,
        -:  234:                                                  bool LTOPreLink = false);
        -:  235:
        -:  236:  /// Build a pre-link, ThinLTO-targeting default optimization pipeline to
        -:  237:  /// a pass manager.
        -:  238:  ///
        -:  239:  /// This adds the pre-link optimizations tuned to prepare a module for
        -:  240:  /// a ThinLTO run. It works to minimize the IR which needs to be analyzed
        -:  241:  /// without making irreversible decisions which could be made better during
        -:  242:  /// the LTO run.
        -:  243:  ///
        -:  244:  /// Note that \p Level cannot be `O0` here. The pipelines produced are
        -:  245:  /// only intended for use when attempting to optimize code. If frontends
        -:  246:  /// require some transformations for semantic reasons, they should explicitly
        -:  247:  /// build them.
        -:  248:  ModulePassManager buildThinLTOPreLinkDefaultPipeline(OptimizationLevel Level);
        -:  249:
        -:  250:  /// Build an ThinLTO default optimization pipeline to a pass manager.
        -:  251:  ///
        -:  252:  /// This provides a good default optimization pipeline for link-time
        -:  253:  /// optimization and code generation. It is particularly tuned to fit well
        -:  254:  /// when IR coming into the LTO phase was first run through \c
        -:  255:  /// addPreLinkLTODefaultPipeline, and the two coordinate closely.
        -:  256:  ///
        -:  257:  /// Note that \p Level cannot be `O0` here. The pipelines produced are
        -:  258:  /// only intended for use when attempting to optimize code. If frontends
        -:  259:  /// require some transformations for semantic reasons, they should explicitly
        -:  260:  /// build them.
        -:  261:  ModulePassManager
        -:  262:  buildThinLTODefaultPipeline(OptimizationLevel Level,
        -:  263:                              const ModuleSummaryIndex *ImportSummary);
        -:  264:
        -:  265:  /// Build a pre-link, LTO-targeting default optimization pipeline to a pass
        -:  266:  /// manager.
        -:  267:  ///
        -:  268:  /// This adds the pre-link optimizations tuned to work well with a later LTO
        -:  269:  /// run. It works to minimize the IR which needs to be analyzed without
        -:  270:  /// making irreversible decisions which could be made better during the LTO
        -:  271:  /// run.
        -:  272:  ///
        -:  273:  /// Note that \p Level cannot be `O0` here. The pipelines produced are
        -:  274:  /// only intended for use when attempting to optimize code. If frontends
        -:  275:  /// require some transformations for semantic reasons, they should explicitly
        -:  276:  /// build them.
        -:  277:  ModulePassManager buildLTOPreLinkDefaultPipeline(OptimizationLevel Level);
        -:  278:
        -:  279:  /// Build an LTO default optimization pipeline to a pass manager.
        -:  280:  ///
        -:  281:  /// This provides a good default optimization pipeline for link-time
        -:  282:  /// optimization and code generation. It is particularly tuned to fit well
        -:  283:  /// when IR coming into the LTO phase was first run through \c
        -:  284:  /// addPreLinkLTODefaultPipeline, and the two coordinate closely.
        -:  285:  ///
        -:  286:  /// Note that \p Level cannot be `O0` here. The pipelines produced are
        -:  287:  /// only intended for use when attempting to optimize code. If frontends
        -:  288:  /// require some transformations for semantic reasons, they should explicitly
        -:  289:  /// build them.
        -:  290:  ModulePassManager buildLTODefaultPipeline(OptimizationLevel Level,
        -:  291:                                            ModuleSummaryIndex *ExportSummary);
        -:  292:
        -:  293:  /// Build an O0 pipeline with the minimal semantically required passes.
        -:  294:  ///
        -:  295:  /// This should only be used for non-LTO and LTO pre-link pipelines.
        -:  296:  ModulePassManager buildO0DefaultPipeline(OptimizationLevel Level,
        -:  297:                                           bool LTOPreLink = false);
        -:  298:
        -:  299:  /// Build the default `AAManager` with the default alias analysis pipeline
        -:  300:  /// registered.
        -:  301:  ///
        -:  302:  /// This also adds target-specific alias analyses registered via
        -:  303:  /// TargetMachine::registerDefaultAliasAnalyses().
        -:  304:  AAManager buildDefaultAAPipeline();
        -:  305:
        -:  306:  /// Parse a textual pass pipeline description into a \c
        -:  307:  /// ModulePassManager.
        -:  308:  ///
        -:  309:  /// The format of the textual pass pipeline description looks something like:
        -:  310:  ///
        -:  311:  ///   module(function(instcombine,sroa),dce,cgscc(inliner,function(...)),...)
        -:  312:  ///
        -:  313:  /// Pass managers have ()s describing the nest structure of passes. All passes
        -:  314:  /// are comma separated. As a special shortcut, if the very first pass is not
        -:  315:  /// a module pass (as a module pass manager is), this will automatically form
        -:  316:  /// the shortest stack of pass managers that allow inserting that first pass.
        -:  317:  /// So, assuming function passes 'fpassN', CGSCC passes 'cgpassN', and loop
        -:  318:  /// passes 'lpassN', all of these are valid:
        -:  319:  ///
        -:  320:  ///   fpass1,fpass2,fpass3
        -:  321:  ///   cgpass1,cgpass2,cgpass3
        -:  322:  ///   lpass1,lpass2,lpass3
        -:  323:  ///
        -:  324:  /// And they are equivalent to the following (resp.):
        -:  325:  ///
        -:  326:  ///   module(function(fpass1,fpass2,fpass3))
        -:  327:  ///   module(cgscc(cgpass1,cgpass2,cgpass3))
        -:  328:  ///   module(function(loop(lpass1,lpass2,lpass3)))
        -:  329:  ///
        -:  330:  /// This shortcut is especially useful for debugging and testing small pass
        -:  331:  /// combinations.
        -:  332:  ///
        -:  333:  /// The sequence of passes aren't necessarily the exact same kind of pass.
        -:  334:  /// You can mix different levels implicitly if adaptor passes are defined to
        -:  335:  /// make them work. For example,
        -:  336:  ///
        -:  337:  ///   mpass1,fpass1,fpass2,mpass2,lpass1
        -:  338:  ///
        -:  339:  /// This pipeline uses only one pass manager: the top-level module manager.
        -:  340:  /// fpass1,fpass2 and lpass1 are added into the the top-level module manager
        -:  341:  /// using only adaptor passes. No nested function/loop pass managers are
        -:  342:  /// added. The purpose is to allow easy pass testing when the user
        -:  343:  /// specifically want the pass to run under a adaptor directly. This is
        -:  344:  /// preferred when a pipeline is largely of one type, but one or just a few
        -:  345:  /// passes are of different types(See PassBuilder.cpp for examples).
        -:  346:  Error parsePassPipeline(ModulePassManager &MPM, StringRef PipelineText);
        -:  347:
        -:  348:  /// {{@ Parse a textual pass pipeline description into a specific PassManager
        -:  349:  ///
        -:  350:  /// Automatic deduction of an appropriate pass manager stack is not supported.
        -:  351:  /// For example, to insert a loop pass 'lpass' into a FunctionPassManager,
        -:  352:  /// this is the valid pipeline text:
        -:  353:  ///
        -:  354:  ///   function(lpass)
        -:  355:  Error parsePassPipeline(CGSCCPassManager &CGPM, StringRef PipelineText);
        -:  356:  Error parsePassPipeline(FunctionPassManager &FPM, StringRef PipelineText);
        -:  357:  Error parsePassPipeline(LoopPassManager &LPM, StringRef PipelineText);
        -:  358:  /// @}}
        -:  359:
        -:  360:  /// Parse a textual alias analysis pipeline into the provided AA manager.
        -:  361:  ///
        -:  362:  /// The format of the textual AA pipeline is a comma separated list of AA
        -:  363:  /// pass names:
        -:  364:  ///
        -:  365:  ///   basic-aa,globals-aa,...
        -:  366:  ///
        -:  367:  /// The AA manager is set up such that the provided alias analyses are tried
        -:  368:  /// in the order specified. See the \c AAManaager documentation for details
        -:  369:  /// about the logic used. This routine just provides the textual mapping
        -:  370:  /// between AA names and the analyses to register with the manager.
        -:  371:  ///
        -:  372:  /// Returns false if the text cannot be parsed cleanly. The specific state of
        -:  373:  /// the \p AA manager is unspecified if such an error is encountered and this
        -:  374:  /// returns false.
        -:  375:  Error parseAAPipeline(AAManager &AA, StringRef PipelineText);
        -:  376:
        -:  377:  /// Returns true if the pass name is the name of an alias analysis pass.
        -:  378:  bool isAAPassName(StringRef PassName);
        -:  379:
        -:  380:  /// Returns true if the pass name is the name of a (non-alias) analysis pass.
        -:  381:  bool isAnalysisPassName(StringRef PassName);
        -:  382:
        -:  383:  /// Print pass names.
        -:  384:  void printPassNames(raw_ostream &OS);
        -:  385:
        -:  386:  /// Register a callback for a default optimizer pipeline extension
        -:  387:  /// point
        -:  388:  ///
        -:  389:  /// This extension point allows adding passes that perform peephole
        -:  390:  /// optimizations similar to the instruction combiner. These passes will be
        -:  391:  /// inserted after each instance of the instruction combiner pass.
        -:  392:  void registerPeepholeEPCallback(
        -:  393:      const std::function<void(FunctionPassManager &, OptimizationLevel)> &C) {
        -:  394:    PeepholeEPCallbacks.push_back(C);
        -:  395:  }
        -:  396:
        -:  397:  /// Register a callback for a default optimizer pipeline extension
        -:  398:  /// point
        -:  399:  ///
        -:  400:  /// This extension point allows adding late loop canonicalization and
        -:  401:  /// simplification passes. This is the last point in the loop optimization
        -:  402:  /// pipeline before loop deletion. Each pass added
        -:  403:  /// here must be an instance of LoopPass.
        -:  404:  /// This is the place to add passes that can remove loops, such as target-
        -:  405:  /// specific loop idiom recognition.
        -:  406:  void registerLateLoopOptimizationsEPCallback(
        -:  407:      const std::function<void(LoopPassManager &, OptimizationLevel)> &C) {
        -:  408:    LateLoopOptimizationsEPCallbacks.push_back(C);
        -:  409:  }
        -:  410:
        -:  411:  /// Register a callback for a default optimizer pipeline extension
        -:  412:  /// point
        -:  413:  ///
        -:  414:  /// This extension point allows adding loop passes to the end of the loop
        -:  415:  /// optimizer.
        -:  416:  void registerLoopOptimizerEndEPCallback(
        -:  417:      const std::function<void(LoopPassManager &, OptimizationLevel)> &C) {
        -:  418:    LoopOptimizerEndEPCallbacks.push_back(C);
        -:  419:  }
        -:  420:
        -:  421:  /// Register a callback for a default optimizer pipeline extension
        -:  422:  /// point
        -:  423:  ///
        -:  424:  /// This extension point allows adding optimization passes after most of the
        -:  425:  /// main optimizations, but before the last cleanup-ish optimizations.
        -:  426:  void registerScalarOptimizerLateEPCallback(
        -:  427:      const std::function<void(FunctionPassManager &, OptimizationLevel)> &C) {
        -:  428:    ScalarOptimizerLateEPCallbacks.push_back(C);
        -:  429:  }
        -:  430:
        -:  431:  /// Register a callback for a default optimizer pipeline extension
        -:  432:  /// point
        -:  433:  ///
        -:  434:  /// This extension point allows adding CallGraphSCC passes at the end of the
        -:  435:  /// main CallGraphSCC passes and before any function simplification passes run
        -:  436:  /// by CGPassManager.
        -:  437:  void registerCGSCCOptimizerLateEPCallback(
        -:  438:      const std::function<void(CGSCCPassManager &, OptimizationLevel)> &C) {
        -:  439:    CGSCCOptimizerLateEPCallbacks.push_back(C);
        -:  440:  }
        -:  441:
        -:  442:  /// Register a callback for a default optimizer pipeline extension
        -:  443:  /// point
        -:  444:  ///
        -:  445:  /// This extension point allows adding optimization passes before the
        -:  446:  /// vectorizer and other highly target specific optimization passes are
        -:  447:  /// executed.
        -:  448:  void registerVectorizerStartEPCallback(
        -:  449:      const std::function<void(FunctionPassManager &, OptimizationLevel)> &C) {
        -:  450:    VectorizerStartEPCallbacks.push_back(C);
        -:  451:  }
        -:  452:
        -:  453:  /// Register a callback for a default optimizer pipeline extension point.
        -:  454:  ///
        -:  455:  /// This extension point allows adding optimization once at the start of the
        -:  456:  /// pipeline. This does not apply to 'backend' compiles (LTO and ThinLTO
        -:  457:  /// link-time pipelines).
        -:  458:  void registerPipelineStartEPCallback(
        -:  459:      const std::function<void(ModulePassManager &, OptimizationLevel)> &C) {
        -:  460:    PipelineStartEPCallbacks.push_back(C);
        -:  461:  }
        -:  462:
        -:  463:  /// Register a callback for a default optimizer pipeline extension point.
        -:  464:  ///
        -:  465:  /// This extension point allows adding optimization right after passes that do
        -:  466:  /// basic simplification of the input IR.
        -:  467:  void registerPipelineEarlySimplificationEPCallback(
        -:  468:      const std::function<void(ModulePassManager &, OptimizationLevel)> &C) {
        -:  469:    PipelineEarlySimplificationEPCallbacks.push_back(C);
        -:  470:  }
        -:  471:
        -:  472:  /// Register a callback for a default optimizer pipeline extension point
        -:  473:  ///
        -:  474:  /// This extension point allows adding optimizations before the function
        -:  475:  /// optimization pipeline.
        -:  476:  void registerOptimizerEarlyEPCallback(
        -:  477:      const std::function<void(ModulePassManager &, OptimizationLevel)> &C) {
        -:  478:    OptimizerEarlyEPCallbacks.push_back(C);
        -:  479:  }
        -:  480:
        -:  481:  /// Register a callback for a default optimizer pipeline extension point
        -:  482:  ///
        -:  483:  /// This extension point allows adding optimizations at the very end of the
        -:  484:  /// function optimization pipeline.
        -:  485:  void registerOptimizerLastEPCallback(
        -:  486:      const std::function<void(ModulePassManager &, OptimizationLevel)> &C) {
        -:  487:    OptimizerLastEPCallbacks.push_back(C);
        -:  488:  }
        -:  489:
        -:  490:  /// Register a callback for a default optimizer pipeline extension point
        -:  491:  ///
        -:  492:  /// This extension point allows adding optimizations at the start of the full
        -:  493:  /// LTO pipeline.
        -:  494:  void registerFullLinkTimeOptimizationEarlyEPCallback(
        -:  495:      const std::function<void(ModulePassManager &, OptimizationLevel)> &C) {
        -:  496:    FullLinkTimeOptimizationEarlyEPCallbacks.push_back(C);
        -:  497:  }
        -:  498:
        -:  499:  /// Register a callback for a default optimizer pipeline extension point
        -:  500:  ///
        -:  501:  /// This extension point allows adding optimizations at the end of the full
        -:  502:  /// LTO pipeline.
        -:  503:  void registerFullLinkTimeOptimizationLastEPCallback(
        -:  504:      const std::function<void(ModulePassManager &, OptimizationLevel)> &C) {
        -:  505:    FullLinkTimeOptimizationLastEPCallbacks.push_back(C);
        -:  506:  }
        -:  507:
        -:  508:  /// Register a callback for parsing an AliasAnalysis Name to populate
        -:  509:  /// the given AAManager \p AA
        -:  510:  void registerParseAACallback(
        -:  511:      const std::function<bool(StringRef Name, AAManager &AA)> &C) {
        -:  512:    AAParsingCallbacks.push_back(C);
        -:  513:  }
        -:  514:
        -:  515:  /// {{@ Register callbacks for analysis registration with this PassBuilder
        -:  516:  /// instance.
        -:  517:  /// Callees register their analyses with the given AnalysisManager objects.
        -:  518:  void registerAnalysisRegistrationCallback(
        -:  519:      const std::function<void(CGSCCAnalysisManager &)> &C) {
        -:  520:    CGSCCAnalysisRegistrationCallbacks.push_back(C);
        -:  521:  }
        -:  522:  void registerAnalysisRegistrationCallback(
        -:  523:      const std::function<void(FunctionAnalysisManager &)> &C) {
        -:  524:    FunctionAnalysisRegistrationCallbacks.push_back(C);
        -:  525:  }
        -:  526:  void registerAnalysisRegistrationCallback(
        -:  527:      const std::function<void(LoopAnalysisManager &)> &C) {
        -:  528:    LoopAnalysisRegistrationCallbacks.push_back(C);
        -:  529:  }
        -:  530:  void registerAnalysisRegistrationCallback(
        -:  531:      const std::function<void(ModuleAnalysisManager &)> &C) {
        -:  532:    ModuleAnalysisRegistrationCallbacks.push_back(C);
        -:  533:  }
        -:  534:  /// @}}
        -:  535:
        -:  536:  /// {{@ Register pipeline parsing callbacks with this pass builder instance.
        -:  537:  /// Using these callbacks, callers can parse both a single pass name, as well
        -:  538:  /// as entire sub-pipelines, and populate the PassManager instance
        -:  539:  /// accordingly.
        -:  540:  void registerPipelineParsingCallback(
        -:  541:      const std::function<bool(StringRef Name, CGSCCPassManager &,
        -:  542:                               ArrayRef<PipelineElement>)> &C) {
        -:  543:    CGSCCPipelineParsingCallbacks.push_back(C);
        -:  544:  }
function _ZN4llvm11PassBuilder31registerPipelineParsingCallbackERKSt8functionIFbNS_9StringRefERNS_11PassManagerINS_8FunctionENS_15AnalysisManagerIS4_JEEEJEEENS_8ArrayRefINS0_15PipelineElementEEEEE called 0 returned 0% blocks executed 0%
    #####:  545:  void registerPipelineParsingCallback(
        -:  546:      const std::function<bool(StringRef Name, FunctionPassManager &,
        -:  547:                               ArrayRef<PipelineElement>)> &C) {
    #####:  548:    FunctionPipelineParsingCallbacks.push_back(C);
    %%%%%:  548-block  0
Aufruf  0 niemals ausgeführt
    #####:  549:  }
        -:  550:  void registerPipelineParsingCallback(
        -:  551:      const std::function<bool(StringRef Name, LoopPassManager &,
        -:  552:                               ArrayRef<PipelineElement>)> &C) {
        -:  553:    LoopPipelineParsingCallbacks.push_back(C);
        -:  554:  }
        -:  555:  void registerPipelineParsingCallback(
        -:  556:      const std::function<bool(StringRef Name, ModulePassManager &,
        -:  557:                               ArrayRef<PipelineElement>)> &C) {
        -:  558:    ModulePipelineParsingCallbacks.push_back(C);
        -:  559:  }
        -:  560:  /// @}}
        -:  561:
        -:  562:  /// Register a callback for a top-level pipeline entry.
        -:  563:  ///
        -:  564:  /// If the PassManager type is not given at the top level of the pipeline
        -:  565:  /// text, this Callback should be used to determine the appropriate stack of
        -:  566:  /// PassManagers and populate the passed ModulePassManager.
        -:  567:  void registerParseTopLevelPipelineCallback(
        -:  568:      const std::function<bool(ModulePassManager &, ArrayRef<PipelineElement>)>
        -:  569:          &C);
        -:  570:
        -:  571:  /// Add PGOInstrumenation passes for O0 only.
        -:  572:  void addPGOInstrPassesForO0(ModulePassManager &MPM, bool RunProfileGen,
        -:  573:                              bool IsCS, std::string ProfileFile,
        -:  574:                              std::string ProfileRemappingFile);
        -:  575:
        -:  576:  /// Returns PIC. External libraries can use this to register pass
        -:  577:  /// instrumentation callbacks.
        -:  578:  PassInstrumentationCallbacks *getPassInstrumentationCallbacks() const {
        -:  579:    return PIC;
        -:  580:  }
        -:  581:
        -:  582:private:
        -:  583:  // O1 pass pipeline
        -:  584:  FunctionPassManager
        -:  585:  buildO1FunctionSimplificationPipeline(OptimizationLevel Level,
        -:  586:                                        ThinOrFullLTOPhase Phase);
        -:  587:
        -:  588:  void addRequiredLTOPreLinkPasses(ModulePassManager &MPM);
        -:  589:
        -:  590:  void addVectorPasses(OptimizationLevel Level, FunctionPassManager &FPM,
        -:  591:                       bool IsFullLTO);
        -:  592:
        -:  593:  static Optional<std::vector<PipelineElement>>
        -:  594:  parsePipelineText(StringRef Text);
        -:  595:
        -:  596:  Error parseModulePass(ModulePassManager &MPM, const PipelineElement &E);
        -:  597:  Error parseCGSCCPass(CGSCCPassManager &CGPM, const PipelineElement &E);
        -:  598:  Error parseFunctionPass(FunctionPassManager &FPM, const PipelineElement &E);
        -:  599:  Error parseLoopPass(LoopPassManager &LPM, const PipelineElement &E);
        -:  600:  bool parseAAPassName(AAManager &AA, StringRef Name);
        -:  601:
        -:  602:  Error parseLoopPassPipeline(LoopPassManager &LPM,
        -:  603:                              ArrayRef<PipelineElement> Pipeline);
        -:  604:  Error parseFunctionPassPipeline(FunctionPassManager &FPM,
        -:  605:                                  ArrayRef<PipelineElement> Pipeline);
        -:  606:  Error parseCGSCCPassPipeline(CGSCCPassManager &CGPM,
        -:  607:                               ArrayRef<PipelineElement> Pipeline);
        -:  608:  Error parseModulePassPipeline(ModulePassManager &MPM,
        -:  609:                                ArrayRef<PipelineElement> Pipeline);
        -:  610:
        -:  611:  void addPGOInstrPasses(ModulePassManager &MPM, OptimizationLevel Level,
        -:  612:                         bool RunProfileGen, bool IsCS, std::string ProfileFile,
        -:  613:                         std::string ProfileRemappingFile,
        -:  614:                         ThinOrFullLTOPhase LTOPhase);
        -:  615:  void invokePeepholeEPCallbacks(FunctionPassManager &, OptimizationLevel);
        -:  616:
        -:  617:  // Extension Point callbacks
        -:  618:  SmallVector<std::function<void(FunctionPassManager &, OptimizationLevel)>, 2>
        -:  619:      PeepholeEPCallbacks;
        -:  620:  SmallVector<std::function<void(LoopPassManager &, OptimizationLevel)>, 2>
        -:  621:      LateLoopOptimizationsEPCallbacks;
        -:  622:  SmallVector<std::function<void(LoopPassManager &, OptimizationLevel)>, 2>
        -:  623:      LoopOptimizerEndEPCallbacks;
        -:  624:  SmallVector<std::function<void(FunctionPassManager &, OptimizationLevel)>, 2>
        -:  625:      ScalarOptimizerLateEPCallbacks;
        -:  626:  SmallVector<std::function<void(CGSCCPassManager &, OptimizationLevel)>, 2>
        -:  627:      CGSCCOptimizerLateEPCallbacks;
        -:  628:  SmallVector<std::function<void(FunctionPassManager &, OptimizationLevel)>, 2>
        -:  629:      VectorizerStartEPCallbacks;
        -:  630:  // Module callbacks
        -:  631:  SmallVector<std::function<void(ModulePassManager &, OptimizationLevel)>, 2>
        -:  632:      OptimizerEarlyEPCallbacks;
        -:  633:  SmallVector<std::function<void(ModulePassManager &, OptimizationLevel)>, 2>
        -:  634:      OptimizerLastEPCallbacks;
        -:  635:  SmallVector<std::function<void(ModulePassManager &, OptimizationLevel)>, 2>
        -:  636:      FullLinkTimeOptimizationEarlyEPCallbacks;
        -:  637:  SmallVector<std::function<void(ModulePassManager &, OptimizationLevel)>, 2>
        -:  638:      FullLinkTimeOptimizationLastEPCallbacks;
        -:  639:  SmallVector<std::function<void(ModulePassManager &, OptimizationLevel)>, 2>
        -:  640:      PipelineStartEPCallbacks;
        -:  641:  SmallVector<std::function<void(ModulePassManager &, OptimizationLevel)>, 2>
        -:  642:      PipelineEarlySimplificationEPCallbacks;
        -:  643:
        -:  644:  SmallVector<std::function<void(ModuleAnalysisManager &)>, 2>
        -:  645:      ModuleAnalysisRegistrationCallbacks;
        -:  646:  SmallVector<std::function<bool(StringRef, ModulePassManager &,
        -:  647:                                 ArrayRef<PipelineElement>)>,
        -:  648:              2>
        -:  649:      ModulePipelineParsingCallbacks;
        -:  650:  SmallVector<
        -:  651:      std::function<bool(ModulePassManager &, ArrayRef<PipelineElement>)>, 2>
        -:  652:      TopLevelPipelineParsingCallbacks;
        -:  653:  // CGSCC callbacks
        -:  654:  SmallVector<std::function<void(CGSCCAnalysisManager &)>, 2>
        -:  655:      CGSCCAnalysisRegistrationCallbacks;
        -:  656:  SmallVector<std::function<bool(StringRef, CGSCCPassManager &,
        -:  657:                                 ArrayRef<PipelineElement>)>,
        -:  658:              2>
        -:  659:      CGSCCPipelineParsingCallbacks;
        -:  660:  // Function callbacks
        -:  661:  SmallVector<std::function<void(FunctionAnalysisManager &)>, 2>
        -:  662:      FunctionAnalysisRegistrationCallbacks;
        -:  663:  SmallVector<std::function<bool(StringRef, FunctionPassManager &,
        -:  664:                                 ArrayRef<PipelineElement>)>,
        -:  665:              2>
        -:  666:      FunctionPipelineParsingCallbacks;
        -:  667:  // Loop callbacks
        -:  668:  SmallVector<std::function<void(LoopAnalysisManager &)>, 2>
        -:  669:      LoopAnalysisRegistrationCallbacks;
        -:  670:  SmallVector<std::function<bool(StringRef, LoopPassManager &,
        -:  671:                                 ArrayRef<PipelineElement>)>,
        -:  672:              2>
        -:  673:      LoopPipelineParsingCallbacks;
        -:  674:  // AA callbacks
        -:  675:  SmallVector<std::function<bool(StringRef Name, AAManager &AA)>, 2>
        -:  676:      AAParsingCallbacks;
        -:  677:};
        -:  678:
        -:  679:/// This utility template takes care of adding require<> and invalidate<>
        -:  680:/// passes for an analysis to a given \c PassManager. It is intended to be used
        -:  681:/// during parsing of a pass pipeline when parsing a single PipelineName.
        -:  682:/// When registering a new function analysis FancyAnalysis with the pass
        -:  683:/// pipeline name "fancy-analysis", a matching ParsePipelineCallback could look
        -:  684:/// like this:
        -:  685:///
        -:  686:/// static bool parseFunctionPipeline(StringRef Name, FunctionPassManager &FPM,
        -:  687:///                                   ArrayRef<PipelineElement> P) {
        -:  688:///   if (parseAnalysisUtilityPasses<FancyAnalysis>("fancy-analysis", Name,
        -:  689:///                                                 FPM))
        -:  690:///     return true;
        -:  691:///   return false;
        -:  692:/// }
        -:  693:template <typename AnalysisT, typename IRUnitT, typename AnalysisManagerT,
        -:  694:          typename... ExtraArgTs>
        -:  695:bool parseAnalysisUtilityPasses(
        -:  696:    StringRef AnalysisName, StringRef PipelineName,
        -:  697:    PassManager<IRUnitT, AnalysisManagerT, ExtraArgTs...> &PM) {
        -:  698:  if (!PipelineName.endswith(">"))
        -:  699:    return false;
        -:  700:  // See if this is an invalidate<> pass name
        -:  701:  if (PipelineName.startswith("invalidate<")) {
        -:  702:    PipelineName = PipelineName.substr(11, PipelineName.size() - 12);
        -:  703:    if (PipelineName != AnalysisName)
        -:  704:      return false;
        -:  705:    PM.addPass(InvalidateAnalysisPass<AnalysisT>());
        -:  706:    return true;
        -:  707:  }
        -:  708:
        -:  709:  // See if this is a require<> pass name
        -:  710:  if (PipelineName.startswith("require<")) {
        -:  711:    PipelineName = PipelineName.substr(8, PipelineName.size() - 9);
        -:  712:    if (PipelineName != AnalysisName)
        -:  713:      return false;
        -:  714:    PM.addPass(RequireAnalysisPass<AnalysisT, IRUnitT, AnalysisManagerT,
        -:  715:                                   ExtraArgTs...>());
        -:  716:    return true;
        -:  717:  }
        -:  718:
        -:  719:  return false;
        -:  720:}
        -:  721:}
        -:  722:
        -:  723:#endif
