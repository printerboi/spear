        -:    0:Source:/usr/include/llvm/IR/Value.h
        -:    0:Graph:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/src/main/include/LLVM-Handler/LLVMHandler.cpp.gcno
        -:    0:Data:/home/maximiliank/Dokumente/workbench/Bachelor/bachelorarbeit/cmake-build-debug-coverage/CMakeFiles/ba.dir/src/main/include/LLVM-Handler/LLVMHandler.cpp.gcda
        -:    0:Runs:1
        -:    1://===- llvm/Value.h - Definition of the Value class -------------*- C++ -*-===//
        -:    2://
        -:    3:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    4:// See https://llvm.org/LICENSE.txt for license information.
        -:    5:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    6://
        -:    7://===----------------------------------------------------------------------===//
        -:    8://
        -:    9:// This file declares the Value class.
        -:   10://
        -:   11://===----------------------------------------------------------------------===//
        -:   12:
        -:   13:#ifndef LLVM_IR_VALUE_H
        -:   14:#define LLVM_IR_VALUE_H
        -:   15:
        -:   16:#include "llvm-c/Types.h"
        -:   17:#include "llvm/ADT/STLExtras.h"
        -:   18:#include "llvm/ADT/StringRef.h"
        -:   19:#include "llvm/ADT/iterator_range.h"
        -:   20:#include "llvm/IR/Use.h"
        -:   21:#include "llvm/Support/Alignment.h"
        -:   22:#include "llvm/Support/CBindingWrapping.h"
        -:   23:#include "llvm/Support/Casting.h"
        -:   24:#include <cassert>
        -:   25:#include <iterator>
        -:   26:#include <memory>
        -:   27:
        -:   28:namespace llvm {
        -:   29:
        -:   30:class APInt;
        -:   31:class Argument;
        -:   32:class BasicBlock;
        -:   33:class Constant;
        -:   34:class ConstantData;
        -:   35:class ConstantAggregate;
        -:   36:class DataLayout;
        -:   37:class Function;
        -:   38:class GlobalAlias;
        -:   39:class GlobalIFunc;
        -:   40:class GlobalObject;
        -:   41:class GlobalValue;
        -:   42:class GlobalVariable;
        -:   43:class InlineAsm;
        -:   44:class Instruction;
        -:   45:class LLVMContext;
        -:   46:class MDNode;
        -:   47:class Module;
        -:   48:class ModuleSlotTracker;
        -:   49:class raw_ostream;
        -:   50:template<typename ValueTy> class StringMapEntry;
        -:   51:class Twine;
        -:   52:class Type;
        -:   53:class User;
        -:   54:
        -:   55:using ValueName = StringMapEntry<Value *>;
        -:   56:
        -:   57://===----------------------------------------------------------------------===//
        -:   58://                                 Value Class
        -:   59://===----------------------------------------------------------------------===//
        -:   60:
        -:   61:/// LLVM Value Representation
        -:   62:///
        -:   63:/// This is a very important LLVM class. It is the base class of all values
        -:   64:/// computed by a program that may be used as operands to other values. Value is
        -:   65:/// the super class of other important classes such as Instruction and Function.
        -:   66:/// All Values have a Type. Type is not a subclass of Value. Some values can
        -:   67:/// have a name and they belong to some Module.  Setting the name on the Value
        -:   68:/// automatically updates the module's symbol table.
        -:   69:///
        -:   70:/// Every value has a "use list" that keeps track of which other Values are
        -:   71:/// using this Value.  A Value can also have an arbitrary number of ValueHandle
        -:   72:/// objects that watch it and listen to RAUW and Destroy events.  See
        -:   73:/// llvm/IR/ValueHandle.h for details.
        -:   74:class Value {
        -:   75:  Type *VTy;
        -:   76:  Use *UseList;
        -:   77:
        -:   78:  friend class ValueAsMetadata; // Allow access to IsUsedByMD.
        -:   79:  friend class ValueHandleBase;
        -:   80:
        -:   81:  const unsigned char SubclassID;   // Subclass identifier (for isa/dyn_cast)
        -:   82:  unsigned char HasValueHandle : 1; // Has a ValueHandle pointing to this?
        -:   83:
        -:   84:protected:
        -:   85:  /// Hold subclass data that can be dropped.
        -:   86:  ///
        -:   87:  /// This member is similar to SubclassData, however it is for holding
        -:   88:  /// information which may be used to aid optimization, but which may be
        -:   89:  /// cleared to zero without affecting conservative interpretation.
        -:   90:  unsigned char SubclassOptionalData : 7;
        -:   91:
        -:   92:private:
        -:   93:  /// Hold arbitrary subclass data.
        -:   94:  ///
        -:   95:  /// This member is defined by this class, but is not used for anything.
        -:   96:  /// Subclasses can use it to hold whatever state they find useful.  This
        -:   97:  /// field is initialized to zero by the ctor.
        -:   98:  unsigned short SubclassData;
        -:   99:
        -:  100:protected:
        -:  101:  /// The number of operands in the subclass.
        -:  102:  ///
        -:  103:  /// This member is defined by this class, but not used for anything.
        -:  104:  /// Subclasses can use it to store their number of operands, if they have
        -:  105:  /// any.
        -:  106:  ///
        -:  107:  /// This is stored here to save space in User on 64-bit hosts.  Since most
        -:  108:  /// instances of Value have operands, 32-bit hosts aren't significantly
        -:  109:  /// affected.
        -:  110:  ///
        -:  111:  /// Note, this should *NOT* be used directly by any class other than User.
        -:  112:  /// User uses this value to find the Use list.
        -:  113:  enum : unsigned { NumUserOperandsBits = 27 };
        -:  114:  unsigned NumUserOperands : NumUserOperandsBits;
        -:  115:
        -:  116:  // Use the same type as the bitfield above so that MSVC will pack them.
        -:  117:  unsigned IsUsedByMD : 1;
        -:  118:  unsigned HasName : 1;
        -:  119:  unsigned HasMetadata : 1; // Has metadata attached to this?
        -:  120:  unsigned HasHungOffUses : 1;
        -:  121:  unsigned HasDescriptor : 1;
        -:  122:
        -:  123:private:
        -:  124:  template <typename UseT> // UseT == 'Use' or 'const Use'
        -:  125:  class use_iterator_impl {
        -:  126:    friend class Value;
        -:  127:
        -:  128:    UseT *U;
        -:  129:
        -:  130:    explicit use_iterator_impl(UseT *u) : U(u) {}
        -:  131:
        -:  132:  public:
        -:  133:    using iterator_category = std::forward_iterator_tag;
        -:  134:    using value_type = UseT *;
        -:  135:    using difference_type = std::ptrdiff_t;
        -:  136:    using pointer = value_type *;
        -:  137:    using reference = value_type &;
        -:  138:
        -:  139:    use_iterator_impl() : U() {}
        -:  140:
        -:  141:    bool operator==(const use_iterator_impl &x) const { return U == x.U; }
        -:  142:    bool operator!=(const use_iterator_impl &x) const { return !operator==(x); }
        -:  143:
        -:  144:    use_iterator_impl &operator++() { // Preincrement
        -:  145:      assert(U && "Cannot increment end iterator!");
        -:  146:      U = U->getNext();
        -:  147:      return *this;
        -:  148:    }
        -:  149:
        -:  150:    use_iterator_impl operator++(int) { // Postincrement
        -:  151:      auto tmp = *this;
        -:  152:      ++*this;
        -:  153:      return tmp;
        -:  154:    }
        -:  155:
        -:  156:    UseT &operator*() const {
        -:  157:      assert(U && "Cannot dereference end iterator!");
        -:  158:      return *U;
        -:  159:    }
        -:  160:
        -:  161:    UseT *operator->() const { return &operator*(); }
        -:  162:
        -:  163:    operator use_iterator_impl<const UseT>() const {
        -:  164:      return use_iterator_impl<const UseT>(U);
        -:  165:    }
        -:  166:  };
        -:  167:
        -:  168:  template <typename UserTy> // UserTy == 'User' or 'const User'
        -:  169:  class user_iterator_impl {
        -:  170:    use_iterator_impl<Use> UI;
        -:  171:    explicit user_iterator_impl(Use *U) : UI(U) {}
        -:  172:    friend class Value;
        -:  173:
        -:  174:  public:
        -:  175:    using iterator_category = std::forward_iterator_tag;
        -:  176:    using value_type = UserTy *;
        -:  177:    using difference_type = std::ptrdiff_t;
        -:  178:    using pointer = value_type *;
        -:  179:    using reference = value_type &;
        -:  180:
        -:  181:    user_iterator_impl() = default;
        -:  182:
        -:  183:    bool operator==(const user_iterator_impl &x) const { return UI == x.UI; }
        -:  184:    bool operator!=(const user_iterator_impl &x) const { return !operator==(x); }
        -:  185:
        -:  186:    /// Returns true if this iterator is equal to user_end() on the value.
        -:  187:    bool atEnd() const { return *this == user_iterator_impl(); }
        -:  188:
        -:  189:    user_iterator_impl &operator++() { // Preincrement
        -:  190:      ++UI;
        -:  191:      return *this;
        -:  192:    }
        -:  193:
        -:  194:    user_iterator_impl operator++(int) { // Postincrement
        -:  195:      auto tmp = *this;
        -:  196:      ++*this;
        -:  197:      return tmp;
        -:  198:    }
        -:  199:
        -:  200:    // Retrieve a pointer to the current User.
        -:  201:    UserTy *operator*() const {
        -:  202:      return UI->getUser();
        -:  203:    }
        -:  204:
        -:  205:    UserTy *operator->() const { return operator*(); }
        -:  206:
        -:  207:    operator user_iterator_impl<const UserTy>() const {
        -:  208:      return user_iterator_impl<const UserTy>(*UI);
        -:  209:    }
        -:  210:
        -:  211:    Use &getUse() const { return *UI; }
        -:  212:  };
        -:  213:
        -:  214:protected:
        -:  215:  Value(Type *Ty, unsigned scid);
        -:  216:
        -:  217:  /// Value's destructor should be virtual by design, but that would require
        -:  218:  /// that Value and all of its subclasses have a vtable that effectively
        -:  219:  /// duplicates the information in the value ID. As a size optimization, the
        -:  220:  /// destructor has been protected, and the caller should manually call
        -:  221:  /// deleteValue.
        -:  222:  ~Value(); // Use deleteValue() to delete a generic Value.
        -:  223:
        -:  224:public:
        -:  225:  Value(const Value &) = delete;
        -:  226:  Value &operator=(const Value &) = delete;
        -:  227:
        -:  228:  /// Delete a pointer to a generic Value.
        -:  229:  void deleteValue();
        -:  230:
        -:  231:  /// Support for debugging, callable in GDB: V->dump()
        -:  232:  void dump() const;
        -:  233:
        -:  234:  /// Implement operator<< on Value.
        -:  235:  /// @{
        -:  236:  void print(raw_ostream &O, bool IsForDebug = false) const;
        -:  237:  void print(raw_ostream &O, ModuleSlotTracker &MST,
        -:  238:             bool IsForDebug = false) const;
        -:  239:  /// @}
        -:  240:
        -:  241:  /// Print the name of this Value out to the specified raw_ostream.
        -:  242:  ///
        -:  243:  /// This is useful when you just want to print 'int %reg126', not the
        -:  244:  /// instruction that generated it. If you specify a Module for context, then
        -:  245:  /// even constanst get pretty-printed; for example, the type of a null
        -:  246:  /// pointer is printed symbolically.
        -:  247:  /// @{
        -:  248:  void printAsOperand(raw_ostream &O, bool PrintType = true,
        -:  249:                      const Module *M = nullptr) const;
        -:  250:  void printAsOperand(raw_ostream &O, bool PrintType,
        -:  251:                      ModuleSlotTracker &MST) const;
        -:  252:  /// @}
        -:  253:
        -:  254:  /// All values are typed, get the type of this value.
        -:  255:  Type *getType() const { return VTy; }
        -:  256:
        -:  257:  /// All values hold a context through their type.
        -:  258:  LLVMContext &getContext() const;
        -:  259:
        -:  260:  // All values can potentially be named.
        -:  261:  bool hasName() const { return HasName; }
        -:  262:  ValueName *getValueName() const;
        -:  263:  void setValueName(ValueName *VN);
        -:  264:
        -:  265:private:
        -:  266:  void destroyValueName();
        -:  267:  enum class ReplaceMetadataUses { No, Yes };
        -:  268:  void doRAUW(Value *New, ReplaceMetadataUses);
        -:  269:  void setNameImpl(const Twine &Name);
        -:  270:
        -:  271:public:
        -:  272:  /// Return a constant reference to the value's name.
        -:  273:  ///
        -:  274:  /// This guaranteed to return the same reference as long as the value is not
        -:  275:  /// modified.  If the value has a name, this does a hashtable lookup, so it's
        -:  276:  /// not free.
        -:  277:  StringRef getName() const;
        -:  278:
        -:  279:  /// Change the name of the value.
        -:  280:  ///
        -:  281:  /// Choose a new unique name if the provided name is taken.
        -:  282:  ///
        -:  283:  /// \param Name The new name; or "" if the value's name should be removed.
        -:  284:  void setName(const Twine &Name);
        -:  285:
        -:  286:  /// Transfer the name from V to this value.
        -:  287:  ///
        -:  288:  /// After taking V's name, sets V's name to empty.
        -:  289:  ///
        -:  290:  /// \note It is an error to call V->takeName(V).
        -:  291:  void takeName(Value *V);
        -:  292:
        -:  293:#ifndef NDEBUG
        -:  294:  std::string getNameOrAsOperand() const;
        -:  295:#endif
        -:  296:
        -:  297:  /// Change all uses of this to point to a new Value.
        -:  298:  ///
        -:  299:  /// Go through the uses list for this definition and make each use point to
        -:  300:  /// "V" instead of "this".  After this completes, 'this's use list is
        -:  301:  /// guaranteed to be empty.
        -:  302:  void replaceAllUsesWith(Value *V);
        -:  303:
        -:  304:  /// Change non-metadata uses of this to point to a new Value.
        -:  305:  ///
        -:  306:  /// Go through the uses list for this definition and make each use point to
        -:  307:  /// "V" instead of "this". This function skips metadata entries in the list.
        -:  308:  void replaceNonMetadataUsesWith(Value *V);
        -:  309:
        -:  310:  /// Go through the uses list for this definition and make each use point
        -:  311:  /// to "V" if the callback ShouldReplace returns true for the given Use.
        -:  312:  /// Unlike replaceAllUsesWith() this function does not support basic block
        -:  313:  /// values.
        -:  314:  void replaceUsesWithIf(Value *New,
        -:  315:                         llvm::function_ref<bool(Use &U)> ShouldReplace);
        -:  316:
        -:  317:  /// replaceUsesOutsideBlock - Go through the uses list for this definition and
        -:  318:  /// make each use point to "V" instead of "this" when the use is outside the
        -:  319:  /// block. 'This's use list is expected to have at least one element.
        -:  320:  /// Unlike replaceAllUsesWith() this function does not support basic block
        -:  321:  /// values.
        -:  322:  void replaceUsesOutsideBlock(Value *V, BasicBlock *BB);
        -:  323:
        -:  324:  //----------------------------------------------------------------------
        -:  325:  // Methods for handling the chain of uses of this Value.
        -:  326:  //
        -:  327:  // Materializing a function can introduce new uses, so these methods come in
        -:  328:  // two variants:
        -:  329:  // The methods that start with materialized_ check the uses that are
        -:  330:  // currently known given which functions are materialized. Be very careful
        -:  331:  // when using them since you might not get all uses.
        -:  332:  // The methods that don't start with materialized_ assert that modules is
        -:  333:  // fully materialized.
        -:  334:  void assertModuleIsMaterializedImpl() const;
        -:  335:  // This indirection exists so we can keep assertModuleIsMaterializedImpl()
        -:  336:  // around in release builds of Value.cpp to be linked with other code built
        -:  337:  // in debug mode. But this avoids calling it in any of the release built code.
        -:  338:  void assertModuleIsMaterialized() const {
        -:  339:#ifndef NDEBUG
        -:  340:    assertModuleIsMaterializedImpl();
        -:  341:#endif
        -:  342:  }
        -:  343:
        -:  344:  bool use_empty() const {
        -:  345:    assertModuleIsMaterialized();
        -:  346:    return UseList == nullptr;
        -:  347:  }
        -:  348:
        -:  349:  bool materialized_use_empty() const {
        -:  350:    return UseList == nullptr;
        -:  351:  }
        -:  352:
        -:  353:  using use_iterator = use_iterator_impl<Use>;
        -:  354:  using const_use_iterator = use_iterator_impl<const Use>;
        -:  355:
        -:  356:  use_iterator materialized_use_begin() { return use_iterator(UseList); }
        -:  357:  const_use_iterator materialized_use_begin() const {
        -:  358:    return const_use_iterator(UseList);
        -:  359:  }
        -:  360:  use_iterator use_begin() {
        -:  361:    assertModuleIsMaterialized();
        -:  362:    return materialized_use_begin();
        -:  363:  }
        -:  364:  const_use_iterator use_begin() const {
        -:  365:    assertModuleIsMaterialized();
        -:  366:    return materialized_use_begin();
        -:  367:  }
        -:  368:  use_iterator use_end() { return use_iterator(); }
        -:  369:  const_use_iterator use_end() const { return const_use_iterator(); }
        -:  370:  iterator_range<use_iterator> materialized_uses() {
        -:  371:    return make_range(materialized_use_begin(), use_end());
        -:  372:  }
        -:  373:  iterator_range<const_use_iterator> materialized_uses() const {
        -:  374:    return make_range(materialized_use_begin(), use_end());
        -:  375:  }
        -:  376:  iterator_range<use_iterator> uses() {
        -:  377:    assertModuleIsMaterialized();
        -:  378:    return materialized_uses();
        -:  379:  }
        -:  380:  iterator_range<const_use_iterator> uses() const {
        -:  381:    assertModuleIsMaterialized();
        -:  382:    return materialized_uses();
        -:  383:  }
        -:  384:
        -:  385:  bool user_empty() const {
        -:  386:    assertModuleIsMaterialized();
        -:  387:    return UseList == nullptr;
        -:  388:  }
        -:  389:
        -:  390:  using user_iterator = user_iterator_impl<User>;
        -:  391:  using const_user_iterator = user_iterator_impl<const User>;
        -:  392:
        -:  393:  user_iterator materialized_user_begin() { return user_iterator(UseList); }
        -:  394:  const_user_iterator materialized_user_begin() const {
        -:  395:    return const_user_iterator(UseList);
        -:  396:  }
        -:  397:  user_iterator user_begin() {
        -:  398:    assertModuleIsMaterialized();
        -:  399:    return materialized_user_begin();
        -:  400:  }
        -:  401:  const_user_iterator user_begin() const {
        -:  402:    assertModuleIsMaterialized();
        -:  403:    return materialized_user_begin();
        -:  404:  }
        -:  405:  user_iterator user_end() { return user_iterator(); }
        -:  406:  const_user_iterator user_end() const { return const_user_iterator(); }
        -:  407:  User *user_back() {
        -:  408:    assertModuleIsMaterialized();
        -:  409:    return *materialized_user_begin();
        -:  410:  }
        -:  411:  const User *user_back() const {
        -:  412:    assertModuleIsMaterialized();
        -:  413:    return *materialized_user_begin();
        -:  414:  }
        -:  415:  iterator_range<user_iterator> materialized_users() {
        -:  416:    return make_range(materialized_user_begin(), user_end());
        -:  417:  }
        -:  418:  iterator_range<const_user_iterator> materialized_users() const {
        -:  419:    return make_range(materialized_user_begin(), user_end());
        -:  420:  }
        -:  421:  iterator_range<user_iterator> users() {
        -:  422:    assertModuleIsMaterialized();
        -:  423:    return materialized_users();
        -:  424:  }
        -:  425:  iterator_range<const_user_iterator> users() const {
        -:  426:    assertModuleIsMaterialized();
        -:  427:    return materialized_users();
        -:  428:  }
        -:  429:
        -:  430:  /// Return true if there is exactly one use of this value.
        -:  431:  ///
        -:  432:  /// This is specialized because it is a common request and does not require
        -:  433:  /// traversing the whole use list.
        -:  434:  bool hasOneUse() const { return hasSingleElement(uses()); }
        -:  435:
        -:  436:  /// Return true if this Value has exactly N uses.
        -:  437:  bool hasNUses(unsigned N) const;
        -:  438:
        -:  439:  /// Return true if this value has N uses or more.
        -:  440:  ///
        -:  441:  /// This is logically equivalent to getNumUses() >= N.
        -:  442:  bool hasNUsesOrMore(unsigned N) const;
        -:  443:
        -:  444:  /// Return true if there is exactly one user of this value.
        -:  445:  ///
        -:  446:  /// Note that this is not the same as "has one use". If a value has one use,
        -:  447:  /// then there certainly is a single user. But if value has several uses,
        -:  448:  /// it is possible that all uses are in a single user, or not.
        -:  449:  ///
        -:  450:  /// This check is potentially costly, since it requires traversing,
        -:  451:  /// in the worst case, the whole use list of a value.
        -:  452:  bool hasOneUser() const;
        -:  453:
        -:  454:  /// Return true if there is exactly one use of this value that cannot be
        -:  455:  /// dropped.
        -:  456:  Use *getSingleUndroppableUse();
        -:  457:  const Use *getSingleUndroppableUse() const {
        -:  458:    return const_cast<Value *>(this)->getSingleUndroppableUse();
        -:  459:  }
        -:  460:
        -:  461:  /// Return true if there is exactly one unique user of this value that cannot be
        -:  462:  /// dropped (that user can have multiple uses of this value).
        -:  463:  User *getUniqueUndroppableUser();
        -:  464:  const User *getUniqueUndroppableUser() const {
        -:  465:    return const_cast<Value *>(this)->getUniqueUndroppableUser();
        -:  466:  }
        -:  467:
        -:  468:  /// Return true if there this value.
        -:  469:  ///
        -:  470:  /// This is specialized because it is a common request and does not require
        -:  471:  /// traversing the whole use list.
        -:  472:  bool hasNUndroppableUses(unsigned N) const;
        -:  473:
        -:  474:  /// Return true if this value has N uses or more.
        -:  475:  ///
        -:  476:  /// This is logically equivalent to getNumUses() >= N.
        -:  477:  bool hasNUndroppableUsesOrMore(unsigned N) const;
        -:  478:
        -:  479:  /// Remove every uses that can safely be removed.
        -:  480:  ///
        -:  481:  /// This will remove for example uses in llvm.assume.
        -:  482:  /// This should be used when performing want to perform a tranformation but
        -:  483:  /// some Droppable uses pervent it.
        -:  484:  /// This function optionally takes a filter to only remove some droppable
        -:  485:  /// uses.
        -:  486:  void dropDroppableUses(llvm::function_ref<bool(const Use *)> ShouldDrop =
        -:  487:                             [](const Use *) { return true; });
        -:  488:
        -:  489:  /// Remove every use of this value in \p User that can safely be removed.
        -:  490:  void dropDroppableUsesIn(User &Usr);
        -:  491:
        -:  492:  /// Remove the droppable use \p U.
        -:  493:  static void dropDroppableUse(Use &U);
        -:  494:
        -:  495:  /// Check if this value is used in the specified basic block.
        -:  496:  bool isUsedInBasicBlock(const BasicBlock *BB) const;
        -:  497:
        -:  498:  /// This method computes the number of uses of this Value.
        -:  499:  ///
        -:  500:  /// This is a linear time operation.  Use hasOneUse, hasNUses, or
        -:  501:  /// hasNUsesOrMore to check for specific values.
        -:  502:  unsigned getNumUses() const;
        -:  503:
        -:  504:  /// This method should only be used by the Use class.
        -:  505:  void addUse(Use &U) { U.addToList(&UseList); }
        -:  506:
        -:  507:  /// Concrete subclass of this.
        -:  508:  ///
        -:  509:  /// An enumeration for keeping track of the concrete subclass of Value that
        -:  510:  /// is actually instantiated. Values of this enumeration are kept in the
        -:  511:  /// Value classes SubclassID field. They are used for concrete type
        -:  512:  /// identification.
        -:  513:  enum ValueTy {
        -:  514:#define HANDLE_VALUE(Name) Name##Val,
        -:  515:#include "llvm/IR/Value.def"
        -:  516:
        -:  517:    // Markers:
        -:  518:#define HANDLE_CONSTANT_MARKER(Marker, Constant) Marker = Constant##Val,
        -:  519:#include "llvm/IR/Value.def"
        -:  520:  };
        -:  521:
        -:  522:  /// Return an ID for the concrete type of this object.
        -:  523:  ///
        -:  524:  /// This is used to implement the classof checks.  This should not be used
        -:  525:  /// for any other purpose, as the values may change as LLVM evolves.  Also,
        -:  526:  /// note that for instructions, the Instruction's opcode is added to
        -:  527:  /// InstructionVal. So this means three things:
        -:  528:  /// # there is no value with code InstructionVal (no opcode==0).
        -:  529:  /// # there are more possible values for the value type than in ValueTy enum.
        -:  530:  /// # the InstructionVal enumerator must be the highest valued enumerator in
        -:  531:  ///   the ValueTy enum.
function _ZNK4llvm5Value10getValueIDEv called 0 returned 0% blocks executed 0%
    #####:  532:  unsigned getValueID() const {
    #####:  533:    return SubclassID;
    %%%%%:  533-block  0
        -:  534:  }
        -:  535:
        -:  536:  /// Return the raw optional flags value contained in this value.
        -:  537:  ///
        -:  538:  /// This should only be used when testing two Values for equivalence.
        -:  539:  unsigned getRawSubclassOptionalData() const {
        -:  540:    return SubclassOptionalData;
        -:  541:  }
        -:  542:
        -:  543:  /// Clear the optional flags contained in this value.
        -:  544:  void clearSubclassOptionalData() {
        -:  545:    SubclassOptionalData = 0;
        -:  546:  }
        -:  547:
        -:  548:  /// Check the optional flags for equality.
        -:  549:  bool hasSameSubclassOptionalData(const Value *V) const {
        -:  550:    return SubclassOptionalData == V->SubclassOptionalData;
        -:  551:  }
        -:  552:
        -:  553:  /// Return true if there is a value handle associated with this value.
        -:  554:  bool hasValueHandle() const { return HasValueHandle; }
        -:  555:
        -:  556:  /// Return true if there is metadata referencing this value.
        -:  557:  bool isUsedByMetadata() const { return IsUsedByMD; }
        -:  558:
        -:  559:  // Return true if this value is only transitively referenced by metadata.
        -:  560:  bool isTransitiveUsedByMetadataOnly() const;
        -:  561:
        -:  562:protected:
        -:  563:  /// Get the current metadata attachments for the given kind, if any.
        -:  564:  ///
        -:  565:  /// These functions require that the value have at most a single attachment
        -:  566:  /// of the given kind, and return \c nullptr if such an attachment is missing.
        -:  567:  /// @{
        -:  568:  MDNode *getMetadata(unsigned KindID) const;
        -:  569:  MDNode *getMetadata(StringRef Kind) const;
        -:  570:  /// @}
        -:  571:
        -:  572:  /// Appends all attachments with the given ID to \c MDs in insertion order.
        -:  573:  /// If the Value has no attachments with the given ID, or if ID is invalid,
        -:  574:  /// leaves MDs unchanged.
        -:  575:  /// @{
        -:  576:  void getMetadata(unsigned KindID, SmallVectorImpl<MDNode *> &MDs) const;
        -:  577:  void getMetadata(StringRef Kind, SmallVectorImpl<MDNode *> &MDs) const;
        -:  578:  /// @}
        -:  579:
        -:  580:  /// Appends all metadata attached to this value to \c MDs, sorting by
        -:  581:  /// KindID. The first element of each pair returned is the KindID, the second
        -:  582:  /// element is the metadata value. Attachments with the same ID appear in
        -:  583:  /// insertion order.
        -:  584:  void
        -:  585:  getAllMetadata(SmallVectorImpl<std::pair<unsigned, MDNode *>> &MDs) const;
        -:  586:
        -:  587:  /// Return true if this value has any metadata attached to it.
        -:  588:  bool hasMetadata() const { return (bool)HasMetadata; }
        -:  589:
        -:  590:  /// Return true if this value has the given type of metadata attached.
        -:  591:  /// @{
        -:  592:  bool hasMetadata(unsigned KindID) const {
        -:  593:    return getMetadata(KindID) != nullptr;
        -:  594:  }
        -:  595:  bool hasMetadata(StringRef Kind) const {
        -:  596:    return getMetadata(Kind) != nullptr;
        -:  597:  }
        -:  598:  /// @}
        -:  599:
        -:  600:  /// Set a particular kind of metadata attachment.
        -:  601:  ///
        -:  602:  /// Sets the given attachment to \c MD, erasing it if \c MD is \c nullptr or
        -:  603:  /// replacing it if it already exists.
        -:  604:  /// @{
        -:  605:  void setMetadata(unsigned KindID, MDNode *Node);
        -:  606:  void setMetadata(StringRef Kind, MDNode *Node);
        -:  607:  /// @}
        -:  608:
        -:  609:  /// Add a metadata attachment.
        -:  610:  /// @{
        -:  611:  void addMetadata(unsigned KindID, MDNode &MD);
        -:  612:  void addMetadata(StringRef Kind, MDNode &MD);
        -:  613:  /// @}
        -:  614:
        -:  615:  /// Erase all metadata attachments with the given kind.
        -:  616:  ///
        -:  617:  /// \returns true if any metadata was removed.
        -:  618:  bool eraseMetadata(unsigned KindID);
        -:  619:
        -:  620:  /// Erase all metadata attached to this Value.
        -:  621:  void clearMetadata();
        -:  622:
        -:  623:public:
        -:  624:  /// Return true if this value is a swifterror value.
        -:  625:  ///
        -:  626:  /// swifterror values can be either a function argument or an alloca with a
        -:  627:  /// swifterror attribute.
        -:  628:  bool isSwiftError() const;
        -:  629:
        -:  630:  /// Strip off pointer casts, all-zero GEPs and address space casts.
        -:  631:  ///
        -:  632:  /// Returns the original uncasted value.  If this is called on a non-pointer
        -:  633:  /// value, it returns 'this'.
        -:  634:  const Value *stripPointerCasts() const;
        -:  635:  Value *stripPointerCasts() {
        -:  636:    return const_cast<Value *>(
        -:  637:        static_cast<const Value *>(this)->stripPointerCasts());
        -:  638:  }
        -:  639:
        -:  640:  /// Strip off pointer casts, all-zero GEPs, address space casts, and aliases.
        -:  641:  ///
        -:  642:  /// Returns the original uncasted value.  If this is called on a non-pointer
        -:  643:  /// value, it returns 'this'.
        -:  644:  const Value *stripPointerCastsAndAliases() const;
        -:  645:  Value *stripPointerCastsAndAliases() {
        -:  646:    return const_cast<Value *>(
        -:  647:        static_cast<const Value *>(this)->stripPointerCastsAndAliases());
        -:  648:  }
        -:  649:
        -:  650:  /// Strip off pointer casts, all-zero GEPs and address space casts
        -:  651:  /// but ensures the representation of the result stays the same.
        -:  652:  ///
        -:  653:  /// Returns the original uncasted value with the same representation. If this
        -:  654:  /// is called on a non-pointer value, it returns 'this'.
        -:  655:  const Value *stripPointerCastsSameRepresentation() const;
        -:  656:  Value *stripPointerCastsSameRepresentation() {
        -:  657:    return const_cast<Value *>(static_cast<const Value *>(this)
        -:  658:                                   ->stripPointerCastsSameRepresentation());
        -:  659:  }
        -:  660:
        -:  661:  /// Strip off pointer casts, all-zero GEPs, single-argument phi nodes and
        -:  662:  /// invariant group info.
        -:  663:  ///
        -:  664:  /// Returns the original uncasted value.  If this is called on a non-pointer
        -:  665:  /// value, it returns 'this'. This function should be used only in
        -:  666:  /// Alias analysis.
        -:  667:  const Value *stripPointerCastsForAliasAnalysis() const;
        -:  668:  Value *stripPointerCastsForAliasAnalysis() {
        -:  669:    return const_cast<Value *>(static_cast<const Value *>(this)
        -:  670:                                   ->stripPointerCastsForAliasAnalysis());
        -:  671:  }
        -:  672:
        -:  673:  /// Strip off pointer casts and all-constant inbounds GEPs.
        -:  674:  ///
        -:  675:  /// Returns the original pointer value.  If this is called on a non-pointer
        -:  676:  /// value, it returns 'this'.
        -:  677:  const Value *stripInBoundsConstantOffsets() const;
        -:  678:  Value *stripInBoundsConstantOffsets() {
        -:  679:    return const_cast<Value *>(
        -:  680:              static_cast<const Value *>(this)->stripInBoundsConstantOffsets());
        -:  681:  }
        -:  682:
        -:  683:  /// Accumulate the constant offset this value has compared to a base pointer.
        -:  684:  /// Only 'getelementptr' instructions (GEPs) are accumulated but other
        -:  685:  /// instructions, e.g., casts, are stripped away as well.
        -:  686:  /// The accumulated constant offset is added to \p Offset and the base
        -:  687:  /// pointer is returned.
        -:  688:  ///
        -:  689:  /// The APInt \p Offset has to have a bit-width equal to the IntPtr type for
        -:  690:  /// the address space of 'this' pointer value, e.g., use
        -:  691:  /// DataLayout::getIndexTypeSizeInBits(Ty).
        -:  692:  ///
        -:  693:  /// If \p AllowNonInbounds is true, offsets in GEPs are stripped and
        -:  694:  /// accumulated even if the GEP is not "inbounds".
        -:  695:  ///
        -:  696:  /// If \p AllowInvariantGroup is true then this method also looks through
        -:  697:  /// strip.invariant.group and launder.invariant.group intrinsics.
        -:  698:  ///
        -:  699:  /// If \p ExternalAnalysis is provided it will be used to calculate a offset
        -:  700:  /// when a operand of GEP is not constant.
        -:  701:  /// For example, for a value \p ExternalAnalysis might try to calculate a
        -:  702:  /// lower bound. If \p ExternalAnalysis is successful, it should return true.
        -:  703:  ///
        -:  704:  /// If this is called on a non-pointer value, it returns 'this' and the
        -:  705:  /// \p Offset is not modified.
        -:  706:  ///
        -:  707:  /// Note that this function will never return a nullptr. It will also never
        -:  708:  /// manipulate the \p Offset in a way that would not match the difference
        -:  709:  /// between the underlying value and the returned one. Thus, if no constant
        -:  710:  /// offset was found, the returned value is the underlying one and \p Offset
        -:  711:  /// is unchanged.
        -:  712:  const Value *stripAndAccumulateConstantOffsets(
        -:  713:      const DataLayout &DL, APInt &Offset, bool AllowNonInbounds,
        -:  714:      bool AllowInvariantGroup = false,
        -:  715:      function_ref<bool(Value &Value, APInt &Offset)> ExternalAnalysis =
        -:  716:          nullptr) const;
        -:  717:  Value *stripAndAccumulateConstantOffsets(const DataLayout &DL, APInt &Offset,
        -:  718:                                           bool AllowNonInbounds,
        -:  719:                                           bool AllowInvariantGroup = false) {
        -:  720:    return const_cast<Value *>(
        -:  721:        static_cast<const Value *>(this)->stripAndAccumulateConstantOffsets(
        -:  722:            DL, Offset, AllowNonInbounds, AllowInvariantGroup));
        -:  723:  }
        -:  724:
        -:  725:  /// This is a wrapper around stripAndAccumulateConstantOffsets with the
        -:  726:  /// in-bounds requirement set to false.
        -:  727:  const Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,
        -:  728:                                                         APInt &Offset) const {
        -:  729:    return stripAndAccumulateConstantOffsets(DL, Offset,
        -:  730:                                             /* AllowNonInbounds */ false);
        -:  731:  }
        -:  732:  Value *stripAndAccumulateInBoundsConstantOffsets(const DataLayout &DL,
        -:  733:                                                   APInt &Offset) {
        -:  734:    return stripAndAccumulateConstantOffsets(DL, Offset,
        -:  735:                                             /* AllowNonInbounds */ false);
        -:  736:  }
        -:  737:
        -:  738:  /// Strip off pointer casts and inbounds GEPs.
        -:  739:  ///
        -:  740:  /// Returns the original pointer value.  If this is called on a non-pointer
        -:  741:  /// value, it returns 'this'.
        -:  742:  const Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =
        -:  743:                                        [](const Value *) {}) const;
        -:  744:  inline Value *stripInBoundsOffsets(function_ref<void(const Value *)> Func =
        -:  745:                                  [](const Value *) {}) {
        -:  746:    return const_cast<Value *>(
        -:  747:        static_cast<const Value *>(this)->stripInBoundsOffsets(Func));
        -:  748:  }
        -:  749:
        -:  750:  /// Return true if the memory object referred to by V can by freed in the
        -:  751:  /// scope for which the SSA value defining the allocation is statically
        -:  752:  /// defined.  E.g.  deallocation after the static scope of a value does not
        -:  753:  /// count, but a deallocation before that does.
        -:  754:  bool canBeFreed() const;
        -:  755:
        -:  756:  /// Returns the number of bytes known to be dereferenceable for the
        -:  757:  /// pointer value.
        -:  758:  ///
        -:  759:  /// If CanBeNull is set by this function the pointer can either be null or be
        -:  760:  /// dereferenceable up to the returned number of bytes.
        -:  761:  ///
        -:  762:  /// IF CanBeFreed is true, the pointer is known to be dereferenceable at
        -:  763:  /// point of definition only.  Caller must prove that allocation is not
        -:  764:  /// deallocated between point of definition and use.
        -:  765:  uint64_t getPointerDereferenceableBytes(const DataLayout &DL,
        -:  766:                                          bool &CanBeNull,
        -:  767:                                          bool &CanBeFreed) const;
        -:  768:
        -:  769:  /// Returns an alignment of the pointer value.
        -:  770:  ///
        -:  771:  /// Returns an alignment which is either specified explicitly, e.g. via
        -:  772:  /// align attribute of a function argument, or guaranteed by DataLayout.
        -:  773:  Align getPointerAlignment(const DataLayout &DL) const;
        -:  774:
        -:  775:  /// Translate PHI node to its predecessor from the given basic block.
        -:  776:  ///
        -:  777:  /// If this value is a PHI node with CurBB as its parent, return the value in
        -:  778:  /// the PHI node corresponding to PredBB.  If not, return ourself.  This is
        -:  779:  /// useful if you want to know the value something has in a predecessor
        -:  780:  /// block.
        -:  781:  const Value *DoPHITranslation(const BasicBlock *CurBB,
        -:  782:                                const BasicBlock *PredBB) const;
        -:  783:  Value *DoPHITranslation(const BasicBlock *CurBB, const BasicBlock *PredBB) {
        -:  784:    return const_cast<Value *>(
        -:  785:             static_cast<const Value *>(this)->DoPHITranslation(CurBB, PredBB));
        -:  786:  }
        -:  787:
        -:  788:  /// The maximum alignment for instructions.
        -:  789:  ///
        -:  790:  /// This is the greatest alignment value supported by load, store, and alloca
        -:  791:  /// instructions, and global values.
        -:  792:  static constexpr unsigned MaxAlignmentExponent = 32;
        -:  793:  static constexpr uint64_t MaximumAlignment = 1ULL << MaxAlignmentExponent;
        -:  794:
        -:  795:  /// Mutate the type of this Value to be of the specified type.
        -:  796:  ///
        -:  797:  /// Note that this is an extremely dangerous operation which can create
        -:  798:  /// completely invalid IR very easily.  It is strongly recommended that you
        -:  799:  /// recreate IR objects with the right types instead of mutating them in
        -:  800:  /// place.
        -:  801:  void mutateType(Type *Ty) {
        -:  802:    VTy = Ty;
        -:  803:  }
        -:  804:
        -:  805:  /// Sort the use-list.
        -:  806:  ///
        -:  807:  /// Sorts the Value's use-list by Cmp using a stable mergesort.  Cmp is
        -:  808:  /// expected to compare two \a Use references.
        -:  809:  template <class Compare> void sortUseList(Compare Cmp);
        -:  810:
        -:  811:  /// Reverse the use-list.
        -:  812:  void reverseUseList();
        -:  813:
        -:  814:private:
        -:  815:  /// Merge two lists together.
        -:  816:  ///
        -:  817:  /// Merges \c L and \c R using \c Cmp.  To enable stable sorts, always pushes
        -:  818:  /// "equal" items from L before items from R.
        -:  819:  ///
        -:  820:  /// \return the first element in the list.
        -:  821:  ///
        -:  822:  /// \note Completely ignores \a Use::Prev (doesn't read, doesn't update).
        -:  823:  template <class Compare>
        -:  824:  static Use *mergeUseLists(Use *L, Use *R, Compare Cmp) {
        -:  825:    Use *Merged;
        -:  826:    Use **Next = &Merged;
        -:  827:
        -:  828:    while (true) {
        -:  829:      if (!L) {
        -:  830:        *Next = R;
        -:  831:        break;
        -:  832:      }
        -:  833:      if (!R) {
        -:  834:        *Next = L;
        -:  835:        break;
        -:  836:      }
        -:  837:      if (Cmp(*R, *L)) {
        -:  838:        *Next = R;
        -:  839:        Next = &R->Next;
        -:  840:        R = R->Next;
        -:  841:      } else {
        -:  842:        *Next = L;
        -:  843:        Next = &L->Next;
        -:  844:        L = L->Next;
        -:  845:      }
        -:  846:    }
        -:  847:
        -:  848:    return Merged;
        -:  849:  }
        -:  850:
        -:  851:protected:
        -:  852:  unsigned short getSubclassDataFromValue() const { return SubclassData; }
        -:  853:  void setValueSubclassData(unsigned short D) { SubclassData = D; }
        -:  854:};
        -:  855:
        -:  856:struct ValueDeleter { void operator()(Value *V) { V->deleteValue(); } };
        -:  857:
        -:  858:/// Use this instead of std::unique_ptr<Value> or std::unique_ptr<Instruction>.
        -:  859:/// Those don't work because Value and Instruction's destructors are protected,
        -:  860:/// aren't virtual, and won't destroy the complete object.
        -:  861:using unique_value = std::unique_ptr<Value, ValueDeleter>;
        -:  862:
        -:  863:inline raw_ostream &operator<<(raw_ostream &OS, const Value &V) {
        -:  864:  V.print(OS);
        -:  865:  return OS;
        -:  866:}
        -:  867:
        -:  868:void Use::set(Value *V) {
        -:  869:  if (Val) removeFromList();
        -:  870:  Val = V;
        -:  871:  if (V) V->addUse(*this);
        -:  872:}
        -:  873:
        -:  874:Value *Use::operator=(Value *RHS) {
        -:  875:  set(RHS);
        -:  876:  return RHS;
        -:  877:}
        -:  878:
        -:  879:const Use &Use::operator=(const Use &RHS) {
        -:  880:  set(RHS.Val);
        -:  881:  return *this;
        -:  882:}
        -:  883:
        -:  884:template <class Compare> void Value::sortUseList(Compare Cmp) {
        -:  885:  if (!UseList || !UseList->Next)
        -:  886:    // No need to sort 0 or 1 uses.
        -:  887:    return;
        -:  888:
        -:  889:  // Note: this function completely ignores Prev pointers until the end when
        -:  890:  // they're fixed en masse.
        -:  891:
        -:  892:  // Create a binomial vector of sorted lists, visiting uses one at a time and
        -:  893:  // merging lists as necessary.
        -:  894:  const unsigned MaxSlots = 32;
        -:  895:  Use *Slots[MaxSlots];
        -:  896:
        -:  897:  // Collect the first use, turning it into a single-item list.
        -:  898:  Use *Next = UseList->Next;
        -:  899:  UseList->Next = nullptr;
        -:  900:  unsigned NumSlots = 1;
        -:  901:  Slots[0] = UseList;
        -:  902:
        -:  903:  // Collect all but the last use.
        -:  904:  while (Next->Next) {
        -:  905:    Use *Current = Next;
        -:  906:    Next = Current->Next;
        -:  907:
        -:  908:    // Turn Current into a single-item list.
        -:  909:    Current->Next = nullptr;
        -:  910:
        -:  911:    // Save Current in the first available slot, merging on collisions.
        -:  912:    unsigned I;
        -:  913:    for (I = 0; I < NumSlots; ++I) {
        -:  914:      if (!Slots[I])
        -:  915:        break;
        -:  916:
        -:  917:      // Merge two lists, doubling the size of Current and emptying slot I.
        -:  918:      //
        -:  919:      // Since the uses in Slots[I] originally preceded those in Current, send
        -:  920:      // Slots[I] in as the left parameter to maintain a stable sort.
        -:  921:      Current = mergeUseLists(Slots[I], Current, Cmp);
        -:  922:      Slots[I] = nullptr;
        -:  923:    }
        -:  924:    // Check if this is a new slot.
        -:  925:    if (I == NumSlots) {
        -:  926:      ++NumSlots;
        -:  927:      assert(NumSlots <= MaxSlots && "Use list bigger than 2^32");
        -:  928:    }
        -:  929:
        -:  930:    // Found an open slot.
        -:  931:    Slots[I] = Current;
        -:  932:  }
        -:  933:
        -:  934:  // Merge all the lists together.
        -:  935:  assert(Next && "Expected one more Use");
        -:  936:  assert(!Next->Next && "Expected only one Use");
        -:  937:  UseList = Next;
        -:  938:  for (unsigned I = 0; I < NumSlots; ++I)
        -:  939:    if (Slots[I])
        -:  940:      // Since the uses in Slots[I] originally preceded those in UseList, send
        -:  941:      // Slots[I] in as the left parameter to maintain a stable sort.
        -:  942:      UseList = mergeUseLists(Slots[I], UseList, Cmp);
        -:  943:
        -:  944:  // Fix the Prev pointers.
        -:  945:  for (Use *I = UseList, **Prev = &UseList; I; I = I->Next) {
        -:  946:    I->Prev = Prev;
        -:  947:    Prev = &I->Next;
        -:  948:  }
        -:  949:}
        -:  950:
        -:  951:// isa - Provide some specializations of isa so that we don't have to include
        -:  952:// the subtype header files to test to see if the value is a subclass...
        -:  953://
        -:  954:template <> struct isa_impl<Constant, Value> {
        -:  955:  static inline bool doit(const Value &Val) {
        -:  956:    static_assert(Value::ConstantFirstVal == 0, "Val.getValueID() >= Value::ConstantFirstVal");
        -:  957:    return Val.getValueID() <= Value::ConstantLastVal;
        -:  958:  }
        -:  959:};
        -:  960:
        -:  961:template <> struct isa_impl<ConstantData, Value> {
        -:  962:  static inline bool doit(const Value &Val) {
        -:  963:    return Val.getValueID() >= Value::ConstantDataFirstVal &&
        -:  964:           Val.getValueID() <= Value::ConstantDataLastVal;
        -:  965:  }
        -:  966:};
        -:  967:
        -:  968:template <> struct isa_impl<ConstantAggregate, Value> {
        -:  969:  static inline bool doit(const Value &Val) {
        -:  970:    return Val.getValueID() >= Value::ConstantAggregateFirstVal &&
        -:  971:           Val.getValueID() <= Value::ConstantAggregateLastVal;
        -:  972:  }
        -:  973:};
        -:  974:
        -:  975:template <> struct isa_impl<Argument, Value> {
        -:  976:  static inline bool doit (const Value &Val) {
        -:  977:    return Val.getValueID() == Value::ArgumentVal;
        -:  978:  }
        -:  979:};
        -:  980:
        -:  981:template <> struct isa_impl<InlineAsm, Value> {
        -:  982:  static inline bool doit(const Value &Val) {
        -:  983:    return Val.getValueID() == Value::InlineAsmVal;
        -:  984:  }
        -:  985:};
        -:  986:
        -:  987:template <> struct isa_impl<Instruction, Value> {
        -:  988:  static inline bool doit(const Value &Val) {
        -:  989:    return Val.getValueID() >= Value::InstructionVal;
        -:  990:  }
        -:  991:};
        -:  992:
        -:  993:template <> struct isa_impl<BasicBlock, Value> {
        -:  994:  static inline bool doit(const Value &Val) {
        -:  995:    return Val.getValueID() == Value::BasicBlockVal;
        -:  996:  }
        -:  997:};
        -:  998:
        -:  999:template <> struct isa_impl<Function, Value> {
        -: 1000:  static inline bool doit(const Value &Val) {
        -: 1001:    return Val.getValueID() == Value::FunctionVal;
        -: 1002:  }
        -: 1003:};
        -: 1004:
        -: 1005:template <> struct isa_impl<GlobalVariable, Value> {
        -: 1006:  static inline bool doit(const Value &Val) {
        -: 1007:    return Val.getValueID() == Value::GlobalVariableVal;
        -: 1008:  }
        -: 1009:};
        -: 1010:
        -: 1011:template <> struct isa_impl<GlobalAlias, Value> {
        -: 1012:  static inline bool doit(const Value &Val) {
        -: 1013:    return Val.getValueID() == Value::GlobalAliasVal;
        -: 1014:  }
        -: 1015:};
        -: 1016:
        -: 1017:template <> struct isa_impl<GlobalIFunc, Value> {
        -: 1018:  static inline bool doit(const Value &Val) {
        -: 1019:    return Val.getValueID() == Value::GlobalIFuncVal;
        -: 1020:  }
        -: 1021:};
        -: 1022:
        -: 1023:template <> struct isa_impl<GlobalValue, Value> {
        -: 1024:  static inline bool doit(const Value &Val) {
        -: 1025:    return isa<GlobalObject>(Val) || isa<GlobalAlias>(Val);
        -: 1026:  }
        -: 1027:};
        -: 1028:
        -: 1029:template <> struct isa_impl<GlobalObject, Value> {
        -: 1030:  static inline bool doit(const Value &Val) {
        -: 1031:    return isa<GlobalVariable>(Val) || isa<Function>(Val) ||
        -: 1032:           isa<GlobalIFunc>(Val);
        -: 1033:  }
        -: 1034:};
        -: 1035:
        -: 1036:// Create wrappers for C Binding types (see CBindingWrapping.h).
        -: 1037:DEFINE_ISA_CONVERSION_FUNCTIONS(Value, LLVMValueRef)
        -: 1038:
        -: 1039:// Specialized opaque value conversions.
        -: 1040:inline Value **unwrap(LLVMValueRef *Vals) {
        -: 1041:  return reinterpret_cast<Value**>(Vals);
        -: 1042:}
        -: 1043:
        -: 1044:template<typename T>
        -: 1045:inline T **unwrap(LLVMValueRef *Vals, unsigned Length) {
        -: 1046:#ifndef NDEBUG
        -: 1047:  for (LLVMValueRef *I = Vals, *E = Vals + Length; I != E; ++I)
        -: 1048:    unwrap<T>(*I); // For side effect of calling assert on invalid usage.
        -: 1049:#endif
        -: 1050:  (void)Length;
        -: 1051:  return reinterpret_cast<T**>(Vals);
        -: 1052:}
        -: 1053:
        -: 1054:inline LLVMValueRef *wrap(const Value **Vals) {
        -: 1055:  return reinterpret_cast<LLVMValueRef*>(const_cast<Value**>(Vals));
        -: 1056:}
        -: 1057:
        -: 1058:} // end namespace llvm
        -: 1059:
        -: 1060:#endif // LLVM_IR_VALUE_H
